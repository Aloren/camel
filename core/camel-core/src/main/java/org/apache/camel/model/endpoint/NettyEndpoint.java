/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.endpoint;

import java.io.File;
import java.util.List;
import java.util.Map;
import javax.annotation.Generated;
import org.apache.camel.ExchangePattern;
import org.apache.camel.LoggingLevel;
import org.apache.camel.spi.ExceptionHandler;

/**
 * Socket level networking using TCP or UDP with the Netty 4.x library.
 * 
 * Generated by camel-package-maven-plugin - do not edit this file!
 */
@Generated("org.apache.camel.maven.packaging.EndpointDslMojo")
public class NettyEndpoint {


    public static class NettyCommon extends EndpointConfiguration {
        /**
         * The protocol to use which can be tcp or udp. The option is a
         * java.lang.String type.
         */
        private String protocol;
        /**
         * The hostname. For the consumer the hostname is localhost or 0.0.0.0.
         * For the producer the hostname is the remote host to connect to. The
         * option is a java.lang.String type.
         */
        private String host;
        /**
         * The host port number. The option is a int type.
         */
        private int port;
        /**
         * Whether or not to disconnect(close) from Netty Channel right after
         * use. Can be used for both consumer and producer. The option is a
         * boolean type.
         */
        private boolean disconnect;
        /**
         * Setting to ensure socket is not closed due to inactivity. The option
         * is a boolean type.
         */
        private boolean keepAlive;
        /**
         * Setting to facilitate socket multiplexing. The option is a boolean
         * type.
         */
        private boolean reuseAddress;
        /**
         * This option allows producers and consumers (in client mode) to reuse
         * the same Netty Channel for the lifecycle of processing the Exchange.
         * This is useful if you need to call a server multiple times in a Camel
         * route and want to use the same network connection. When using this,
         * the channel is not returned to the connection pool until the Exchange
         * is done; or disconnected if the disconnect option is set to true. The
         * reused Channel is stored on the Exchange as an exchange property with
         * the key NettyConstants#NETTY_CHANNEL which allows you to obtain the
         * channel during routing and use it as well. The option is a boolean
         * type.
         */
        private boolean reuseChannel;
        /**
         * Setting to set endpoint as one-way or request-response. The option is
         * a boolean type.
         */
        private boolean sync;
        /**
         * Setting to improve TCP protocol performance. The option is a boolean
         * type.
         */
        private boolean tcpNoDelay;
        /**
         * Only used for TCP when transferExchange is true. When set to true,
         * serializable objects in headers and properties will be added to the
         * exchange. Otherwise Camel will exclude any non-serializable objects
         * and log it at WARN level. The option is a boolean type.
         */
        private boolean allowSerializedHeaders;
        /**
         * Whether the endpoint should use basic property binding (Camel 2.x) or
         * the newer property binding with additional capabilities. The option
         * is a boolean type.
         */
        private boolean basicPropertyBinding;
        /**
         * To use a custom configured NettyServerBootstrapConfiguration for
         * configuring this endpoint. The option is a
         * org.apache.camel.component.netty4.NettyServerBootstrapConfiguration
         * type.
         */
        private Object bootstrapConfiguration;
        /**
         * To use a explicit ChannelGroup. The option is a
         * io.netty.channel.group.ChannelGroup type.
         */
        private Object channelGroup;
        /**
         * Whether to use native transport instead of NIO. Native transport
         * takes advantage of the host operating system and is only supported on
         * some platforms. You need to add the netty JAR for the host operating
         * system you are using. See more details at:
         * http://netty.io/wiki/native-transports.html. The option is a boolean
         * type.
         */
        private boolean nativeTransport;
        /**
         * Allows to configure additional netty options using option. as prefix.
         * For example option.child.keepAlive=false to set the netty option
         * child.keepAlive=false. See the Netty documentation for possible
         * options that can be used. The option is a
         * java.util.Map<java.lang.String,java.lang.Object> type.
         */
        private Map<String, Object> options;
        /**
         * The TCP/UDP buffer sizes to be used during inbound communication.
         * Size is bytes. The option is a int type.
         */
        private int receiveBufferSize;
        /**
         * Configures the buffer size predictor. See details at Jetty
         * documentation and this mail thread. The option is a int type.
         */
        private int receiveBufferSizePredictor;
        /**
         * The TCP/UDP buffer sizes to be used during outbound communication.
         * Size is bytes. The option is a int type.
         */
        private int sendBufferSize;
        /**
         * Sets whether synchronous processing should be strictly used, or Camel
         * is allowed to use asynchronous processing (if supported). The option
         * is a boolean type.
         */
        private boolean synchronous;
        /**
         * Only used for TCP. You can transfer the exchange over the wire
         * instead of just the body. The following fields are transferred: In
         * body, Out body, fault body, In headers, Out headers, fault headers,
         * exchange properties, exchange exception. This requires that the
         * objects are serializable. Camel will exclude any non-serializable
         * objects and log it at WARN level. The option is a boolean type.
         */
        private boolean transferExchange;
        /**
         * For UDP only. If enabled the using byte array codec instead of Java
         * serialization protocol. The option is a boolean type.
         */
        private boolean udpByteArrayCodec;
        /**
         * When netty works on nio mode, it uses default workerCount parameter
         * from Netty, which is cpu_core_threads x 2. User can use this
         * operation to override the default workerCount from Netty. The option
         * is a int type.
         */
        private int workerCount;
        /**
         * To use a explicit EventLoopGroup as the boss thread pool. For example
         * to share a thread pool with multiple consumers or producers. By
         * default each consumer or producer has their own worker pool with 2 x
         * cpu count core threads. The option is a
         * io.netty.channel.EventLoopGroup type.
         */
        private Object workerGroup;
        /**
         * The netty component installs a default codec if both, encoder/decoder
         * is null and textline is false. Setting allowDefaultCodec to false
         * prevents the netty component from installing a default codec as the
         * first element in the filter chain. The option is a boolean type.
         */
        private boolean allowDefaultCodec;
        /**
         * Whether or not to auto append missing end delimiter when sending
         * using the textline codec. The option is a boolean type.
         */
        private boolean autoAppendDelimiter;
        /**
         * A custom ChannelHandler class that can be used to perform special
         * marshalling of inbound payloads. The option is a
         * io.netty.channel.ChannelHandler type.
         */
        @Deprecated
        private Object decoder;
        /**
         * The max line length to use for the textline codec. The option is a
         * int type.
         */
        private int decoderMaxLineLength;
        /**
         * A list of decoders to be used. You can use a String which have values
         * separated by comma, and have the values be looked up in the Registry.
         * Just remember to prefix the value with # so Camel knows it should
         * lookup. The option is a java.lang.String type.
         */
        private List<Object> decoders;
        /**
         * The delimiter to use for the textline codec. Possible values are LINE
         * and NULL. The option is a
         * org.apache.camel.component.netty4.TextLineDelimiter type.
         */
        private TextLineDelimiter delimiter;
        /**
         * A custom ChannelHandler class that can be used to perform special
         * marshalling of outbound payloads. The option is a
         * io.netty.channel.ChannelHandler type.
         */
        @Deprecated
        private Object encoder;
        /**
         * A list of encoders to be used. You can use a String which have values
         * separated by comma, and have the values be looked up in the Registry.
         * Just remember to prefix the value with # so Camel knows it should
         * lookup. The option is a java.lang.String type.
         */
        private List<Object> encoders;
        /**
         * The encoding (a charset name) to use for the textline codec. If not
         * provided, Camel will use the JVM default Charset. The option is a
         * java.lang.String type.
         */
        private String encoding;
        /**
         * Only used for TCP. If no codec is specified, you can use this flag to
         * indicate a text line based codec; if not specified or the value is
         * false, then Object Serialization is assumed over TCP. The option is a
         * boolean type.
         */
        private boolean textline;
        /**
         * Which protocols to enable when using SSL. The option is a
         * java.lang.String type.
         */
        private String enabledProtocols;
        /**
         * Client side certificate keystore to be used for encryption. The
         * option is a java.io.File type.
         */
        private File keyStoreFile;
        /**
         * Keystore format to be used for payload encryption. Defaults to JKS if
         * not set. The option is a java.lang.String type.
         */
        private String keyStoreFormat;
        /**
         * Client side certificate keystore to be used for encryption. Is loaded
         * by default from classpath, but you can prefix with classpath:, file:,
         * or http: to load the resource from different systems. The option is a
         * java.lang.String type.
         */
        private String keyStoreResource;
        /**
         * Password setting to use in order to encrypt/decrypt payloads sent
         * using SSH. The option is a java.lang.String type.
         */
        private String passphrase;
        /**
         * Security provider to be used for payload encryption. Defaults to
         * SunX509 if not set. The option is a java.lang.String type.
         */
        private String securityProvider;
        /**
         * Setting to specify whether SSL encryption is applied to this
         * endpoint. The option is a boolean type.
         */
        private boolean ssl;
        /**
         * When enabled and in SSL mode, then the Netty consumer will enrich the
         * Camel Message with headers having information about the client
         * certificate such as subject name, issuer name, serial number, and the
         * valid date range. The option is a boolean type.
         */
        private boolean sslClientCertHeaders;
        /**
         * To configure security using SSLContextParameters. The option is a
         * org.apache.camel.support.jsse.SSLContextParameters type.
         */
        private Object sslContextParameters;
        /**
         * Reference to a class that could be used to return an SSL Handler. The
         * option is a io.netty.handler.ssl.SslHandler type.
         */
        private Object sslHandler;
        /**
         * Server side certificate keystore to be used for encryption. The
         * option is a java.io.File type.
         */
        private File trustStoreFile;
        /**
         * Server side certificate keystore to be used for encryption. Is loaded
         * by default from classpath, but you can prefix with classpath:, file:,
         * or http: to load the resource from different systems. The option is a
         * java.lang.String type.
         */
        private String trustStoreResource;

        public String getProtocol() {
            return protocol;
        }

        public void setProtocol(String protocol) {
            this.protocol = protocol;
        }

        public String getHost() {
            return host;
        }

        public void setHost(String host) {
            this.host = host;
        }

        public int getPort() {
            return port;
        }

        public void setPort(int port) {
            this.port = port;
        }

        public boolean getDisconnect() {
            return disconnect;
        }

        public void setDisconnect(boolean disconnect) {
            this.disconnect = disconnect;
        }

        public boolean getKeepAlive() {
            return keepAlive;
        }

        public void setKeepAlive(boolean keepAlive) {
            this.keepAlive = keepAlive;
        }

        public boolean getReuseAddress() {
            return reuseAddress;
        }

        public void setReuseAddress(boolean reuseAddress) {
            this.reuseAddress = reuseAddress;
        }

        public boolean getReuseChannel() {
            return reuseChannel;
        }

        public void setReuseChannel(boolean reuseChannel) {
            this.reuseChannel = reuseChannel;
        }

        public boolean getSync() {
            return sync;
        }

        public void setSync(boolean sync) {
            this.sync = sync;
        }

        public boolean getTcpNoDelay() {
            return tcpNoDelay;
        }

        public void setTcpNoDelay(boolean tcpNoDelay) {
            this.tcpNoDelay = tcpNoDelay;
        }

        public boolean getAllowSerializedHeaders() {
            return allowSerializedHeaders;
        }

        public void setAllowSerializedHeaders(boolean allowSerializedHeaders) {
            this.allowSerializedHeaders = allowSerializedHeaders;
        }

        public boolean getBasicPropertyBinding() {
            return basicPropertyBinding;
        }

        public void setBasicPropertyBinding(boolean basicPropertyBinding) {
            this.basicPropertyBinding = basicPropertyBinding;
        }

        public Object getBootstrapConfiguration() {
            return bootstrapConfiguration;
        }

        public void setBootstrapConfiguration(Object bootstrapConfiguration) {
            this.bootstrapConfiguration = bootstrapConfiguration;
        }

        public Object getChannelGroup() {
            return channelGroup;
        }

        public void setChannelGroup(Object channelGroup) {
            this.channelGroup = channelGroup;
        }

        public boolean getNativeTransport() {
            return nativeTransport;
        }

        public void setNativeTransport(boolean nativeTransport) {
            this.nativeTransport = nativeTransport;
        }

        public Map<String, Object> getOptions() {
            return options;
        }

        public void setOptions(Map<String, Object> options) {
            this.options = options;
        }

        public int getReceiveBufferSize() {
            return receiveBufferSize;
        }

        public void setReceiveBufferSize(int receiveBufferSize) {
            this.receiveBufferSize = receiveBufferSize;
        }

        public int getReceiveBufferSizePredictor() {
            return receiveBufferSizePredictor;
        }

        public void setReceiveBufferSizePredictor(int receiveBufferSizePredictor) {
            this.receiveBufferSizePredictor = receiveBufferSizePredictor;
        }

        public int getSendBufferSize() {
            return sendBufferSize;
        }

        public void setSendBufferSize(int sendBufferSize) {
            this.sendBufferSize = sendBufferSize;
        }

        public boolean getSynchronous() {
            return synchronous;
        }

        public void setSynchronous(boolean synchronous) {
            this.synchronous = synchronous;
        }

        public boolean getTransferExchange() {
            return transferExchange;
        }

        public void setTransferExchange(boolean transferExchange) {
            this.transferExchange = transferExchange;
        }

        public boolean getUdpByteArrayCodec() {
            return udpByteArrayCodec;
        }

        public void setUdpByteArrayCodec(boolean udpByteArrayCodec) {
            this.udpByteArrayCodec = udpByteArrayCodec;
        }

        public int getWorkerCount() {
            return workerCount;
        }

        public void setWorkerCount(int workerCount) {
            this.workerCount = workerCount;
        }

        public Object getWorkerGroup() {
            return workerGroup;
        }

        public void setWorkerGroup(Object workerGroup) {
            this.workerGroup = workerGroup;
        }

        public boolean getAllowDefaultCodec() {
            return allowDefaultCodec;
        }

        public void setAllowDefaultCodec(boolean allowDefaultCodec) {
            this.allowDefaultCodec = allowDefaultCodec;
        }

        public boolean getAutoAppendDelimiter() {
            return autoAppendDelimiter;
        }

        public void setAutoAppendDelimiter(boolean autoAppendDelimiter) {
            this.autoAppendDelimiter = autoAppendDelimiter;
        }

        @Deprecated
        public Object getDecoder() {
            return decoder;
        }

        @Deprecated
        public void setDecoder(Object decoder) {
            this.decoder = decoder;
        }

        public int getDecoderMaxLineLength() {
            return decoderMaxLineLength;
        }

        public void setDecoderMaxLineLength(int decoderMaxLineLength) {
            this.decoderMaxLineLength = decoderMaxLineLength;
        }

        public List<Object> getDecoders() {
            return decoders;
        }

        public void setDecoders(List<Object> decoders) {
            this.decoders = decoders;
        }

        public TextLineDelimiter getDelimiter() {
            return delimiter;
        }

        public void setDelimiter(TextLineDelimiter delimiter) {
            this.delimiter = delimiter;
        }

        @Deprecated
        public Object getEncoder() {
            return encoder;
        }

        @Deprecated
        public void setEncoder(Object encoder) {
            this.encoder = encoder;
        }

        public List<Object> getEncoders() {
            return encoders;
        }

        public void setEncoders(List<Object> encoders) {
            this.encoders = encoders;
        }

        public String getEncoding() {
            return encoding;
        }

        public void setEncoding(String encoding) {
            this.encoding = encoding;
        }

        public boolean getTextline() {
            return textline;
        }

        public void setTextline(boolean textline) {
            this.textline = textline;
        }

        public String getEnabledProtocols() {
            return enabledProtocols;
        }

        public void setEnabledProtocols(String enabledProtocols) {
            this.enabledProtocols = enabledProtocols;
        }

        public File getKeyStoreFile() {
            return keyStoreFile;
        }

        public void setKeyStoreFile(File keyStoreFile) {
            this.keyStoreFile = keyStoreFile;
        }

        public String getKeyStoreFormat() {
            return keyStoreFormat;
        }

        public void setKeyStoreFormat(String keyStoreFormat) {
            this.keyStoreFormat = keyStoreFormat;
        }

        public String getKeyStoreResource() {
            return keyStoreResource;
        }

        public void setKeyStoreResource(String keyStoreResource) {
            this.keyStoreResource = keyStoreResource;
        }

        public String getPassphrase() {
            return passphrase;
        }

        public void setPassphrase(String passphrase) {
            this.passphrase = passphrase;
        }

        public String getSecurityProvider() {
            return securityProvider;
        }

        public void setSecurityProvider(String securityProvider) {
            this.securityProvider = securityProvider;
        }

        public boolean getSsl() {
            return ssl;
        }

        public void setSsl(boolean ssl) {
            this.ssl = ssl;
        }

        public boolean getSslClientCertHeaders() {
            return sslClientCertHeaders;
        }

        public void setSslClientCertHeaders(boolean sslClientCertHeaders) {
            this.sslClientCertHeaders = sslClientCertHeaders;
        }

        public Object getSslContextParameters() {
            return sslContextParameters;
        }

        public void setSslContextParameters(Object sslContextParameters) {
            this.sslContextParameters = sslContextParameters;
        }

        public Object getSslHandler() {
            return sslHandler;
        }

        public void setSslHandler(Object sslHandler) {
            this.sslHandler = sslHandler;
        }

        public File getTrustStoreFile() {
            return trustStoreFile;
        }

        public void setTrustStoreFile(File trustStoreFile) {
            this.trustStoreFile = trustStoreFile;
        }

        public String getTrustStoreResource() {
            return trustStoreResource;
        }

        public void setTrustStoreResource(String trustStoreResource) {
            this.trustStoreResource = trustStoreResource;
        }
    }

    public static class NettyConsumer extends NettyCommon {
        /**
         * Allows for bridging the consumer to the Camel routing Error Handler,
         * which mean any exceptions occurred while the consumer is trying to
         * pickup incoming messages, or the likes, will now be processed as a
         * message and handled by the routing Error Handler. By default the
         * consumer will use the org.apache.camel.spi.ExceptionHandler to deal
         * with exceptions, that will be logged at WARN or ERROR level and
         * ignored. The option is a boolean type.
         */
        private boolean bridgeErrorHandler;
        /**
         * Setting to choose Multicast over UDP. The option is a boolean type.
         */
        private boolean broadcast;
        /**
         * If the clientMode is true, netty consumer will connect the address as
         * a TCP client. The option is a boolean type.
         */
        private boolean clientMode;
        /**
         * Used only in clientMode in consumer, the consumer will attempt to
         * reconnect on disconnection if this is enabled. The option is a
         * boolean type.
         */
        private boolean reconnect;
        /**
         * Used if reconnect and clientMode is enabled. The interval in milli
         * seconds to attempt reconnection. The option is a int type.
         */
        private int reconnectInterval;
        /**
         * Allows to configure a backlog for netty consumer (server). Note the
         * backlog is just a best effort depending on the OS. Setting this
         * option to a value such as 200, 500 or 1000, tells the TCP stack how
         * long the accept queue can be If this option is not configured, then
         * the backlog depends on OS setting. The option is a int type.
         */
        private int backlog;
        /**
         * When netty works on nio mode, it uses default bossCount parameter
         * from Netty, which is 1. User can use this operation to override the
         * default bossCount from Netty. The option is a int type.
         */
        private int bossCount;
        /**
         * Set the BossGroup which could be used for handling the new connection
         * of the server side across the NettyEndpoint. The option is a
         * io.netty.channel.EventLoopGroup type.
         */
        private Object bossGroup;
        /**
         * If sync is enabled then this option dictates NettyConsumer if it
         * should disconnect where there is no reply to send back. The option is
         * a boolean type.
         */
        private boolean disconnectOnNoReply;
        /**
         * To let the consumer use a custom ExceptionHandler. Notice if the
         * option bridgeErrorHandler is enabled then this option is not in use.
         * By default the consumer will deal with exceptions, that will be
         * logged at WARN or ERROR level and ignored. The option is a
         * org.apache.camel.spi.ExceptionHandler type.
         */
        private ExceptionHandler exceptionHandler;
        /**
         * Sets the exchange pattern when the consumer creates an exchange. The
         * option is a org.apache.camel.ExchangePattern type.
         */
        private ExchangePattern exchangePattern;
        /**
         * To use a custom NettyServerBootstrapFactory. The option is a
         * org.apache.camel.component.netty4.NettyServerBootstrapFactory type.
         */
        private Object nettyServerBootstrapFactory;
        /**
         * When using UDP then this option can be used to specify a network
         * interface by its name, such as eth0 to join a multicast group. The
         * option is a java.lang.String type.
         */
        private String networkInterface;
        /**
         * If sync is enabled this option dictates NettyConsumer which logging
         * level to use when logging a there is no reply to send back. The
         * option is a org.apache.camel.LoggingLevel type.
         */
        private LoggingLevel noReplyLogLevel;
        /**
         * If the server (NettyConsumer) catches an
         * java.nio.channels.ClosedChannelException then its logged using this
         * logging level. This is used to avoid logging the closed channel
         * exceptions, as clients can disconnect abruptly and then cause a flood
         * of closed exceptions in the Netty server. The option is a
         * org.apache.camel.LoggingLevel type.
         */
        private LoggingLevel serverClosedChannelExceptionCaughtLogLevel;
        /**
         * If the server (NettyConsumer) catches an exception then its logged
         * using this logging level. The option is a
         * org.apache.camel.LoggingLevel type.
         */
        private LoggingLevel serverExceptionCaughtLogLevel;
        /**
         * To use a custom ServerInitializerFactory. The option is a
         * org.apache.camel.component.netty4.ServerInitializerFactory type.
         */
        private Object serverInitializerFactory;
        /**
         * Whether to use ordered thread pool, to ensure events are processed
         * orderly on the same channel. The option is a boolean type.
         */
        private boolean usingExecutorService;
        /**
         * Configures whether the server needs client authentication when using
         * SSL. The option is a boolean type.
         */
        private boolean needClientAuth;

        public boolean getBridgeErrorHandler() {
            return bridgeErrorHandler;
        }

        public void setBridgeErrorHandler(boolean bridgeErrorHandler) {
            this.bridgeErrorHandler = bridgeErrorHandler;
        }

        public boolean getBroadcast() {
            return broadcast;
        }

        public void setBroadcast(boolean broadcast) {
            this.broadcast = broadcast;
        }

        public boolean getClientMode() {
            return clientMode;
        }

        public void setClientMode(boolean clientMode) {
            this.clientMode = clientMode;
        }

        public boolean getReconnect() {
            return reconnect;
        }

        public void setReconnect(boolean reconnect) {
            this.reconnect = reconnect;
        }

        public int getReconnectInterval() {
            return reconnectInterval;
        }

        public void setReconnectInterval(int reconnectInterval) {
            this.reconnectInterval = reconnectInterval;
        }

        public int getBacklog() {
            return backlog;
        }

        public void setBacklog(int backlog) {
            this.backlog = backlog;
        }

        public int getBossCount() {
            return bossCount;
        }

        public void setBossCount(int bossCount) {
            this.bossCount = bossCount;
        }

        public Object getBossGroup() {
            return bossGroup;
        }

        public void setBossGroup(Object bossGroup) {
            this.bossGroup = bossGroup;
        }

        public boolean getDisconnectOnNoReply() {
            return disconnectOnNoReply;
        }

        public void setDisconnectOnNoReply(boolean disconnectOnNoReply) {
            this.disconnectOnNoReply = disconnectOnNoReply;
        }

        public ExceptionHandler getExceptionHandler() {
            return exceptionHandler;
        }

        public void setExceptionHandler(ExceptionHandler exceptionHandler) {
            this.exceptionHandler = exceptionHandler;
        }

        public ExchangePattern getExchangePattern() {
            return exchangePattern;
        }

        public void setExchangePattern(ExchangePattern exchangePattern) {
            this.exchangePattern = exchangePattern;
        }

        public Object getNettyServerBootstrapFactory() {
            return nettyServerBootstrapFactory;
        }

        public void setNettyServerBootstrapFactory(
                Object nettyServerBootstrapFactory) {
            this.nettyServerBootstrapFactory = nettyServerBootstrapFactory;
        }

        public String getNetworkInterface() {
            return networkInterface;
        }

        public void setNetworkInterface(String networkInterface) {
            this.networkInterface = networkInterface;
        }

        public LoggingLevel getNoReplyLogLevel() {
            return noReplyLogLevel;
        }

        public void setNoReplyLogLevel(LoggingLevel noReplyLogLevel) {
            this.noReplyLogLevel = noReplyLogLevel;
        }

        public LoggingLevel getServerClosedChannelExceptionCaughtLogLevel() {
            return serverClosedChannelExceptionCaughtLogLevel;
        }

        public void setServerClosedChannelExceptionCaughtLogLevel(
                LoggingLevel serverClosedChannelExceptionCaughtLogLevel) {
            this.serverClosedChannelExceptionCaughtLogLevel = serverClosedChannelExceptionCaughtLogLevel;
        }

        public LoggingLevel getServerExceptionCaughtLogLevel() {
            return serverExceptionCaughtLogLevel;
        }

        public void setServerExceptionCaughtLogLevel(
                LoggingLevel serverExceptionCaughtLogLevel) {
            this.serverExceptionCaughtLogLevel = serverExceptionCaughtLogLevel;
        }

        public Object getServerInitializerFactory() {
            return serverInitializerFactory;
        }

        public void setServerInitializerFactory(Object serverInitializerFactory) {
            this.serverInitializerFactory = serverInitializerFactory;
        }

        public boolean getUsingExecutorService() {
            return usingExecutorService;
        }

        public void setUsingExecutorService(boolean usingExecutorService) {
            this.usingExecutorService = usingExecutorService;
        }

        public boolean getNeedClientAuth() {
            return needClientAuth;
        }

        public void setNeedClientAuth(boolean needClientAuth) {
            this.needClientAuth = needClientAuth;
        }
    }

    public static class NettyProducer extends NettyCommon {
        /**
         * Time to wait for a socket connection to be available. Value is in
         * milliseconds. The option is a int type.
         */
        private int connectTimeout;
        /**
         * Allows to use a timeout for the Netty producer when calling a remote
         * server. By default no timeout is in use. The value is in milli
         * seconds, so eg 30000 is 30 seconds. The requestTimeout is using
         * Netty's ReadTimeoutHandler to trigger the timeout. The option is a
         * long type.
         */
        private long requestTimeout;
        /**
         * To use a custom ClientInitializerFactory. The option is a
         * org.apache.camel.component.netty4.ClientInitializerFactory type.
         */
        private Object clientInitializerFactory;
        /**
         * To use a custom correlation manager to manage how request and reply
         * messages are mapped when using request/reply with the netty producer.
         * This should only be used if you have a way to map requests together
         * with replies such as if there is correlation ids in both the request
         * and reply messages. This can be used if you want to multiplex
         * concurrent messages on the same channel (aka connection) in netty.
         * When doing this you must have a way to correlate the request and
         * reply messages so you can store the right reply on the inflight Camel
         * Exchange before its continued routed. We recommend extending the
         * TimeoutCorrelationManagerSupport when you build custom correlation
         * managers. This provides support for timeout and other complexities
         * you otherwise would need to implement as well. See also the
         * producerPoolEnabled option for more details. The option is a
         * org.apache.camel.component.netty4.NettyCamelStateCorrelationManager
         * type.
         */
        private Object correlationManager;
        /**
         * Channels can be lazily created to avoid exceptions, if the remote
         * server is not up and running when the Camel producer is started. The
         * option is a boolean type.
         */
        private boolean lazyChannelCreation;
        /**
         * Whether producer pool is enabled or not. Important: If you turn this
         * off then a single shared connection is used for the producer, also if
         * you are doing request/reply. That means there is a potential issue
         * with interleaved responses if replies comes back out-of-order.
         * Therefore you need to have a correlation id in both the request and
         * reply messages so you can properly correlate the replies to the Camel
         * callback that is responsible for continue processing the message in
         * Camel. To do this you need to implement
         * NettyCamelStateCorrelationManager as correlation manager and
         * configure it via the correlationManager option. See also the
         * correlationManager option for more details. The option is a boolean
         * type.
         */
        private boolean producerPoolEnabled;
        /**
         * Sets the cap on the number of objects that can be allocated by the
         * pool (checked out to clients, or idle awaiting checkout) at a given
         * time. Use a negative value for no limit. The option is a int type.
         */
        private int producerPoolMaxActive;
        /**
         * Sets the cap on the number of idle instances in the pool. The option
         * is a int type.
         */
        private int producerPoolMaxIdle;
        /**
         * Sets the minimum amount of time (value in millis) an object may sit
         * idle in the pool before it is eligible for eviction by the idle
         * object evictor. The option is a long type.
         */
        private long producerPoolMinEvictableIdle;
        /**
         * Sets the minimum number of instances allowed in the producer pool
         * before the evictor thread (if active) spawns new objects. The option
         * is a int type.
         */
        private int producerPoolMinIdle;
        /**
         * This option supports connection less udp sending which is a real fire
         * and forget. A connected udp send receive the PortUnreachableException
         * if no one is listen on the receiving port. The option is a boolean
         * type.
         */
        private boolean udpConnectionlessSending;
        /**
         * If the useByteBuf is true, netty producer will turn the message body
         * into ByteBuf before sending it out. The option is a boolean type.
         */
        private boolean useByteBuf;

        public int getConnectTimeout() {
            return connectTimeout;
        }

        public void setConnectTimeout(int connectTimeout) {
            this.connectTimeout = connectTimeout;
        }

        public long getRequestTimeout() {
            return requestTimeout;
        }

        public void setRequestTimeout(long requestTimeout) {
            this.requestTimeout = requestTimeout;
        }

        public Object getClientInitializerFactory() {
            return clientInitializerFactory;
        }

        public void setClientInitializerFactory(Object clientInitializerFactory) {
            this.clientInitializerFactory = clientInitializerFactory;
        }

        public Object getCorrelationManager() {
            return correlationManager;
        }

        public void setCorrelationManager(Object correlationManager) {
            this.correlationManager = correlationManager;
        }

        public boolean getLazyChannelCreation() {
            return lazyChannelCreation;
        }

        public void setLazyChannelCreation(boolean lazyChannelCreation) {
            this.lazyChannelCreation = lazyChannelCreation;
        }

        public boolean getProducerPoolEnabled() {
            return producerPoolEnabled;
        }

        public void setProducerPoolEnabled(boolean producerPoolEnabled) {
            this.producerPoolEnabled = producerPoolEnabled;
        }

        public int getProducerPoolMaxActive() {
            return producerPoolMaxActive;
        }

        public void setProducerPoolMaxActive(int producerPoolMaxActive) {
            this.producerPoolMaxActive = producerPoolMaxActive;
        }

        public int getProducerPoolMaxIdle() {
            return producerPoolMaxIdle;
        }

        public void setProducerPoolMaxIdle(int producerPoolMaxIdle) {
            this.producerPoolMaxIdle = producerPoolMaxIdle;
        }

        public long getProducerPoolMinEvictableIdle() {
            return producerPoolMinEvictableIdle;
        }

        public void setProducerPoolMinEvictableIdle(
                long producerPoolMinEvictableIdle) {
            this.producerPoolMinEvictableIdle = producerPoolMinEvictableIdle;
        }

        public int getProducerPoolMinIdle() {
            return producerPoolMinIdle;
        }

        public void setProducerPoolMinIdle(int producerPoolMinIdle) {
            this.producerPoolMinIdle = producerPoolMinIdle;
        }

        public boolean getUdpConnectionlessSending() {
            return udpConnectionlessSending;
        }

        public void setUdpConnectionlessSending(boolean udpConnectionlessSending) {
            this.udpConnectionlessSending = udpConnectionlessSending;
        }

        public boolean getUseByteBuf() {
            return useByteBuf;
        }

        public void setUseByteBuf(boolean useByteBuf) {
            this.useByteBuf = useByteBuf;
        }
    }

    public static enum TextLineDelimiter {
        LINE, NULL;
    }
}