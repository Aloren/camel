/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.endpoint;

import javax.annotation.Generated;
import org.apache.camel.ExchangePattern;
import org.apache.camel.LoggingLevel;
import org.apache.camel.spi.ExceptionHandler;
import org.apache.camel.spi.HeaderFilterStrategy;

/**
 * The sjms2 component (simple jms) allows messages to be sent to (or consumed
 * from) a JMS Queue or Topic (uses JMS 2.x API).
 * 
 * Generated by camel-package-maven-plugin - do not edit this file!
 */
@Generated("org.apache.camel.maven.packaging.EndpointDslMojo")
public class Sjms2Endpoint {


    public static class Sjms2Common<T extends EndpointConfiguration>
            extends
                EndpointConfiguration<T> {
        private String destinationType;
        private String destinationName;
        private SessionAcknowledgementType acknowledgementMode;
        private Boolean asyncStartListener;
        private Boolean asyncStopListener;
        private Boolean basicPropertyBinding;
        private Integer connectionCount;
        private Object connectionFactory;
        private Object connectionResource;
        private Object destinationCreationStrategy;
        private Object exceptionListener;
        private HeaderFilterStrategy headerFilterStrategy;
        private Boolean includeAllJMSXProperties;
        private Object jmsKeyFormatStrategy;
        private Boolean mapJmsMessage;
        private Object messageCreatedStrategy;
        private Object transactionCommitStrategy;
        private Boolean sharedJMSSession;

        /**
         * The kind of destination to use. The option is a java.lang.String
         * type.
         */
        public T destinationType(String destinationType) {
            this.destinationType = destinationType;
            return (T) this;
        }

        /**
         * DestinationName is a JMS queue or topic name. By default, the
         * destinationName is interpreted as a queue name. The option is a
         * java.lang.String type.
         */
        public T destinationName(String destinationName) {
            this.destinationName = destinationName;
            return (T) this;
        }

        /**
         * The JMS acknowledgement name, which is one of: SESSION_TRANSACTED,
         * CLIENT_ACKNOWLEDGE, AUTO_ACKNOWLEDGE, DUPS_OK_ACKNOWLEDGE. The option
         * is a org.apache.camel.component.sjms.jms.SessionAcknowledgementType
         * type.
         */
        public T acknowledgementMode(
                SessionAcknowledgementType acknowledgementMode) {
            this.acknowledgementMode = acknowledgementMode;
            return (T) this;
        }

        /**
         * Whether to startup the consumer message listener asynchronously, when
         * starting a route. For example if a JmsConsumer cannot get a
         * connection to a remote JMS broker, then it may block while retrying
         * and/or failover. This will cause Camel to block while starting
         * routes. By setting this option to true, you will let routes startup,
         * while the JmsConsumer connects to the JMS broker using a dedicated
         * thread in asynchronous mode. If this option is used, then beware that
         * if the connection could not be established, then an exception is
         * logged at WARN level, and the consumer will not be able to receive
         * messages; You can then restart the route to retry. The option is a
         * boolean type.
         */
        public T asyncStartListener(boolean asyncStartListener) {
            this.asyncStartListener = asyncStartListener;
            return (T) this;
        }

        /**
         * Whether to stop the consumer message listener asynchronously, when
         * stopping a route. The option is a boolean type.
         */
        public T asyncStopListener(boolean asyncStopListener) {
            this.asyncStopListener = asyncStopListener;
            return (T) this;
        }

        /**
         * Whether the endpoint should use basic property binding (Camel 2.x) or
         * the newer property binding with additional capabilities. The option
         * is a boolean type.
         */
        public T basicPropertyBinding(boolean basicPropertyBinding) {
            this.basicPropertyBinding = basicPropertyBinding;
            return (T) this;
        }

        /**
         * The maximum number of connections available to this endpoint. The
         * option is a java.lang.Integer type.
         */
        public T connectionCount(Integer connectionCount) {
            this.connectionCount = connectionCount;
            return (T) this;
        }

        /**
         * Initializes the connectionFactory for the endpoint, which takes
         * precedence over the component's connectionFactory, if any. The option
         * is a javax.jms.ConnectionFactory type.
         */
        public T connectionFactory(Object connectionFactory) {
            this.connectionFactory = connectionFactory;
            return (T) this;
        }

        /**
         * Initializes the connectionResource for the endpoint, which takes
         * precedence over the component's connectionResource, if any. The
         * option is a org.apache.camel.component.sjms.jms.ConnectionResource
         * type.
         */
        public T connectionResource(Object connectionResource) {
            this.connectionResource = connectionResource;
            return (T) this;
        }

        /**
         * To use a custom DestinationCreationStrategy. The option is a
         * org.apache.camel.component.sjms.jms.DestinationCreationStrategy type.
         */
        public T destinationCreationStrategy(Object destinationCreationStrategy) {
            this.destinationCreationStrategy = destinationCreationStrategy;
            return (T) this;
        }

        /**
         * Specifies the JMS Exception Listener that is to be notified of any
         * underlying JMS exceptions. The option is a
         * javax.jms.ExceptionListener type.
         */
        public T exceptionListener(Object exceptionListener) {
            this.exceptionListener = exceptionListener;
            return (T) this;
        }

        /**
         * To use a custom HeaderFilterStrategy to filter header to and from
         * Camel message. The option is a
         * org.apache.camel.spi.HeaderFilterStrategy type.
         */
        public T headerFilterStrategy(HeaderFilterStrategy headerFilterStrategy) {
            this.headerFilterStrategy = headerFilterStrategy;
            return (T) this;
        }

        /**
         * Whether to include all JMSXxxx properties when mapping from JMS to
         * Camel Message. Setting this to true will include properties such as
         * JMSXAppID, and JMSXUserID etc. Note: If you are using a custom
         * headerFilterStrategy then this option does not apply. The option is a
         * boolean type.
         */
        public T includeAllJMSXProperties(boolean includeAllJMSXProperties) {
            this.includeAllJMSXProperties = includeAllJMSXProperties;
            return (T) this;
        }

        /**
         * Pluggable strategy for encoding and decoding JMS keys so they can be
         * compliant with the JMS specification. Camel provides two
         * implementations out of the box: default and passthrough. The default
         * strategy will safely marshal dots and hyphens (. and -). The
         * passthrough strategy leaves the key as is. Can be used for JMS
         * brokers which do not care whether JMS header keys contain illegal
         * characters. You can provide your own implementation of the
         * org.apache.camel.component.jms.JmsKeyFormatStrategy and refer to it
         * using the # notation. The option is a
         * org.apache.camel.component.sjms.jms.JmsKeyFormatStrategy type.
         */
        public T jmsKeyFormatStrategy(Object jmsKeyFormatStrategy) {
            this.jmsKeyFormatStrategy = jmsKeyFormatStrategy;
            return (T) this;
        }

        /**
         * Specifies whether Camel should auto map the received JMS message to a
         * suited payload type, such as javax.jms.TextMessage to a String etc.
         * See section about how mapping works below for more details. The
         * option is a boolean type.
         */
        public T mapJmsMessage(boolean mapJmsMessage) {
            this.mapJmsMessage = mapJmsMessage;
            return (T) this;
        }

        /**
         * To use the given MessageCreatedStrategy which are invoked when Camel
         * creates new instances of javax.jms.Message objects when Camel is
         * sending a JMS message. The option is a
         * org.apache.camel.component.sjms.jms.MessageCreatedStrategy type.
         */
        public T messageCreatedStrategy(Object messageCreatedStrategy) {
            this.messageCreatedStrategy = messageCreatedStrategy;
            return (T) this;
        }

        /**
         * Sets the commit strategy. The option is a
         * org.apache.camel.component.sjms.TransactionCommitStrategy type.
         */
        public T transactionCommitStrategy(Object transactionCommitStrategy) {
            this.transactionCommitStrategy = transactionCommitStrategy;
            return (T) this;
        }

        /**
         * Specifies whether to share JMS session with other SJMS endpoints.
         * Turn this off if your route is accessing to multiple JMS providers.
         * If you need transaction against multiple JMS providers, use jms
         * component to leverage XA transaction. The option is a boolean type.
         */
        public T sharedJMSSession(boolean sharedJMSSession) {
            this.sharedJMSSession = sharedJMSSession;
            return (T) this;
        }

        public String getDestinationType() {
            return destinationType;
        }

        public void setDestinationType(String destinationType) {
            this.destinationType = destinationType;
        }

        public String getDestinationName() {
            return destinationName;
        }

        public void setDestinationName(String destinationName) {
            this.destinationName = destinationName;
        }

        public SessionAcknowledgementType getAcknowledgementMode() {
            return acknowledgementMode;
        }

        public void setAcknowledgementMode(
                SessionAcknowledgementType acknowledgementMode) {
            this.acknowledgementMode = acknowledgementMode;
        }

        public Boolean getAsyncStartListener() {
            return asyncStartListener;
        }

        public void setAsyncStartListener(Boolean asyncStartListener) {
            this.asyncStartListener = asyncStartListener;
        }

        public Boolean getAsyncStopListener() {
            return asyncStopListener;
        }

        public void setAsyncStopListener(Boolean asyncStopListener) {
            this.asyncStopListener = asyncStopListener;
        }

        public Boolean getBasicPropertyBinding() {
            return basicPropertyBinding;
        }

        public void setBasicPropertyBinding(Boolean basicPropertyBinding) {
            this.basicPropertyBinding = basicPropertyBinding;
        }

        public Integer getConnectionCount() {
            return connectionCount;
        }

        public void setConnectionCount(Integer connectionCount) {
            this.connectionCount = connectionCount;
        }

        public Object getConnectionFactory() {
            return connectionFactory;
        }

        public void setConnectionFactory(Object connectionFactory) {
            this.connectionFactory = connectionFactory;
        }

        public Object getConnectionResource() {
            return connectionResource;
        }

        public void setConnectionResource(Object connectionResource) {
            this.connectionResource = connectionResource;
        }

        public Object getDestinationCreationStrategy() {
            return destinationCreationStrategy;
        }

        public void setDestinationCreationStrategy(
                Object destinationCreationStrategy) {
            this.destinationCreationStrategy = destinationCreationStrategy;
        }

        public Object getExceptionListener() {
            return exceptionListener;
        }

        public void setExceptionListener(Object exceptionListener) {
            this.exceptionListener = exceptionListener;
        }

        public HeaderFilterStrategy getHeaderFilterStrategy() {
            return headerFilterStrategy;
        }

        public void setHeaderFilterStrategy(
                HeaderFilterStrategy headerFilterStrategy) {
            this.headerFilterStrategy = headerFilterStrategy;
        }

        public Boolean getIncludeAllJMSXProperties() {
            return includeAllJMSXProperties;
        }

        public void setIncludeAllJMSXProperties(Boolean includeAllJMSXProperties) {
            this.includeAllJMSXProperties = includeAllJMSXProperties;
        }

        public Object getJmsKeyFormatStrategy() {
            return jmsKeyFormatStrategy;
        }

        public void setJmsKeyFormatStrategy(Object jmsKeyFormatStrategy) {
            this.jmsKeyFormatStrategy = jmsKeyFormatStrategy;
        }

        public Boolean getMapJmsMessage() {
            return mapJmsMessage;
        }

        public void setMapJmsMessage(Boolean mapJmsMessage) {
            this.mapJmsMessage = mapJmsMessage;
        }

        public Object getMessageCreatedStrategy() {
            return messageCreatedStrategy;
        }

        public void setMessageCreatedStrategy(Object messageCreatedStrategy) {
            this.messageCreatedStrategy = messageCreatedStrategy;
        }

        public Object getTransactionCommitStrategy() {
            return transactionCommitStrategy;
        }

        public void setTransactionCommitStrategy(
                Object transactionCommitStrategy) {
            this.transactionCommitStrategy = transactionCommitStrategy;
        }

        public Boolean getSharedJMSSession() {
            return sharedJMSSession;
        }

        public void setSharedJMSSession(Boolean sharedJMSSession) {
            this.sharedJMSSession = sharedJMSSession;
        }
    }

    public static class Sjms2Consumer extends Sjms2Common<Sjms2Consumer> {
        private Boolean durable;
        private Boolean shared;
        private String subscriptionId;
        private Boolean bridgeErrorHandler;
        private Integer consumerCount;
        private String durableSubscriptionId;
        private Boolean synchronous;
        private ExceptionHandler exceptionHandler;
        private ExchangePattern exchangePattern;
        private String messageSelector;
        private LoggingLevel errorHandlerLoggingLevel;
        private Boolean errorHandlerLogStackTrace;
        private Boolean transacted;
        private Integer transactionBatchCount;
        private Long transactionBatchTimeout;

        /**
         * Sets topic consumer to durable. The option is a boolean type.
         */
        public Sjms2Consumer durable(boolean durable) {
            this.durable = durable;
            return (Sjms2Consumer) this;
        }

        /**
         * Sets the consumer to shared. The option is a boolean type.
         */
        public Sjms2Consumer shared(boolean shared) {
            this.shared = shared;
            return (Sjms2Consumer) this;
        }

        /**
         * Sets the subscription Id, required for durable or shared topics. The
         * option is a java.lang.String type.
         */
        public Sjms2Consumer subscriptionId(String subscriptionId) {
            this.subscriptionId = subscriptionId;
            return (Sjms2Consumer) this;
        }

        /**
         * Allows for bridging the consumer to the Camel routing Error Handler,
         * which mean any exceptions occurred while the consumer is trying to
         * pickup incoming messages, or the likes, will now be processed as a
         * message and handled by the routing Error Handler. By default the
         * consumer will use the org.apache.camel.spi.ExceptionHandler to deal
         * with exceptions, that will be logged at WARN or ERROR level and
         * ignored. The option is a boolean type.
         */
        public Sjms2Consumer bridgeErrorHandler(boolean bridgeErrorHandler) {
            this.bridgeErrorHandler = bridgeErrorHandler;
            return (Sjms2Consumer) this;
        }

        /**
         * Sets the number of consumer listeners used for this endpoint. The
         * option is a int type.
         */
        public Sjms2Consumer consumerCount(int consumerCount) {
            this.consumerCount = consumerCount;
            return (Sjms2Consumer) this;
        }

        /**
         * Sets the durable subscription Id required for durable topics. The
         * option is a java.lang.String type.
         */
        public Sjms2Consumer durableSubscriptionId(String durableSubscriptionId) {
            this.durableSubscriptionId = durableSubscriptionId;
            return (Sjms2Consumer) this;
        }

        /**
         * Sets whether synchronous processing should be strictly used or Camel
         * is allowed to use asynchronous processing (if supported). The option
         * is a boolean type.
         */
        public Sjms2Consumer synchronous(boolean synchronous) {
            this.synchronous = synchronous;
            return (Sjms2Consumer) this;
        }

        /**
         * To let the consumer use a custom ExceptionHandler. Notice if the
         * option bridgeErrorHandler is enabled then this option is not in use.
         * By default the consumer will deal with exceptions, that will be
         * logged at WARN or ERROR level and ignored. The option is a
         * org.apache.camel.spi.ExceptionHandler type.
         */
        public Sjms2Consumer exceptionHandler(ExceptionHandler exceptionHandler) {
            this.exceptionHandler = exceptionHandler;
            return (Sjms2Consumer) this;
        }

        /**
         * Sets the exchange pattern when the consumer creates an exchange. The
         * option is a org.apache.camel.ExchangePattern type.
         */
        public Sjms2Consumer exchangePattern(ExchangePattern exchangePattern) {
            this.exchangePattern = exchangePattern;
            return (Sjms2Consumer) this;
        }

        /**
         * Sets the JMS Message selector syntax. The option is a
         * java.lang.String type.
         */
        public Sjms2Consumer messageSelector(String messageSelector) {
            this.messageSelector = messageSelector;
            return (Sjms2Consumer) this;
        }

        /**
         * Allows to configure the default errorHandler logging level for
         * logging uncaught exceptions. The option is a
         * org.apache.camel.LoggingLevel type.
         */
        public Sjms2Consumer errorHandlerLoggingLevel(
                LoggingLevel errorHandlerLoggingLevel) {
            this.errorHandlerLoggingLevel = errorHandlerLoggingLevel;
            return (Sjms2Consumer) this;
        }

        /**
         * Allows to control whether stacktraces should be logged or not, by the
         * default errorHandler. The option is a boolean type.
         */
        public Sjms2Consumer errorHandlerLogStackTrace(
                boolean errorHandlerLogStackTrace) {
            this.errorHandlerLogStackTrace = errorHandlerLogStackTrace;
            return (Sjms2Consumer) this;
        }

        /**
         * Specifies whether to use transacted mode. The option is a boolean
         * type.
         */
        public Sjms2Consumer transacted(boolean transacted) {
            this.transacted = transacted;
            return (Sjms2Consumer) this;
        }

        /**
         * If transacted sets the number of messages to process before
         * committing a transaction. The option is a int type.
         */
        public Sjms2Consumer transactionBatchCount(int transactionBatchCount) {
            this.transactionBatchCount = transactionBatchCount;
            return (Sjms2Consumer) this;
        }

        /**
         * Sets timeout (in millis) for batch transactions, the value should be
         * 1000 or higher. The option is a long type.
         */
        public Sjms2Consumer transactionBatchTimeout(
                long transactionBatchTimeout) {
            this.transactionBatchTimeout = transactionBatchTimeout;
            return (Sjms2Consumer) this;
        }

        public Boolean getDurable() {
            return durable;
        }

        public void setDurable(Boolean durable) {
            this.durable = durable;
        }

        public Boolean getShared() {
            return shared;
        }

        public void setShared(Boolean shared) {
            this.shared = shared;
        }

        public String getSubscriptionId() {
            return subscriptionId;
        }

        public void setSubscriptionId(String subscriptionId) {
            this.subscriptionId = subscriptionId;
        }

        public Boolean getBridgeErrorHandler() {
            return bridgeErrorHandler;
        }

        public void setBridgeErrorHandler(Boolean bridgeErrorHandler) {
            this.bridgeErrorHandler = bridgeErrorHandler;
        }

        public Integer getConsumerCount() {
            return consumerCount;
        }

        public void setConsumerCount(Integer consumerCount) {
            this.consumerCount = consumerCount;
        }

        public String getDurableSubscriptionId() {
            return durableSubscriptionId;
        }

        public void setDurableSubscriptionId(String durableSubscriptionId) {
            this.durableSubscriptionId = durableSubscriptionId;
        }

        public Boolean getSynchronous() {
            return synchronous;
        }

        public void setSynchronous(Boolean synchronous) {
            this.synchronous = synchronous;
        }

        public ExceptionHandler getExceptionHandler() {
            return exceptionHandler;
        }

        public void setExceptionHandler(ExceptionHandler exceptionHandler) {
            this.exceptionHandler = exceptionHandler;
        }

        public ExchangePattern getExchangePattern() {
            return exchangePattern;
        }

        public void setExchangePattern(ExchangePattern exchangePattern) {
            this.exchangePattern = exchangePattern;
        }

        public String getMessageSelector() {
            return messageSelector;
        }

        public void setMessageSelector(String messageSelector) {
            this.messageSelector = messageSelector;
        }

        public LoggingLevel getErrorHandlerLoggingLevel() {
            return errorHandlerLoggingLevel;
        }

        public void setErrorHandlerLoggingLevel(
                LoggingLevel errorHandlerLoggingLevel) {
            this.errorHandlerLoggingLevel = errorHandlerLoggingLevel;
        }

        public Boolean getErrorHandlerLogStackTrace() {
            return errorHandlerLogStackTrace;
        }

        public void setErrorHandlerLogStackTrace(
                Boolean errorHandlerLogStackTrace) {
            this.errorHandlerLogStackTrace = errorHandlerLogStackTrace;
        }

        public Boolean getTransacted() {
            return transacted;
        }

        public void setTransacted(Boolean transacted) {
            this.transacted = transacted;
        }

        public Integer getTransactionBatchCount() {
            return transactionBatchCount;
        }

        public void setTransactionBatchCount(Integer transactionBatchCount) {
            this.transactionBatchCount = transactionBatchCount;
        }

        public Long getTransactionBatchTimeout() {
            return transactionBatchTimeout;
        }

        public void setTransactionBatchTimeout(Long transactionBatchTimeout) {
            this.transactionBatchTimeout = transactionBatchTimeout;
        }
    }

    public static class Sjms2Producer extends Sjms2Common<Sjms2Producer> {
        private String namedReplyTo;
        private Boolean persistent;
        private Integer producerCount;
        private Long ttl;
        private Boolean allowNullBody;
        private Boolean prefillPool;
        private Long responseTimeOut;

        /**
         * Sets the reply to destination name used for InOut producer endpoints.
         * The type of the reply to destination can be determined by the
         * starting prefix (topic: or queue:) in its name. The option is a
         * java.lang.String type.
         */
        public Sjms2Producer namedReplyTo(String namedReplyTo) {
            this.namedReplyTo = namedReplyTo;
            return (Sjms2Producer) this;
        }

        /**
         * Flag used to enable/disable message persistence. The option is a
         * boolean type.
         */
        public Sjms2Producer persistent(boolean persistent) {
            this.persistent = persistent;
            return (Sjms2Producer) this;
        }

        /**
         * Sets the number of producers used for this endpoint. The option is a
         * int type.
         */
        public Sjms2Producer producerCount(int producerCount) {
            this.producerCount = producerCount;
            return (Sjms2Producer) this;
        }

        /**
         * Flag used to adjust the Time To Live value of produced messages. The
         * option is a long type.
         */
        public Sjms2Producer ttl(long ttl) {
            this.ttl = ttl;
            return (Sjms2Producer) this;
        }

        /**
         * Whether to allow sending messages with no body. If this option is
         * false and the message body is null, then an JMSException is thrown.
         * The option is a boolean type.
         */
        public Sjms2Producer allowNullBody(boolean allowNullBody) {
            this.allowNullBody = allowNullBody;
            return (Sjms2Producer) this;
        }

        /**
         * Whether to prefill the producer connection pool on startup, or create
         * connections lazy when needed. The option is a boolean type.
         */
        public Sjms2Producer prefillPool(boolean prefillPool) {
            this.prefillPool = prefillPool;
            return (Sjms2Producer) this;
        }

        /**
         * Sets the amount of time we should wait before timing out a InOut
         * response. The option is a long type.
         */
        public Sjms2Producer responseTimeOut(long responseTimeOut) {
            this.responseTimeOut = responseTimeOut;
            return (Sjms2Producer) this;
        }

        public String getNamedReplyTo() {
            return namedReplyTo;
        }

        public void setNamedReplyTo(String namedReplyTo) {
            this.namedReplyTo = namedReplyTo;
        }

        public Boolean getPersistent() {
            return persistent;
        }

        public void setPersistent(Boolean persistent) {
            this.persistent = persistent;
        }

        public Integer getProducerCount() {
            return producerCount;
        }

        public void setProducerCount(Integer producerCount) {
            this.producerCount = producerCount;
        }

        public Long getTtl() {
            return ttl;
        }

        public void setTtl(Long ttl) {
            this.ttl = ttl;
        }

        public Boolean getAllowNullBody() {
            return allowNullBody;
        }

        public void setAllowNullBody(Boolean allowNullBody) {
            this.allowNullBody = allowNullBody;
        }

        public Boolean getPrefillPool() {
            return prefillPool;
        }

        public void setPrefillPool(Boolean prefillPool) {
            this.prefillPool = prefillPool;
        }

        public Long getResponseTimeOut() {
            return responseTimeOut;
        }

        public void setResponseTimeOut(Long responseTimeOut) {
            this.responseTimeOut = responseTimeOut;
        }
    }

    public static enum SessionAcknowledgementType {
        SESSION_TRANSACTED, CLIENT_ACKNOWLEDGE, AUTO_ACKNOWLEDGE, DUPS_OK_ACKNOWLEDGE;
    }
}