/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.endpoint;

import java.util.Map;
import javax.annotation.Generated;
import org.apache.camel.ExchangePattern;
import org.apache.camel.model.AbstractEndpointBuilder;
import org.apache.camel.model.EndpointConsumerBuilder;
import org.apache.camel.model.EndpointProducerBuilder;
import org.apache.camel.spi.ExceptionHandler;

/**
 * The rabbitmq component allows you produce and consume messages from RabbitMQ
 * instances.
 * 
 * Generated by camel-package-maven-plugin - do not edit this file!
 */
@Generated("org.apache.camel.maven.packaging.EndpointDslMojo")
public interface RabbitMQEndpointBuilder {


    public static class RabbitMQCommonBuilder<T extends AbstractEndpointBuilder>
            extends
                AbstractEndpointBuilder<T> {
        RabbitMQCommonBuilder(String path) {
            super("rabbitmq", path);
        }
        /**
         * The exchange name determines which exchange produced messages will
         * sent to. In the case of consumers, the exchange name determines which
         * exchange the queue will bind to. The option is a
         * <code>java.lang.String</code> type.
         */
        public T exchangeName(String exchangeName) {
            this.properties.put("exchangeName", exchangeName);
            return (T) this;
        }
        /**
         * If this option is set, camel-rabbitmq will try to create connection
         * based on the setting of option addresses. The addresses value is a
         * string which looks like server1:12345, server2:12345. The option is a
         * <code>com.rabbitmq.client.Address[]</code> type.
         */
        public T addresses(Object[] addresses) {
            this.properties.put("addresses", addresses);
            return (T) this;
        }
        /**
         * If this option is set, camel-rabbitmq will try to create connection
         * based on the setting of option addresses. The addresses value is a
         * string which looks like server1:12345, server2:12345. The option will
         * be converted to a <code>com.rabbitmq.client.Address[]</code> type.
         */
        public T addresses(String addresses) {
            this.properties.put("addresses", addresses);
            return (T) this;
        }
        /**
         * If it is true, the exchange will be deleted when it is no longer in
         * use. The option is a <code>boolean</code> type.
         */
        public T autoDelete(boolean autoDelete) {
            this.properties.put("autoDelete", autoDelete);
            return (T) this;
        }
        /**
         * If it is true, the exchange will be deleted when it is no longer in
         * use. The option will be converted to a <code>boolean</code> type.
         */
        public T autoDelete(String autoDelete) {
            this.properties.put("autoDelete", autoDelete);
            return (T) this;
        }
        /**
         * To use a custom RabbitMQ connection factory. When this option is set,
         * all connection options (connectionTimeout, requestedChannelMax...)
         * set on URI are not used. The option is a
         * <code>com.rabbitmq.client.ConnectionFactory</code> type.
         */
        public T connectionFactory(Object connectionFactory) {
            this.properties.put("connectionFactory", connectionFactory);
            return (T) this;
        }
        /**
         * To use a custom RabbitMQ connection factory. When this option is set,
         * all connection options (connectionTimeout, requestedChannelMax...)
         * set on URI are not used. The option will be converted to a
         * <code>com.rabbitmq.client.ConnectionFactory</code> type.
         */
        public T connectionFactory(String connectionFactory) {
            this.properties.put("connectionFactory", connectionFactory);
            return (T) this;
        }
        /**
         * The name of the dead letter exchange. The option is a
         * <code>java.lang.String</code> type.
         */
        public T deadLetterExchange(String deadLetterExchange) {
            this.properties.put("deadLetterExchange", deadLetterExchange);
            return (T) this;
        }
        /**
         * The type of the dead letter exchange. The option is a
         * <code>java.lang.String</code> type.
         */
        public T deadLetterExchangeType(String deadLetterExchangeType) {
            this.properties.put("deadLetterExchangeType", deadLetterExchangeType);
            return (T) this;
        }
        /**
         * The name of the dead letter queue. The option is a
         * <code>java.lang.String</code> type.
         */
        public T deadLetterQueue(String deadLetterQueue) {
            this.properties.put("deadLetterQueue", deadLetterQueue);
            return (T) this;
        }
        /**
         * The routing key for the dead letter exchange. The option is a
         * <code>java.lang.String</code> type.
         */
        public T deadLetterRoutingKey(String deadLetterRoutingKey) {
            this.properties.put("deadLetterRoutingKey", deadLetterRoutingKey);
            return (T) this;
        }
        /**
         * If the option is true, camel declare the exchange and queue name and
         * bind them together. If the option is false, camel won't declare the
         * exchange and queue name on the server. The option is a
         * <code>boolean</code> type.
         */
        public T declare(boolean declare) {
            this.properties.put("declare", declare);
            return (T) this;
        }
        /**
         * If the option is true, camel declare the exchange and queue name and
         * bind them together. If the option is false, camel won't declare the
         * exchange and queue name on the server. The option will be converted
         * to a <code>boolean</code> type.
         */
        public T declare(String declare) {
            this.properties.put("declare", declare);
            return (T) this;
        }
        /**
         * If we are declaring a durable exchange (the exchange will survive a
         * server restart). The option is a <code>boolean</code> type.
         */
        public T durable(boolean durable) {
            this.properties.put("durable", durable);
            return (T) this;
        }
        /**
         * If we are declaring a durable exchange (the exchange will survive a
         * server restart). The option will be converted to a
         * <code>boolean</code> type.
         */
        public T durable(String durable) {
            this.properties.put("durable", durable);
            return (T) this;
        }
        /**
         * The exchange type such as direct or topic. The option is a
         * <code>java.lang.String</code> type.
         */
        public T exchangeType(String exchangeType) {
            this.properties.put("exchangeType", exchangeType);
            return (T) this;
        }
        /**
         * Exclusive queues may only be accessed by the current connection, and
         * are deleted when that connection closes. The option is a
         * <code>boolean</code> type.
         */
        public T exclusive(boolean exclusive) {
            this.properties.put("exclusive", exclusive);
            return (T) this;
        }
        /**
         * Exclusive queues may only be accessed by the current connection, and
         * are deleted when that connection closes. The option will be converted
         * to a <code>boolean</code> type.
         */
        public T exclusive(String exclusive) {
            this.properties.put("exclusive", exclusive);
            return (T) this;
        }
        /**
         * The hostname of the running rabbitmq instance or cluster. The option
         * is a <code>java.lang.String</code> type.
         */
        public T hostname(String hostname) {
            this.properties.put("hostname", hostname);
            return (T) this;
        }
        /**
         * Passive queues depend on the queue already to be available at
         * RabbitMQ. The option is a <code>boolean</code> type.
         */
        public T passive(boolean passive) {
            this.properties.put("passive", passive);
            return (T) this;
        }
        /**
         * Passive queues depend on the queue already to be available at
         * RabbitMQ. The option will be converted to a <code>boolean</code>
         * type.
         */
        public T passive(String passive) {
            this.properties.put("passive", passive);
            return (T) this;
        }
        /**
         * Port number for the host with the running rabbitmq instance or
         * cluster. Default value is 5672. The option is a <code>int</code>
         * type.
         */
        public T portNumber(int portNumber) {
            this.properties.put("portNumber", portNumber);
            return (T) this;
        }
        /**
         * Port number for the host with the running rabbitmq instance or
         * cluster. Default value is 5672. The option will be converted to a
         * <code>int</code> type.
         */
        public T portNumber(String portNumber) {
            this.properties.put("portNumber", portNumber);
            return (T) this;
        }
        /**
         * The queue to receive messages from. The option is a
         * <code>java.lang.String</code> type.
         */
        public T queue(String queue) {
            this.properties.put("queue", queue);
            return (T) this;
        }
        /**
         * The routing key to use when binding a consumer queue to the exchange.
         * For producer routing keys, you set the header rabbitmq.ROUTING_KEY.
         * The option is a <code>java.lang.String</code> type.
         */
        public T routingKey(String routingKey) {
            this.properties.put("routingKey", routingKey);
            return (T) this;
        }
        /**
         * This can be used if we need to declare the queue but not the
         * exchange. The option is a <code>boolean</code> type.
         */
        public T skipExchangeDeclare(boolean skipExchangeDeclare) {
            this.properties.put("skipExchangeDeclare", skipExchangeDeclare);
            return (T) this;
        }
        /**
         * This can be used if we need to declare the queue but not the
         * exchange. The option will be converted to a <code>boolean</code>
         * type.
         */
        public T skipExchangeDeclare(String skipExchangeDeclare) {
            this.properties.put("skipExchangeDeclare", skipExchangeDeclare);
            return (T) this;
        }
        /**
         * If true the queue will not be bound to the exchange after declaring
         * it. The option is a <code>boolean</code> type.
         */
        public T skipQueueBind(boolean skipQueueBind) {
            this.properties.put("skipQueueBind", skipQueueBind);
            return (T) this;
        }
        /**
         * If true the queue will not be bound to the exchange after declaring
         * it. The option will be converted to a <code>boolean</code> type.
         */
        public T skipQueueBind(String skipQueueBind) {
            this.properties.put("skipQueueBind", skipQueueBind);
            return (T) this;
        }
        /**
         * If true the producer will not declare and bind a queue. This can be
         * used for directing messages via an existing routing key. The option
         * is a <code>boolean</code> type.
         */
        public T skipQueueDeclare(boolean skipQueueDeclare) {
            this.properties.put("skipQueueDeclare", skipQueueDeclare);
            return (T) this;
        }
        /**
         * If true the producer will not declare and bind a queue. This can be
         * used for directing messages via an existing routing key. The option
         * will be converted to a <code>boolean</code> type.
         */
        public T skipQueueDeclare(String skipQueueDeclare) {
            this.properties.put("skipQueueDeclare", skipQueueDeclare);
            return (T) this;
        }
        /**
         * The vhost for the channel. The option is a
         * <code>java.lang.String</code> type.
         */
        public T vhost(String vhost) {
            this.properties.put("vhost", vhost);
            return (T) this;
        }
        /**
         * Specify arguments for configuring the different RabbitMQ concepts, a
         * different prefix is required for each: Exchange: arg.exchange. Queue:
         * arg.queue. Binding: arg.binding. For example to declare a queue with
         * message ttl argument:
         * http://localhost:5672/exchange/queueargs=arg.queue.x-message-ttl=60000. The option is a <code>java.util.Map&lt;java.lang.String, java.lang.Object&gt;</code> type.
         */
        public T args(Map<String, Object> args) {
            this.properties.put("args", args);
            return (T) this;
        }
        /**
         * Specify arguments for configuring the different RabbitMQ concepts, a
         * different prefix is required for each: Exchange: arg.exchange. Queue:
         * arg.queue. Binding: arg.binding. For example to declare a queue with
         * message ttl argument:
         * http://localhost:5672/exchange/queueargs=arg.queue.x-message-ttl=60000. The option will be converted to a <code>java.util.Map&lt;java.lang.String, java.lang.Object&gt;</code> type.
         */
        public T args(String args) {
            this.properties.put("args", args);
            return (T) this;
        }
        /**
         * Enables connection automatic recovery (uses connection implementation
         * that performs automatic recovery when connection shutdown is not
         * initiated by the application). The option is a
         * <code>java.lang.Boolean</code> type.
         */
        public T automaticRecoveryEnabled(Boolean automaticRecoveryEnabled) {
            this.properties.put("automaticRecoveryEnabled", automaticRecoveryEnabled);
            return (T) this;
        }
        /**
         * Enables connection automatic recovery (uses connection implementation
         * that performs automatic recovery when connection shutdown is not
         * initiated by the application). The option will be converted to a
         * <code>java.lang.Boolean</code> type.
         */
        public T automaticRecoveryEnabled(String automaticRecoveryEnabled) {
            this.properties.put("automaticRecoveryEnabled", automaticRecoveryEnabled);
            return (T) this;
        }
        /**
         * Whether the endpoint should use basic property binding (Camel 2.x) or
         * the newer property binding with additional capabilities. The option
         * is a <code>boolean</code> type.
         */
        public T basicPropertyBinding(boolean basicPropertyBinding) {
            this.properties.put("basicPropertyBinding", basicPropertyBinding);
            return (T) this;
        }
        /**
         * Whether the endpoint should use basic property binding (Camel 2.x) or
         * the newer property binding with additional capabilities. The option
         * will be converted to a <code>boolean</code> type.
         */
        public T basicPropertyBinding(String basicPropertyBinding) {
            this.properties.put("basicPropertyBinding", basicPropertyBinding);
            return (T) this;
        }
        /**
         * Connection client properties (client info used in negotiating with
         * the server). The option is a <code>java.util.Map&lt;java.lang.String,
         * java.lang.Object&gt;</code> type.
         */
        public T clientProperties(Map<String, Object> clientProperties) {
            this.properties.put("clientProperties", clientProperties);
            return (T) this;
        }
        /**
         * Connection client properties (client info used in negotiating with
         * the server). The option will be converted to a
         * <code>java.util.Map&lt;java.lang.String, java.lang.Object&gt;</code>
         * type.
         */
        public T clientProperties(String clientProperties) {
            this.properties.put("clientProperties", clientProperties);
            return (T) this;
        }
        /**
         * Connection timeout. The option is a <code>int</code> type.
         */
        public T connectionTimeout(int connectionTimeout) {
            this.properties.put("connectionTimeout", connectionTimeout);
            return (T) this;
        }
        /**
         * Connection timeout. The option will be converted to a
         * <code>int</code> type.
         */
        public T connectionTimeout(String connectionTimeout) {
            this.properties.put("connectionTimeout", connectionTimeout);
            return (T) this;
        }
        /**
         * Network recovery interval in milliseconds (interval used when
         * recovering from network failure). The option is a
         * <code>java.lang.Integer</code> type.
         */
        public T networkRecoveryInterval(Integer networkRecoveryInterval) {
            this.properties.put("networkRecoveryInterval", networkRecoveryInterval);
            return (T) this;
        }
        /**
         * Network recovery interval in milliseconds (interval used when
         * recovering from network failure). The option will be converted to a
         * <code>java.lang.Integer</code> type.
         */
        public T networkRecoveryInterval(String networkRecoveryInterval) {
            this.properties.put("networkRecoveryInterval", networkRecoveryInterval);
            return (T) this;
        }
        /**
         * Connection requested channel max (max number of channels offered).
         * The option is a <code>int</code> type.
         */
        public T requestedChannelMax(int requestedChannelMax) {
            this.properties.put("requestedChannelMax", requestedChannelMax);
            return (T) this;
        }
        /**
         * Connection requested channel max (max number of channels offered).
         * The option will be converted to a <code>int</code> type.
         */
        public T requestedChannelMax(String requestedChannelMax) {
            this.properties.put("requestedChannelMax", requestedChannelMax);
            return (T) this;
        }
        /**
         * Connection requested frame max (max size of frame offered). The
         * option is a <code>int</code> type.
         */
        public T requestedFrameMax(int requestedFrameMax) {
            this.properties.put("requestedFrameMax", requestedFrameMax);
            return (T) this;
        }
        /**
         * Connection requested frame max (max size of frame offered). The
         * option will be converted to a <code>int</code> type.
         */
        public T requestedFrameMax(String requestedFrameMax) {
            this.properties.put("requestedFrameMax", requestedFrameMax);
            return (T) this;
        }
        /**
         * Connection requested heartbeat (heart-beat in seconds offered). The
         * option is a <code>int</code> type.
         */
        public T requestedHeartbeat(int requestedHeartbeat) {
            this.properties.put("requestedHeartbeat", requestedHeartbeat);
            return (T) this;
        }
        /**
         * Connection requested heartbeat (heart-beat in seconds offered). The
         * option will be converted to a <code>int</code> type.
         */
        public T requestedHeartbeat(String requestedHeartbeat) {
            this.properties.put("requestedHeartbeat", requestedHeartbeat);
            return (T) this;
        }
        /**
         * Set timeout for waiting for a reply when using the InOut Exchange
         * Pattern (in milliseconds). The option is a <code>long</code> type.
         */
        public T requestTimeout(long requestTimeout) {
            this.properties.put("requestTimeout", requestTimeout);
            return (T) this;
        }
        /**
         * Set timeout for waiting for a reply when using the InOut Exchange
         * Pattern (in milliseconds). The option will be converted to a
         * <code>long</code> type.
         */
        public T requestTimeout(String requestTimeout) {
            this.properties.put("requestTimeout", requestTimeout);
            return (T) this;
        }
        /**
         * Set requestTimeoutCheckerInterval for inOut exchange. The option is a
         * <code>long</code> type.
         */
        public T requestTimeoutCheckerInterval(
                long requestTimeoutCheckerInterval) {
            this.properties.put("requestTimeoutCheckerInterval", requestTimeoutCheckerInterval);
            return (T) this;
        }
        /**
         * Set requestTimeoutCheckerInterval for inOut exchange. The option will
         * be converted to a <code>long</code> type.
         */
        public T requestTimeoutCheckerInterval(
                String requestTimeoutCheckerInterval) {
            this.properties.put("requestTimeoutCheckerInterval", requestTimeoutCheckerInterval);
            return (T) this;
        }
        /**
         * Sets whether synchronous processing should be strictly used, or Camel
         * is allowed to use asynchronous processing (if supported). The option
         * is a <code>boolean</code> type.
         */
        public T synchronous(boolean synchronous) {
            this.properties.put("synchronous", synchronous);
            return (T) this;
        }
        /**
         * Sets whether synchronous processing should be strictly used, or Camel
         * is allowed to use asynchronous processing (if supported). The option
         * will be converted to a <code>boolean</code> type.
         */
        public T synchronous(String synchronous) {
            this.properties.put("synchronous", synchronous);
            return (T) this;
        }
        /**
         * Enables connection topology recovery (should topology recovery be
         * performed). The option is a <code>java.lang.Boolean</code> type.
         */
        public T topologyRecoveryEnabled(Boolean topologyRecoveryEnabled) {
            this.properties.put("topologyRecoveryEnabled", topologyRecoveryEnabled);
            return (T) this;
        }
        /**
         * Enables connection topology recovery (should topology recovery be
         * performed). The option will be converted to a
         * <code>java.lang.Boolean</code> type.
         */
        public T topologyRecoveryEnabled(String topologyRecoveryEnabled) {
            this.properties.put("topologyRecoveryEnabled", topologyRecoveryEnabled);
            return (T) this;
        }
        /**
         * When true and an inOut Exchange failed on the consumer side send the
         * caused Exception back in the response. The option is a
         * <code>boolean</code> type.
         */
        public T transferException(boolean transferException) {
            this.properties.put("transferException", transferException);
            return (T) this;
        }
        /**
         * When true and an inOut Exchange failed on the consumer side send the
         * caused Exception back in the response. The option will be converted
         * to a <code>boolean</code> type.
         */
        public T transferException(String transferException) {
            this.properties.put("transferException", transferException);
            return (T) this;
        }
        /**
         * Password for authenticated access. The option is a
         * <code>java.lang.String</code> type.
         */
        public T password(String password) {
            this.properties.put("password", password);
            return (T) this;
        }
        /**
         * Enables SSL on connection, accepted value are true, TLS and 'SSLv3.
         * The option is a <code>java.lang.String</code> type.
         */
        public T sslProtocol(String sslProtocol) {
            this.properties.put("sslProtocol", sslProtocol);
            return (T) this;
        }
        /**
         * Configure SSL trust manager, SSL should be enabled for this option to
         * be effective. The option is a <code>javax.net.ssl.TrustManager</code>
         * type.
         */
        public T trustManager(Object trustManager) {
            this.properties.put("trustManager", trustManager);
            return (T) this;
        }
        /**
         * Configure SSL trust manager, SSL should be enabled for this option to
         * be effective. The option will be converted to a
         * <code>javax.net.ssl.TrustManager</code> type.
         */
        public T trustManager(String trustManager) {
            this.properties.put("trustManager", trustManager);
            return (T) this;
        }
        /**
         * Username in case of authenticated access. The option is a
         * <code>java.lang.String</code> type.
         */
        public T username(String username) {
            this.properties.put("username", username);
            return (T) this;
        }
    }

    public static class RabbitMQConsumerBuilder
            extends
                RabbitMQCommonBuilder<RabbitMQConsumerBuilder>
            implements
                EndpointConsumerBuilder {
        public RabbitMQConsumerBuilder(String path) {
            super(path);
        }
        /**
         * If messages should be auto acknowledged. The option is a
         * <code>boolean</code> type.
         */
        public RabbitMQConsumerBuilder autoAck(boolean autoAck) {
            this.properties.put("autoAck", autoAck);
            return (RabbitMQConsumerBuilder) this;
        }
        /**
         * If messages should be auto acknowledged. The option will be converted
         * to a <code>boolean</code> type.
         */
        public RabbitMQConsumerBuilder autoAck(String autoAck) {
            this.properties.put("autoAck", autoAck);
            return (RabbitMQConsumerBuilder) this;
        }
        /**
         * Allows for bridging the consumer to the Camel routing Error Handler,
         * which mean any exceptions occurred while the consumer is trying to
         * pickup incoming messages, or the likes, will now be processed as a
         * message and handled by the routing Error Handler. By default the
         * consumer will use the org.apache.camel.spi.ExceptionHandler to deal
         * with exceptions, that will be logged at WARN or ERROR level and
         * ignored. The option is a <code>boolean</code> type.
         */
        public RabbitMQConsumerBuilder bridgeErrorHandler(
                boolean bridgeErrorHandler) {
            this.properties.put("bridgeErrorHandler", bridgeErrorHandler);
            return (RabbitMQConsumerBuilder) this;
        }
        /**
         * Allows for bridging the consumer to the Camel routing Error Handler,
         * which mean any exceptions occurred while the consumer is trying to
         * pickup incoming messages, or the likes, will now be processed as a
         * message and handled by the routing Error Handler. By default the
         * consumer will use the org.apache.camel.spi.ExceptionHandler to deal
         * with exceptions, that will be logged at WARN or ERROR level and
         * ignored. The option will be converted to a <code>boolean</code> type.
         */
        public RabbitMQConsumerBuilder bridgeErrorHandler(
                String bridgeErrorHandler) {
            this.properties.put("bridgeErrorHandler", bridgeErrorHandler);
            return (RabbitMQConsumerBuilder) this;
        }
        /**
         * Number of concurrent consumers when consuming from broker. (eg
         * similar as to the same option for the JMS component). The option is a
         * <code>int</code> type.
         */
        public RabbitMQConsumerBuilder concurrentConsumers(
                int concurrentConsumers) {
            this.properties.put("concurrentConsumers", concurrentConsumers);
            return (RabbitMQConsumerBuilder) this;
        }
        /**
         * Number of concurrent consumers when consuming from broker. (eg
         * similar as to the same option for the JMS component). The option will
         * be converted to a <code>int</code> type.
         */
        public RabbitMQConsumerBuilder concurrentConsumers(
                String concurrentConsumers) {
            this.properties.put("concurrentConsumers", concurrentConsumers);
            return (RabbitMQConsumerBuilder) this;
        }
        /**
         * Request exclusive access to the queue (meaning only this consumer can
         * access the queue). This is useful when you want a long-lived shared
         * queue to be temporarily accessible by just one consumer. The option
         * is a <code>boolean</code> type.
         */
        public RabbitMQConsumerBuilder exclusiveConsumer(
                boolean exclusiveConsumer) {
            this.properties.put("exclusiveConsumer", exclusiveConsumer);
            return (RabbitMQConsumerBuilder) this;
        }
        /**
         * Request exclusive access to the queue (meaning only this consumer can
         * access the queue). This is useful when you want a long-lived shared
         * queue to be temporarily accessible by just one consumer. The option
         * will be converted to a <code>boolean</code> type.
         */
        public RabbitMQConsumerBuilder exclusiveConsumer(
                String exclusiveConsumer) {
            this.properties.put("exclusiveConsumer", exclusiveConsumer);
            return (RabbitMQConsumerBuilder) this;
        }
        /**
         * The maximum number of messages that the server will deliver, 0 if
         * unlimited. You need to specify the option of prefetchSize,
         * prefetchCount, prefetchGlobal at the same time. The option is a
         * <code>int</code> type.
         */
        public RabbitMQConsumerBuilder prefetchCount(int prefetchCount) {
            this.properties.put("prefetchCount", prefetchCount);
            return (RabbitMQConsumerBuilder) this;
        }
        /**
         * The maximum number of messages that the server will deliver, 0 if
         * unlimited. You need to specify the option of prefetchSize,
         * prefetchCount, prefetchGlobal at the same time. The option will be
         * converted to a <code>int</code> type.
         */
        public RabbitMQConsumerBuilder prefetchCount(String prefetchCount) {
            this.properties.put("prefetchCount", prefetchCount);
            return (RabbitMQConsumerBuilder) this;
        }
        /**
         * Enables the quality of service on the RabbitMQConsumer side. You need
         * to specify the option of prefetchSize, prefetchCount, prefetchGlobal
         * at the same time. The option is a <code>boolean</code> type.
         */
        public RabbitMQConsumerBuilder prefetchEnabled(boolean prefetchEnabled) {
            this.properties.put("prefetchEnabled", prefetchEnabled);
            return (RabbitMQConsumerBuilder) this;
        }
        /**
         * Enables the quality of service on the RabbitMQConsumer side. You need
         * to specify the option of prefetchSize, prefetchCount, prefetchGlobal
         * at the same time. The option will be converted to a
         * <code>boolean</code> type.
         */
        public RabbitMQConsumerBuilder prefetchEnabled(String prefetchEnabled) {
            this.properties.put("prefetchEnabled", prefetchEnabled);
            return (RabbitMQConsumerBuilder) this;
        }
        /**
         * If the settings should be applied to the entire channel rather than
         * each consumer You need to specify the option of prefetchSize,
         * prefetchCount, prefetchGlobal at the same time. The option is a
         * <code>boolean</code> type.
         */
        public RabbitMQConsumerBuilder prefetchGlobal(boolean prefetchGlobal) {
            this.properties.put("prefetchGlobal", prefetchGlobal);
            return (RabbitMQConsumerBuilder) this;
        }
        /**
         * If the settings should be applied to the entire channel rather than
         * each consumer You need to specify the option of prefetchSize,
         * prefetchCount, prefetchGlobal at the same time. The option will be
         * converted to a <code>boolean</code> type.
         */
        public RabbitMQConsumerBuilder prefetchGlobal(String prefetchGlobal) {
            this.properties.put("prefetchGlobal", prefetchGlobal);
            return (RabbitMQConsumerBuilder) this;
        }
        /**
         * The maximum amount of content (measured in octets) that the server
         * will deliver, 0 if unlimited. You need to specify the option of
         * prefetchSize, prefetchCount, prefetchGlobal at the same time. The
         * option is a <code>int</code> type.
         */
        public RabbitMQConsumerBuilder prefetchSize(int prefetchSize) {
            this.properties.put("prefetchSize", prefetchSize);
            return (RabbitMQConsumerBuilder) this;
        }
        /**
         * The maximum amount of content (measured in octets) that the server
         * will deliver, 0 if unlimited. You need to specify the option of
         * prefetchSize, prefetchCount, prefetchGlobal at the same time. The
         * option will be converted to a <code>int</code> type.
         */
        public RabbitMQConsumerBuilder prefetchSize(String prefetchSize) {
            this.properties.put("prefetchSize", prefetchSize);
            return (RabbitMQConsumerBuilder) this;
        }
        /**
         * To let the consumer use a custom ExceptionHandler. Notice if the
         * option bridgeErrorHandler is enabled then this option is not in use.
         * By default the consumer will deal with exceptions, that will be
         * logged at WARN or ERROR level and ignored. The option is a
         * <code>org.apache.camel.spi.ExceptionHandler</code> type.
         */
        public RabbitMQConsumerBuilder exceptionHandler(
                ExceptionHandler exceptionHandler) {
            this.properties.put("exceptionHandler", exceptionHandler);
            return (RabbitMQConsumerBuilder) this;
        }
        /**
         * To let the consumer use a custom ExceptionHandler. Notice if the
         * option bridgeErrorHandler is enabled then this option is not in use.
         * By default the consumer will deal with exceptions, that will be
         * logged at WARN or ERROR level and ignored. The option will be
         * converted to a <code>org.apache.camel.spi.ExceptionHandler</code>
         * type.
         */
        public RabbitMQConsumerBuilder exceptionHandler(String exceptionHandler) {
            this.properties.put("exceptionHandler", exceptionHandler);
            return (RabbitMQConsumerBuilder) this;
        }
        /**
         * Sets the exchange pattern when the consumer creates an exchange. The
         * option is a <code>org.apache.camel.ExchangePattern</code> type.
         */
        public RabbitMQConsumerBuilder exchangePattern(
                ExchangePattern exchangePattern) {
            this.properties.put("exchangePattern", exchangePattern);
            return (RabbitMQConsumerBuilder) this;
        }
        /**
         * Sets the exchange pattern when the consumer creates an exchange. The
         * option will be converted to a
         * <code>org.apache.camel.ExchangePattern</code> type.
         */
        public RabbitMQConsumerBuilder exchangePattern(String exchangePattern) {
            this.properties.put("exchangePattern", exchangePattern);
            return (RabbitMQConsumerBuilder) this;
        }
        /**
         * The consumer uses a Thread Pool Executor with a fixed number of
         * threads. This setting allows you to set that number of threads. The
         * option is a <code>int</code> type.
         */
        public RabbitMQConsumerBuilder threadPoolSize(int threadPoolSize) {
            this.properties.put("threadPoolSize", threadPoolSize);
            return (RabbitMQConsumerBuilder) this;
        }
        /**
         * The consumer uses a Thread Pool Executor with a fixed number of
         * threads. This setting allows you to set that number of threads. The
         * option will be converted to a <code>int</code> type.
         */
        public RabbitMQConsumerBuilder threadPoolSize(String threadPoolSize) {
            this.properties.put("threadPoolSize", threadPoolSize);
            return (RabbitMQConsumerBuilder) this;
        }
    }

    public static class RabbitMQProducerBuilder
            extends
                RabbitMQCommonBuilder<RabbitMQProducerBuilder>
            implements
                EndpointProducerBuilder {
        public RabbitMQProducerBuilder(String path) {
            super(path);
        }
        /**
         * Allow pass null values to header. The option is a
         * <code>boolean</code> type.
         */
        public RabbitMQProducerBuilder allowNullHeaders(boolean allowNullHeaders) {
            this.properties.put("allowNullHeaders", allowNullHeaders);
            return (RabbitMQProducerBuilder) this;
        }
        /**
         * Allow pass null values to header. The option will be converted to a
         * <code>boolean</code> type.
         */
        public RabbitMQProducerBuilder allowNullHeaders(String allowNullHeaders) {
            this.properties.put("allowNullHeaders", allowNullHeaders);
            return (RabbitMQProducerBuilder) this;
        }
        /**
         * If the bridgeEndpoint is true, the producer will ignore the message
         * header of rabbitmq.EXCHANGE_NAME and rabbitmq.ROUTING_KEY. The option
         * is a <code>boolean</code> type.
         */
        public RabbitMQProducerBuilder bridgeEndpoint(boolean bridgeEndpoint) {
            this.properties.put("bridgeEndpoint", bridgeEndpoint);
            return (RabbitMQProducerBuilder) this;
        }
        /**
         * If the bridgeEndpoint is true, the producer will ignore the message
         * header of rabbitmq.EXCHANGE_NAME and rabbitmq.ROUTING_KEY. The option
         * will be converted to a <code>boolean</code> type.
         */
        public RabbitMQProducerBuilder bridgeEndpoint(String bridgeEndpoint) {
            this.properties.put("bridgeEndpoint", bridgeEndpoint);
            return (RabbitMQProducerBuilder) this;
        }
        /**
         * Get maximum number of opened channel in pool. The option is a
         * <code>int</code> type.
         */
        public RabbitMQProducerBuilder channelPoolMaxSize(int channelPoolMaxSize) {
            this.properties.put("channelPoolMaxSize", channelPoolMaxSize);
            return (RabbitMQProducerBuilder) this;
        }
        /**
         * Get maximum number of opened channel in pool. The option will be
         * converted to a <code>int</code> type.
         */
        public RabbitMQProducerBuilder channelPoolMaxSize(
                String channelPoolMaxSize) {
            this.properties.put("channelPoolMaxSize", channelPoolMaxSize);
            return (RabbitMQProducerBuilder) this;
        }
        /**
         * Set the maximum number of milliseconds to wait for a channel from the
         * pool. The option is a <code>long</code> type.
         */
        public RabbitMQProducerBuilder channelPoolMaxWait(
                long channelPoolMaxWait) {
            this.properties.put("channelPoolMaxWait", channelPoolMaxWait);
            return (RabbitMQProducerBuilder) this;
        }
        /**
         * Set the maximum number of milliseconds to wait for a channel from the
         * pool. The option will be converted to a <code>long</code> type.
         */
        public RabbitMQProducerBuilder channelPoolMaxWait(
                String channelPoolMaxWait) {
            this.properties.put("channelPoolMaxWait", channelPoolMaxWait);
            return (RabbitMQProducerBuilder) this;
        }
        /**
         * When true, an exception will be thrown when the message cannot be
         * delivered (basic.return) and the message is marked as mandatory.
         * PublisherAcknowledgement will also be activated in this case. See
         * also publisher acknowledgements - When will messages be confirmed.
         * The option is a <code>boolean</code> type.
         */
        public RabbitMQProducerBuilder guaranteedDeliveries(
                boolean guaranteedDeliveries) {
            this.properties.put("guaranteedDeliveries", guaranteedDeliveries);
            return (RabbitMQProducerBuilder) this;
        }
        /**
         * When true, an exception will be thrown when the message cannot be
         * delivered (basic.return) and the message is marked as mandatory.
         * PublisherAcknowledgement will also be activated in this case. See
         * also publisher acknowledgements - When will messages be confirmed.
         * The option will be converted to a <code>boolean</code> type.
         */
        public RabbitMQProducerBuilder guaranteedDeliveries(
                String guaranteedDeliveries) {
            this.properties.put("guaranteedDeliveries", guaranteedDeliveries);
            return (RabbitMQProducerBuilder) this;
        }
        /**
         * This flag tells the server how to react if the message cannot be
         * routed to a queue consumer immediately. If this flag is set, the
         * server will return an undeliverable message with a Return method. If
         * this flag is zero, the server will queue the message, but with no
         * guarantee that it will ever be consumed. If the header is present
         * rabbitmq.IMMEDIATE it will override this option. The option is a
         * <code>boolean</code> type.
         */
        public RabbitMQProducerBuilder immediate(boolean immediate) {
            this.properties.put("immediate", immediate);
            return (RabbitMQProducerBuilder) this;
        }
        /**
         * This flag tells the server how to react if the message cannot be
         * routed to a queue consumer immediately. If this flag is set, the
         * server will return an undeliverable message with a Return method. If
         * this flag is zero, the server will queue the message, but with no
         * guarantee that it will ever be consumed. If the header is present
         * rabbitmq.IMMEDIATE it will override this option. The option will be
         * converted to a <code>boolean</code> type.
         */
        public RabbitMQProducerBuilder immediate(String immediate) {
            this.properties.put("immediate", immediate);
            return (RabbitMQProducerBuilder) this;
        }
        /**
         * This flag tells the server how to react if the message cannot be
         * routed to a queue. If this flag is set, the server will return an
         * unroutable message with a Return method. If this flag is zero, the
         * server silently drops the message. If the header is present
         * rabbitmq.MANDATORY it will override this option. The option is a
         * <code>boolean</code> type.
         */
        public RabbitMQProducerBuilder mandatory(boolean mandatory) {
            this.properties.put("mandatory", mandatory);
            return (RabbitMQProducerBuilder) this;
        }
        /**
         * This flag tells the server how to react if the message cannot be
         * routed to a queue. If this flag is set, the server will return an
         * unroutable message with a Return method. If this flag is zero, the
         * server silently drops the message. If the header is present
         * rabbitmq.MANDATORY it will override this option. The option will be
         * converted to a <code>boolean</code> type.
         */
        public RabbitMQProducerBuilder mandatory(String mandatory) {
            this.properties.put("mandatory", mandatory);
            return (RabbitMQProducerBuilder) this;
        }
        /**
         * When true, the message will be published with publisher
         * acknowledgements turned on. The option is a <code>boolean</code>
         * type.
         */
        public RabbitMQProducerBuilder publisherAcknowledgements(
                boolean publisherAcknowledgements) {
            this.properties.put("publisherAcknowledgements", publisherAcknowledgements);
            return (RabbitMQProducerBuilder) this;
        }
        /**
         * When true, the message will be published with publisher
         * acknowledgements turned on. The option will be converted to a
         * <code>boolean</code> type.
         */
        public RabbitMQProducerBuilder publisherAcknowledgements(
                String publisherAcknowledgements) {
            this.properties.put("publisherAcknowledgements", publisherAcknowledgements);
            return (RabbitMQProducerBuilder) this;
        }
        /**
         * The amount of time in milliseconds to wait for a basic.ack response
         * from RabbitMQ server. The option is a <code>long</code> type.
         */
        public RabbitMQProducerBuilder publisherAcknowledgementsTimeout(
                long publisherAcknowledgementsTimeout) {
            this.properties.put("publisherAcknowledgementsTimeout", publisherAcknowledgementsTimeout);
            return (RabbitMQProducerBuilder) this;
        }
        /**
         * The amount of time in milliseconds to wait for a basic.ack response
         * from RabbitMQ server. The option will be converted to a
         * <code>long</code> type.
         */
        public RabbitMQProducerBuilder publisherAcknowledgementsTimeout(
                String publisherAcknowledgementsTimeout) {
            this.properties.put("publisherAcknowledgementsTimeout", publisherAcknowledgementsTimeout);
            return (RabbitMQProducerBuilder) this;
        }
    }
    public default RabbitMQConsumerBuilder fromRabbitMQ(String path) {
        return new RabbitMQConsumerBuilder(path);
    }
    public default RabbitMQProducerBuilder toRabbitMQ(String path) {
        return new RabbitMQProducerBuilder(path);
    }
}