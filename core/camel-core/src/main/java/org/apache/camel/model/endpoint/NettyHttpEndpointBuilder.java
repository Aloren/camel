/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.endpoint;

import java.io.File;
import java.util.List;
import java.util.Map;
import javax.annotation.Generated;
import org.apache.camel.ExchangePattern;
import org.apache.camel.LoggingLevel;
import org.apache.camel.model.AbstractEndpointBuilder;
import org.apache.camel.model.EndpointConsumerBuilder;
import org.apache.camel.model.EndpointProducerBuilder;
import org.apache.camel.spi.ExceptionHandler;
import org.apache.camel.spi.HeaderFilterStrategy;

/**
 * Netty HTTP server and client using the Netty 4.x library.
 * 
 * Generated by camel-package-maven-plugin - do not edit this file!
 */
@Generated("org.apache.camel.maven.packaging.EndpointDslMojo")
public interface NettyHttpEndpointBuilder {


    /**
     * Base class for the Netty4 HTTP component builders.
     */
    public static class NettyHttpCommonBuilder<T extends AbstractEndpointBuilder>
            extends
                AbstractEndpointBuilder<T> {
        NettyHttpCommonBuilder(String path) {
            super("netty-http", path);
        }
        /**
         * The protocol to use which is either http, https or proxy - a consumer
         * only option.
         * The option is a <code>java.lang.String</code> type.
         * @group common
         */
        public T protocol(String protocol) {
            this.properties.put("protocol", protocol);
            return (T) this;
        }
        /**
         * The local hostname such as localhost, or 0.0.0.0 when being a
         * consumer. The remote HTTP server hostname when using producer.
         * The option is a <code>java.lang.String</code> type.
         * @group common
         */
        public T host(String host) {
            this.properties.put("host", host);
            return (T) this;
        }
        /**
         * The host port number.
         * The option is a <code>int</code> type.
         * @group common
         */
        public T port(int port) {
            this.properties.put("port", port);
            return (T) this;
        }
        /**
         * The host port number.
         * The option will be converted to a <code>int</code> type.
         * @group common
         */
        public T port(String port) {
            this.properties.put("port", port);
            return (T) this;
        }
        /**
         * Resource path.
         * The option is a <code>java.lang.String</code> type.
         * @group common
         */
        public T path(String path) {
            this.properties.put("path", path);
            return (T) this;
        }
        /**
         * If the option is true, the producer will ignore the Exchange.HTTP_URI
         * header, and use the endpoint's URI for request. You may also set the
         * throwExceptionOnFailure to be false to let the producer send all the
         * fault response back. The consumer working in the bridge mode will
         * skip the gzip compression and WWW URL form encoding (by adding the
         * Exchange.SKIP_GZIP_ENCODING and Exchange.SKIP_WWW_FORM_URLENCODED
         * headers to the consumed exchange).
         * The option is a <code>boolean</code> type.
         * @group common
         */
        public T bridgeEndpoint(boolean bridgeEndpoint) {
            this.properties.put("bridgeEndpoint", bridgeEndpoint);
            return (T) this;
        }
        /**
         * If the option is true, the producer will ignore the Exchange.HTTP_URI
         * header, and use the endpoint's URI for request. You may also set the
         * throwExceptionOnFailure to be false to let the producer send all the
         * fault response back. The consumer working in the bridge mode will
         * skip the gzip compression and WWW URL form encoding (by adding the
         * Exchange.SKIP_GZIP_ENCODING and Exchange.SKIP_WWW_FORM_URLENCODED
         * headers to the consumed exchange).
         * The option will be converted to a <code>boolean</code> type.
         * @group common
         */
        public T bridgeEndpoint(String bridgeEndpoint) {
            this.properties.put("bridgeEndpoint", bridgeEndpoint);
            return (T) this;
        }
        /**
         * Whether or not to disconnect(close) from Netty Channel right after
         * use. Can be used for both consumer and producer.
         * The option is a <code>boolean</code> type.
         * @group common
         */
        public T disconnect(boolean disconnect) {
            this.properties.put("disconnect", disconnect);
            return (T) this;
        }
        /**
         * Whether or not to disconnect(close) from Netty Channel right after
         * use. Can be used for both consumer and producer.
         * The option will be converted to a <code>boolean</code> type.
         * @group common
         */
        public T disconnect(String disconnect) {
            this.properties.put("disconnect", disconnect);
            return (T) this;
        }
        /**
         * Setting to ensure socket is not closed due to inactivity.
         * The option is a <code>boolean</code> type.
         * @group common
         */
        public T keepAlive(boolean keepAlive) {
            this.properties.put("keepAlive", keepAlive);
            return (T) this;
        }
        /**
         * Setting to ensure socket is not closed due to inactivity.
         * The option will be converted to a <code>boolean</code> type.
         * @group common
         */
        public T keepAlive(String keepAlive) {
            this.properties.put("keepAlive", keepAlive);
            return (T) this;
        }
        /**
         * Setting to facilitate socket multiplexing.
         * The option is a <code>boolean</code> type.
         * @group common
         */
        public T reuseAddress(boolean reuseAddress) {
            this.properties.put("reuseAddress", reuseAddress);
            return (T) this;
        }
        /**
         * Setting to facilitate socket multiplexing.
         * The option will be converted to a <code>boolean</code> type.
         * @group common
         */
        public T reuseAddress(String reuseAddress) {
            this.properties.put("reuseAddress", reuseAddress);
            return (T) this;
        }
        /**
         * This option allows producers and consumers (in client mode) to reuse
         * the same Netty Channel for the lifecycle of processing the Exchange.
         * This is useful if you need to call a server multiple times in a Camel
         * route and want to use the same network connection. When using this,
         * the channel is not returned to the connection pool until the Exchange
         * is done; or disconnected if the disconnect option is set to true. The
         * reused Channel is stored on the Exchange as an exchange property with
         * the key NettyConstants#NETTY_CHANNEL which allows you to obtain the
         * channel during routing and use it as well.
         * The option is a <code>boolean</code> type.
         * @group common
         */
        public T reuseChannel(boolean reuseChannel) {
            this.properties.put("reuseChannel", reuseChannel);
            return (T) this;
        }
        /**
         * This option allows producers and consumers (in client mode) to reuse
         * the same Netty Channel for the lifecycle of processing the Exchange.
         * This is useful if you need to call a server multiple times in a Camel
         * route and want to use the same network connection. When using this,
         * the channel is not returned to the connection pool until the Exchange
         * is done; or disconnected if the disconnect option is set to true. The
         * reused Channel is stored on the Exchange as an exchange property with
         * the key NettyConstants#NETTY_CHANNEL which allows you to obtain the
         * channel during routing and use it as well.
         * The option will be converted to a <code>boolean</code> type.
         * @group common
         */
        public T reuseChannel(String reuseChannel) {
            this.properties.put("reuseChannel", reuseChannel);
            return (T) this;
        }
        /**
         * Setting to set endpoint as one-way or request-response.
         * The option is a <code>boolean</code> type.
         * @group common
         */
        public T sync(boolean sync) {
            this.properties.put("sync", sync);
            return (T) this;
        }
        /**
         * Setting to set endpoint as one-way or request-response.
         * The option will be converted to a <code>boolean</code> type.
         * @group common
         */
        public T sync(String sync) {
            this.properties.put("sync", sync);
            return (T) this;
        }
        /**
         * Setting to improve TCP protocol performance.
         * The option is a <code>boolean</code> type.
         * @group common
         */
        public T tcpNoDelay(boolean tcpNoDelay) {
            this.properties.put("tcpNoDelay", tcpNoDelay);
            return (T) this;
        }
        /**
         * Setting to improve TCP protocol performance.
         * The option will be converted to a <code>boolean</code> type.
         * @group common
         */
        public T tcpNoDelay(String tcpNoDelay) {
            this.properties.put("tcpNoDelay", tcpNoDelay);
            return (T) this;
        }
        /**
         * Only used for TCP when transferExchange is true. When set to true,
         * serializable objects in headers and properties will be added to the
         * exchange. Otherwise Camel will exclude any non-serializable objects
         * and log it at WARN level.
         * The option is a <code>boolean</code> type.
         * @group advanced
         */
        public T allowSerializedHeaders(boolean allowSerializedHeaders) {
            this.properties.put("allowSerializedHeaders", allowSerializedHeaders);
            return (T) this;
        }
        /**
         * Only used for TCP when transferExchange is true. When set to true,
         * serializable objects in headers and properties will be added to the
         * exchange. Otherwise Camel will exclude any non-serializable objects
         * and log it at WARN level.
         * The option will be converted to a <code>boolean</code> type.
         * @group advanced
         */
        public T allowSerializedHeaders(String allowSerializedHeaders) {
            this.properties.put("allowSerializedHeaders", allowSerializedHeaders);
            return (T) this;
        }
        /**
         * To use a explicit ChannelGroup.
         * The option is a <code>io.netty.channel.group.ChannelGroup</code>
         * type.
         * @group advanced
         */
        public T channelGroup(Object channelGroup) {
            this.properties.put("channelGroup", channelGroup);
            return (T) this;
        }
        /**
         * To use a explicit ChannelGroup.
         * The option will be converted to a
         * <code>io.netty.channel.group.ChannelGroup</code> type.
         * @group advanced
         */
        public T channelGroup(String channelGroup) {
            this.properties.put("channelGroup", channelGroup);
            return (T) this;
        }
        /**
         * To use a custom configured NettyHttpConfiguration for configuring
         * this endpoint.
         * The option is a
         * <code>org.apache.camel.component.netty4.http.NettyHttpConfiguration</code> type.
         * @group advanced
         */
        public T configuration(Object configuration) {
            this.properties.put("configuration", configuration);
            return (T) this;
        }
        /**
         * To use a custom configured NettyHttpConfiguration for configuring
         * this endpoint.
         * The option will be converted to a
         * <code>org.apache.camel.component.netty4.http.NettyHttpConfiguration</code> type.
         * @group advanced
         */
        public T configuration(String configuration) {
            this.properties.put("configuration", configuration);
            return (T) this;
        }
        /**
         * Determines whether or not the raw input stream from Netty
         * HttpRequest#getContent() or HttpResponset#getContent() is cached or
         * not (Camel will read the stream into a in light-weight memory based
         * Stream caching) cache. By default Camel will cache the Netty input
         * stream to support reading it multiple times to ensure it Camel can
         * retrieve all data from the stream. However you can set this option to
         * true when you for example need to access the raw stream, such as
         * streaming it directly to a file or other persistent store. Mind that
         * if you enable this option, then you cannot read the Netty stream
         * multiple times out of the box, and you would need manually to reset
         * the reader index on the Netty raw stream. Also Netty will auto-close
         * the Netty stream when the Netty HTTP server/HTTP client is done
         * processing, which means that if the asynchronous routing engine is in
         * use then any asynchronous thread that may continue routing the
         * org.apache.camel.Exchange may not be able to read the Netty stream,
         * because Netty has closed it.
         * The option is a <code>boolean</code> type.
         * @group advanced
         */
        public T disableStreamCache(boolean disableStreamCache) {
            this.properties.put("disableStreamCache", disableStreamCache);
            return (T) this;
        }
        /**
         * Determines whether or not the raw input stream from Netty
         * HttpRequest#getContent() or HttpResponset#getContent() is cached or
         * not (Camel will read the stream into a in light-weight memory based
         * Stream caching) cache. By default Camel will cache the Netty input
         * stream to support reading it multiple times to ensure it Camel can
         * retrieve all data from the stream. However you can set this option to
         * true when you for example need to access the raw stream, such as
         * streaming it directly to a file or other persistent store. Mind that
         * if you enable this option, then you cannot read the Netty stream
         * multiple times out of the box, and you would need manually to reset
         * the reader index on the Netty raw stream. Also Netty will auto-close
         * the Netty stream when the Netty HTTP server/HTTP client is done
         * processing, which means that if the asynchronous routing engine is in
         * use then any asynchronous thread that may continue routing the
         * org.apache.camel.Exchange may not be able to read the Netty stream,
         * because Netty has closed it.
         * The option will be converted to a <code>boolean</code> type.
         * @group advanced
         */
        public T disableStreamCache(String disableStreamCache) {
            this.properties.put("disableStreamCache", disableStreamCache);
            return (T) this;
        }
        /**
         * To use a custom org.apache.camel.spi.HeaderFilterStrategy to filter
         * headers.
         * The option is a
         * <code>org.apache.camel.spi.HeaderFilterStrategy</code> type.
         * @group advanced
         */
        public T headerFilterStrategy(HeaderFilterStrategy headerFilterStrategy) {
            this.properties.put("headerFilterStrategy", headerFilterStrategy);
            return (T) this;
        }
        /**
         * To use a custom org.apache.camel.spi.HeaderFilterStrategy to filter
         * headers.
         * The option will be converted to a
         * <code>org.apache.camel.spi.HeaderFilterStrategy</code> type.
         * @group advanced
         */
        public T headerFilterStrategy(String headerFilterStrategy) {
            this.properties.put("headerFilterStrategy", headerFilterStrategy);
            return (T) this;
        }
        /**
         * Whether to use native transport instead of NIO. Native transport
         * takes advantage of the host operating system and is only supported on
         * some platforms. You need to add the netty JAR for the host operating
         * system you are using. See more details at:
         * http://netty.io/wiki/native-transports.html.
         * The option is a <code>boolean</code> type.
         * @group advanced
         */
        public T nativeTransport(boolean nativeTransport) {
            this.properties.put("nativeTransport", nativeTransport);
            return (T) this;
        }
        /**
         * Whether to use native transport instead of NIO. Native transport
         * takes advantage of the host operating system and is only supported on
         * some platforms. You need to add the netty JAR for the host operating
         * system you are using. See more details at:
         * http://netty.io/wiki/native-transports.html.
         * The option will be converted to a <code>boolean</code> type.
         * @group advanced
         */
        public T nativeTransport(String nativeTransport) {
            this.properties.put("nativeTransport", nativeTransport);
            return (T) this;
        }
        /**
         * To use a custom
         * org.apache.camel.component.netty4.http.NettyHttpBinding for binding
         * to/from Netty and Camel Message API.
         * The option is a
         * <code>org.apache.camel.component.netty4.http.NettyHttpBinding</code>
         * type.
         * @group advanced
         */
        public T nettyHttpBinding(Object nettyHttpBinding) {
            this.properties.put("nettyHttpBinding", nettyHttpBinding);
            return (T) this;
        }
        /**
         * To use a custom
         * org.apache.camel.component.netty4.http.NettyHttpBinding for binding
         * to/from Netty and Camel Message API.
         * The option will be converted to a
         * <code>org.apache.camel.component.netty4.http.NettyHttpBinding</code>
         * type.
         * @group advanced
         */
        public T nettyHttpBinding(String nettyHttpBinding) {
            this.properties.put("nettyHttpBinding", nettyHttpBinding);
            return (T) this;
        }
        /**
         * Allows to configure additional netty options using option. as prefix.
         * For example option.child.keepAlive=false to set the netty option
         * child.keepAlive=false. See the Netty documentation for possible
         * options that can be used.
         * The option is a <code>java.util.Map&lt;java.lang.String,
         * java.lang.Object&gt;</code> type.
         * @group advanced
         */
        public T options(Map<String, Object> options) {
            this.properties.put("options", options);
            return (T) this;
        }
        /**
         * Allows to configure additional netty options using option. as prefix.
         * For example option.child.keepAlive=false to set the netty option
         * child.keepAlive=false. See the Netty documentation for possible
         * options that can be used.
         * The option will be converted to a
         * <code>java.util.Map&lt;java.lang.String, java.lang.Object&gt;</code>
         * type.
         * @group advanced
         */
        public T options(String options) {
            this.properties.put("options", options);
            return (T) this;
        }
        /**
         * The TCP/UDP buffer sizes to be used during inbound communication.
         * Size is bytes.
         * The option is a <code>int</code> type.
         * @group advanced
         */
        public T receiveBufferSize(int receiveBufferSize) {
            this.properties.put("receiveBufferSize", receiveBufferSize);
            return (T) this;
        }
        /**
         * The TCP/UDP buffer sizes to be used during inbound communication.
         * Size is bytes.
         * The option will be converted to a <code>int</code> type.
         * @group advanced
         */
        public T receiveBufferSize(String receiveBufferSize) {
            this.properties.put("receiveBufferSize", receiveBufferSize);
            return (T) this;
        }
        /**
         * Configures the buffer size predictor. See details at Jetty
         * documentation and this mail thread.
         * The option is a <code>int</code> type.
         * @group advanced
         */
        public T receiveBufferSizePredictor(int receiveBufferSizePredictor) {
            this.properties.put("receiveBufferSizePredictor", receiveBufferSizePredictor);
            return (T) this;
        }
        /**
         * Configures the buffer size predictor. See details at Jetty
         * documentation and this mail thread.
         * The option will be converted to a <code>int</code> type.
         * @group advanced
         */
        public T receiveBufferSizePredictor(String receiveBufferSizePredictor) {
            this.properties.put("receiveBufferSizePredictor", receiveBufferSizePredictor);
            return (T) this;
        }
        /**
         * The TCP/UDP buffer sizes to be used during outbound communication.
         * Size is bytes.
         * The option is a <code>int</code> type.
         * @group advanced
         */
        public T sendBufferSize(int sendBufferSize) {
            this.properties.put("sendBufferSize", sendBufferSize);
            return (T) this;
        }
        /**
         * The TCP/UDP buffer sizes to be used during outbound communication.
         * Size is bytes.
         * The option will be converted to a <code>int</code> type.
         * @group advanced
         */
        public T sendBufferSize(String sendBufferSize) {
            this.properties.put("sendBufferSize", sendBufferSize);
            return (T) this;
        }
        /**
         * If enabled and an Exchange failed processing on the consumer side,
         * and if the caused Exception was send back serialized in the response
         * as a application/x-java-serialized-object content type. On the
         * producer side the exception will be deserialized and thrown as is,
         * instead of the HttpOperationFailedException. The caused exception is
         * required to be serialized. This is by default turned off. If you
         * enable this then be aware that Java will deserialize the incoming
         * data from the request to Java and that can be a potential security
         * risk.
         * The option is a <code>boolean</code> type.
         * @group advanced
         */
        public T transferException(boolean transferException) {
            this.properties.put("transferException", transferException);
            return (T) this;
        }
        /**
         * If enabled and an Exchange failed processing on the consumer side,
         * and if the caused Exception was send back serialized in the response
         * as a application/x-java-serialized-object content type. On the
         * producer side the exception will be deserialized and thrown as is,
         * instead of the HttpOperationFailedException. The caused exception is
         * required to be serialized. This is by default turned off. If you
         * enable this then be aware that Java will deserialize the incoming
         * data from the request to Java and that can be a potential security
         * risk.
         * The option will be converted to a <code>boolean</code> type.
         * @group advanced
         */
        public T transferException(String transferException) {
            this.properties.put("transferException", transferException);
            return (T) this;
        }
        /**
         * Only used for TCP. You can transfer the exchange over the wire
         * instead of just the body. The following fields are transferred: In
         * body, Out body, fault body, In headers, Out headers, fault headers,
         * exchange properties, exchange exception. This requires that the
         * objects are serializable. Camel will exclude any non-serializable
         * objects and log it at WARN level.
         * The option is a <code>boolean</code> type.
         * @group advanced
         */
        public T transferExchange(boolean transferExchange) {
            this.properties.put("transferExchange", transferExchange);
            return (T) this;
        }
        /**
         * Only used for TCP. You can transfer the exchange over the wire
         * instead of just the body. The following fields are transferred: In
         * body, Out body, fault body, In headers, Out headers, fault headers,
         * exchange properties, exchange exception. This requires that the
         * objects are serializable. Camel will exclude any non-serializable
         * objects and log it at WARN level.
         * The option will be converted to a <code>boolean</code> type.
         * @group advanced
         */
        public T transferExchange(String transferExchange) {
            this.properties.put("transferExchange", transferExchange);
            return (T) this;
        }
        /**
         * When netty works on nio mode, it uses default workerCount parameter
         * from Netty, which is cpu_core_threads x 2. User can use this
         * operation to override the default workerCount from Netty.
         * The option is a <code>int</code> type.
         * @group advanced
         */
        public T workerCount(int workerCount) {
            this.properties.put("workerCount", workerCount);
            return (T) this;
        }
        /**
         * When netty works on nio mode, it uses default workerCount parameter
         * from Netty, which is cpu_core_threads x 2. User can use this
         * operation to override the default workerCount from Netty.
         * The option will be converted to a <code>int</code> type.
         * @group advanced
         */
        public T workerCount(String workerCount) {
            this.properties.put("workerCount", workerCount);
            return (T) this;
        }
        /**
         * To use a explicit EventLoopGroup as the boss thread pool. For example
         * to share a thread pool with multiple consumers or producers. By
         * default each consumer or producer has their own worker pool with 2 x
         * cpu count core threads.
         * The option is a <code>io.netty.channel.EventLoopGroup</code> type.
         * @group advanced
         */
        public T workerGroup(Object workerGroup) {
            this.properties.put("workerGroup", workerGroup);
            return (T) this;
        }
        /**
         * To use a explicit EventLoopGroup as the boss thread pool. For example
         * to share a thread pool with multiple consumers or producers. By
         * default each consumer or producer has their own worker pool with 2 x
         * cpu count core threads.
         * The option will be converted to a
         * <code>io.netty.channel.EventLoopGroup</code> type.
         * @group advanced
         */
        public T workerGroup(String workerGroup) {
            this.properties.put("workerGroup", workerGroup);
            return (T) this;
        }
        /**
         * To use a single decoder. This options is deprecated use encoders
         * instead.
         * The option is a <code>io.netty.channel.ChannelHandler</code> type.
         * @group codec
         */
        @Deprecated
        public T decoder(Object decoder) {
            this.properties.put("decoder", decoder);
            return (T) this;
        }
        /**
         * To use a single decoder. This options is deprecated use encoders
         * instead.
         * The option will be converted to a
         * <code>io.netty.channel.ChannelHandler</code> type.
         * @group codec
         */
        @Deprecated
        public T decoder(String decoder) {
            this.properties.put("decoder", decoder);
            return (T) this;
        }
        /**
         * A list of decoders to be used. You can use a String which have values
         * separated by comma, and have the values be looked up in the Registry.
         * Just remember to prefix the value with # so Camel knows it should
         * lookup.
         * The option is a
         * <code>java.util.List&lt;io.netty.channel.ChannelHandler&gt;</code>
         * type.
         * @group codec
         */
        public T decoders(List<Object> decoders) {
            this.properties.put("decoders", decoders);
            return (T) this;
        }
        /**
         * A list of decoders to be used. You can use a String which have values
         * separated by comma, and have the values be looked up in the Registry.
         * Just remember to prefix the value with # so Camel knows it should
         * lookup.
         * The option will be converted to a
         * <code>java.util.List&lt;io.netty.channel.ChannelHandler&gt;</code>
         * type.
         * @group codec
         */
        public T decoders(String decoders) {
            this.properties.put("decoders", decoders);
            return (T) this;
        }
        /**
         * To use a single encoder. This options is deprecated use encoders
         * instead.
         * The option is a <code>io.netty.channel.ChannelHandler</code> type.
         * @group codec
         */
        @Deprecated
        public T encoder(Object encoder) {
            this.properties.put("encoder", encoder);
            return (T) this;
        }
        /**
         * To use a single encoder. This options is deprecated use encoders
         * instead.
         * The option will be converted to a
         * <code>io.netty.channel.ChannelHandler</code> type.
         * @group codec
         */
        @Deprecated
        public T encoder(String encoder) {
            this.properties.put("encoder", encoder);
            return (T) this;
        }
        /**
         * A list of encoders to be used. You can use a String which have values
         * separated by comma, and have the values be looked up in the Registry.
         * Just remember to prefix the value with # so Camel knows it should
         * lookup.
         * The option is a
         * <code>java.util.List&lt;io.netty.channel.ChannelHandler&gt;</code>
         * type.
         * @group codec
         */
        public T encoders(List<Object> encoders) {
            this.properties.put("encoders", encoders);
            return (T) this;
        }
        /**
         * A list of encoders to be used. You can use a String which have values
         * separated by comma, and have the values be looked up in the Registry.
         * Just remember to prefix the value with # so Camel knows it should
         * lookup.
         * The option will be converted to a
         * <code>java.util.List&lt;io.netty.channel.ChannelHandler&gt;</code>
         * type.
         * @group codec
         */
        public T encoders(String encoders) {
            this.properties.put("encoders", encoders);
            return (T) this;
        }
        /**
         * Which protocols to enable when using SSL.
         * The option is a <code>java.lang.String</code> type.
         * @group security
         */
        public T enabledProtocols(String enabledProtocols) {
            this.properties.put("enabledProtocols", enabledProtocols);
            return (T) this;
        }
        /**
         * Client side certificate keystore to be used for encryption.
         * The option is a <code>java.io.File</code> type.
         * @group security
         */
        public T keyStoreFile(File keyStoreFile) {
            this.properties.put("keyStoreFile", keyStoreFile);
            return (T) this;
        }
        /**
         * Client side certificate keystore to be used for encryption.
         * The option will be converted to a <code>java.io.File</code> type.
         * @group security
         */
        public T keyStoreFile(String keyStoreFile) {
            this.properties.put("keyStoreFile", keyStoreFile);
            return (T) this;
        }
        /**
         * Keystore format to be used for payload encryption. Defaults to JKS if
         * not set.
         * The option is a <code>java.lang.String</code> type.
         * @group security
         */
        public T keyStoreFormat(String keyStoreFormat) {
            this.properties.put("keyStoreFormat", keyStoreFormat);
            return (T) this;
        }
        /**
         * Client side certificate keystore to be used for encryption. Is loaded
         * by default from classpath, but you can prefix with classpath:, file:,
         * or http: to load the resource from different systems.
         * The option is a <code>java.lang.String</code> type.
         * @group security
         */
        public T keyStoreResource(String keyStoreResource) {
            this.properties.put("keyStoreResource", keyStoreResource);
            return (T) this;
        }
        /**
         * Password setting to use in order to encrypt/decrypt payloads sent
         * using SSH.
         * The option is a <code>java.lang.String</code> type.
         * @group security
         */
        public T passphrase(String passphrase) {
            this.properties.put("passphrase", passphrase);
            return (T) this;
        }
        /**
         * Security provider to be used for payload encryption. Defaults to
         * SunX509 if not set.
         * The option is a <code>java.lang.String</code> type.
         * @group security
         */
        public T securityProvider(String securityProvider) {
            this.properties.put("securityProvider", securityProvider);
            return (T) this;
        }
        /**
         * Setting to specify whether SSL encryption is applied to this
         * endpoint.
         * The option is a <code>boolean</code> type.
         * @group security
         */
        public T ssl(boolean ssl) {
            this.properties.put("ssl", ssl);
            return (T) this;
        }
        /**
         * Setting to specify whether SSL encryption is applied to this
         * endpoint.
         * The option will be converted to a <code>boolean</code> type.
         * @group security
         */
        public T ssl(String ssl) {
            this.properties.put("ssl", ssl);
            return (T) this;
        }
        /**
         * When enabled and in SSL mode, then the Netty consumer will enrich the
         * Camel Message with headers having information about the client
         * certificate such as subject name, issuer name, serial number, and the
         * valid date range.
         * The option is a <code>boolean</code> type.
         * @group security
         */
        public T sslClientCertHeaders(boolean sslClientCertHeaders) {
            this.properties.put("sslClientCertHeaders", sslClientCertHeaders);
            return (T) this;
        }
        /**
         * When enabled and in SSL mode, then the Netty consumer will enrich the
         * Camel Message with headers having information about the client
         * certificate such as subject name, issuer name, serial number, and the
         * valid date range.
         * The option will be converted to a <code>boolean</code> type.
         * @group security
         */
        public T sslClientCertHeaders(String sslClientCertHeaders) {
            this.properties.put("sslClientCertHeaders", sslClientCertHeaders);
            return (T) this;
        }
        /**
         * To configure security using SSLContextParameters.
         * The option is a
         * <code>org.apache.camel.support.jsse.SSLContextParameters</code> type.
         * @group security
         */
        public T sslContextParameters(Object sslContextParameters) {
            this.properties.put("sslContextParameters", sslContextParameters);
            return (T) this;
        }
        /**
         * To configure security using SSLContextParameters.
         * The option will be converted to a
         * <code>org.apache.camel.support.jsse.SSLContextParameters</code> type.
         * @group security
         */
        public T sslContextParameters(String sslContextParameters) {
            this.properties.put("sslContextParameters", sslContextParameters);
            return (T) this;
        }
        /**
         * Reference to a class that could be used to return an SSL Handler.
         * The option is a <code>io.netty.handler.ssl.SslHandler</code> type.
         * @group security
         */
        public T sslHandler(Object sslHandler) {
            this.properties.put("sslHandler", sslHandler);
            return (T) this;
        }
        /**
         * Reference to a class that could be used to return an SSL Handler.
         * The option will be converted to a
         * <code>io.netty.handler.ssl.SslHandler</code> type.
         * @group security
         */
        public T sslHandler(String sslHandler) {
            this.properties.put("sslHandler", sslHandler);
            return (T) this;
        }
        /**
         * Server side certificate keystore to be used for encryption.
         * The option is a <code>java.io.File</code> type.
         * @group security
         */
        public T trustStoreFile(File trustStoreFile) {
            this.properties.put("trustStoreFile", trustStoreFile);
            return (T) this;
        }
        /**
         * Server side certificate keystore to be used for encryption.
         * The option will be converted to a <code>java.io.File</code> type.
         * @group security
         */
        public T trustStoreFile(String trustStoreFile) {
            this.properties.put("trustStoreFile", trustStoreFile);
            return (T) this;
        }
        /**
         * Server side certificate keystore to be used for encryption. Is loaded
         * by default from classpath, but you can prefix with classpath:, file:,
         * or http: to load the resource from different systems.
         * The option is a <code>java.lang.String</code> type.
         * @group security
         */
        public T trustStoreResource(String trustStoreResource) {
            this.properties.put("trustStoreResource", trustStoreResource);
            return (T) this;
        }
        /**
         * Whether the endpoint should use basic property binding (Camel 2.x) or
         * the newer property binding with additional capabilities.
         * The option is a <code>boolean</code> type.
         * @group advanced
         */
        public T basicPropertyBinding(boolean basicPropertyBinding) {
            this.properties.put("basicPropertyBinding", basicPropertyBinding);
            return (T) this;
        }
        /**
         * Whether the endpoint should use basic property binding (Camel 2.x) or
         * the newer property binding with additional capabilities.
         * The option will be converted to a <code>boolean</code> type.
         * @group advanced
         */
        public T basicPropertyBinding(String basicPropertyBinding) {
            this.properties.put("basicPropertyBinding", basicPropertyBinding);
            return (T) this;
        }
        /**
         * To use a custom configured NettyServerBootstrapConfiguration for
         * configuring this endpoint.
         * The option is a <code>java.lang.Object</code> type.
         * @group advanced
         */
        public T bootstrapConfiguration(Object bootstrapConfiguration) {
            this.properties.put("bootstrapConfiguration", bootstrapConfiguration);
            return (T) this;
        }
        /**
         * To use a custom configured NettyServerBootstrapConfiguration for
         * configuring this endpoint.
         * The option will be converted to a <code>java.lang.Object</code> type.
         * @group advanced
         */
        public T bootstrapConfiguration(String bootstrapConfiguration) {
            this.properties.put("bootstrapConfiguration", bootstrapConfiguration);
            return (T) this;
        }
        /**
         * Sets whether synchronous processing should be strictly used, or Camel
         * is allowed to use asynchronous processing (if supported).
         * The option is a <code>boolean</code> type.
         * @group advanced
         */
        public T synchronous(boolean synchronous) {
            this.properties.put("synchronous", synchronous);
            return (T) this;
        }
        /**
         * Sets whether synchronous processing should be strictly used, or Camel
         * is allowed to use asynchronous processing (if supported).
         * The option will be converted to a <code>boolean</code> type.
         * @group advanced
         */
        public T synchronous(String synchronous) {
            this.properties.put("synchronous", synchronous);
            return (T) this;
        }
    }

    /**
     * Builder for endpoint consumers for the Netty4 HTTP component.
     */
    public static class NettyHttpConsumerBuilder
            extends
                NettyHttpCommonBuilder<NettyHttpConsumerBuilder>
            implements
                EndpointConsumerBuilder {
        public NettyHttpConsumerBuilder(String path) {
            super(path);
        }
        /**
         * Whether or not Camel should try to find a target consumer by matching
         * the URI prefix if no exact match is found.
         * The option is a <code>boolean</code> type.
         * @group consumer
         */
        public NettyHttpConsumerBuilder matchOnUriPrefix(
                boolean matchOnUriPrefix) {
            this.properties.put("matchOnUriPrefix", matchOnUriPrefix);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * Whether or not Camel should try to find a target consumer by matching
         * the URI prefix if no exact match is found.
         * The option will be converted to a <code>boolean</code> type.
         * @group consumer
         */
        public NettyHttpConsumerBuilder matchOnUriPrefix(String matchOnUriPrefix) {
            this.properties.put("matchOnUriPrefix", matchOnUriPrefix);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * Whether to send back HTTP status code 503 when the consumer has been
         * suspended. If the option is false then the Netty Acceptor is unbound
         * when the consumer is suspended, so clients cannot connect anymore.
         * The option is a <code>boolean</code> type.
         * @group consumer
         */
        public NettyHttpConsumerBuilder send503whenSuspended(
                boolean send503whenSuspended) {
            this.properties.put("send503whenSuspended", send503whenSuspended);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * Whether to send back HTTP status code 503 when the consumer has been
         * suspended. If the option is false then the Netty Acceptor is unbound
         * when the consumer is suspended, so clients cannot connect anymore.
         * The option will be converted to a <code>boolean</code> type.
         * @group consumer
         */
        public NettyHttpConsumerBuilder send503whenSuspended(
                String send503whenSuspended) {
            this.properties.put("send503whenSuspended", send503whenSuspended);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * Allows to configure a backlog for netty consumer (server). Note the
         * backlog is just a best effort depending on the OS. Setting this
         * option to a value such as 200, 500 or 1000, tells the TCP stack how
         * long the accept queue can be If this option is not configured, then
         * the backlog depends on OS setting.
         * The option is a <code>int</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder backlog(int backlog) {
            this.properties.put("backlog", backlog);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * Allows to configure a backlog for netty consumer (server). Note the
         * backlog is just a best effort depending on the OS. Setting this
         * option to a value such as 200, 500 or 1000, tells the TCP stack how
         * long the accept queue can be If this option is not configured, then
         * the backlog depends on OS setting.
         * The option will be converted to a <code>int</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder backlog(String backlog) {
            this.properties.put("backlog", backlog);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * When netty works on nio mode, it uses default bossCount parameter
         * from Netty, which is 1. User can use this operation to override the
         * default bossCount from Netty.
         * The option is a <code>int</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder bossCount(int bossCount) {
            this.properties.put("bossCount", bossCount);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * When netty works on nio mode, it uses default bossCount parameter
         * from Netty, which is 1. User can use this operation to override the
         * default bossCount from Netty.
         * The option will be converted to a <code>int</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder bossCount(String bossCount) {
            this.properties.put("bossCount", bossCount);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * Set the BossGroup which could be used for handling the new connection
         * of the server side across the NettyEndpoint.
         * The option is a <code>io.netty.channel.EventLoopGroup</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder bossGroup(Object bossGroup) {
            this.properties.put("bossGroup", bossGroup);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * Set the BossGroup which could be used for handling the new connection
         * of the server side across the NettyEndpoint.
         * The option will be converted to a
         * <code>io.netty.channel.EventLoopGroup</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder bossGroup(String bossGroup) {
            this.properties.put("bossGroup", bossGroup);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * Value in bytes the max content length per chunked frame received on
         * the Netty HTTP server.
         * The option is a <code>int</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder chunkedMaxContentLength(
                int chunkedMaxContentLength) {
            this.properties.put("chunkedMaxContentLength", chunkedMaxContentLength);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * Value in bytes the max content length per chunked frame received on
         * the Netty HTTP server.
         * The option will be converted to a <code>int</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder chunkedMaxContentLength(
                String chunkedMaxContentLength) {
            this.properties.put("chunkedMaxContentLength", chunkedMaxContentLength);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * Allow using gzip/deflate for compression on the Netty HTTP server if
         * the client supports it from the HTTP headers.
         * The option is a <code>boolean</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder compression(boolean compression) {
            this.properties.put("compression", compression);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * Allow using gzip/deflate for compression on the Netty HTTP server if
         * the client supports it from the HTTP headers.
         * The option will be converted to a <code>boolean</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder compression(String compression) {
            this.properties.put("compression", compression);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * If sync is enabled then this option dictates NettyConsumer if it
         * should disconnect where there is no reply to send back.
         * The option is a <code>boolean</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder disconnectOnNoReply(
                boolean disconnectOnNoReply) {
            this.properties.put("disconnectOnNoReply", disconnectOnNoReply);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * If sync is enabled then this option dictates NettyConsumer if it
         * should disconnect where there is no reply to send back.
         * The option will be converted to a <code>boolean</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder disconnectOnNoReply(
                String disconnectOnNoReply) {
            this.properties.put("disconnectOnNoReply", disconnectOnNoReply);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * To disable HTTP methods on the Netty HTTP consumer. You can specify
         * multiple separated by comma.
         * The option is a <code>java.lang.String</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder httpMethodRestrict(
                String httpMethodRestrict) {
            this.properties.put("httpMethodRestrict", httpMethodRestrict);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * If this option is enabled, then during binding from Netty to Camel
         * Message then the headers will be mapped as well (eg added as header
         * to the Camel Message as well). You can turn off this option to
         * disable this. The headers can still be accessed from the
         * org.apache.camel.component.netty.http.NettyHttpMessage message with
         * the method getHttpRequest() that returns the Netty HTTP request
         * io.netty.handler.codec.http.HttpRequest instance.
         * The option is a <code>boolean</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder mapHeaders(boolean mapHeaders) {
            this.properties.put("mapHeaders", mapHeaders);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * If this option is enabled, then during binding from Netty to Camel
         * Message then the headers will be mapped as well (eg added as header
         * to the Camel Message as well). You can turn off this option to
         * disable this. The headers can still be accessed from the
         * org.apache.camel.component.netty.http.NettyHttpMessage message with
         * the method getHttpRequest() that returns the Netty HTTP request
         * io.netty.handler.codec.http.HttpRequest instance.
         * The option will be converted to a <code>boolean</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder mapHeaders(String mapHeaders) {
            this.properties.put("mapHeaders", mapHeaders);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * The maximum length of all headers. If the sum of the length of each
         * header exceeds this value, a
         * io.netty.handler.codec.TooLongFrameException will be raised.
         * The option is a <code>int</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder maxHeaderSize(int maxHeaderSize) {
            this.properties.put("maxHeaderSize", maxHeaderSize);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * The maximum length of all headers. If the sum of the length of each
         * header exceeds this value, a
         * io.netty.handler.codec.TooLongFrameException will be raised.
         * The option will be converted to a <code>int</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder maxHeaderSize(String maxHeaderSize) {
            this.properties.put("maxHeaderSize", maxHeaderSize);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * To use a custom NettyServerBootstrapFactory.
         * The option is a
         * <code>org.apache.camel.component.netty4.NettyServerBootstrapFactory</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder nettyServerBootstrapFactory(
                Object nettyServerBootstrapFactory) {
            this.properties.put("nettyServerBootstrapFactory", nettyServerBootstrapFactory);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * To use a custom NettyServerBootstrapFactory.
         * The option will be converted to a
         * <code>org.apache.camel.component.netty4.NettyServerBootstrapFactory</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder nettyServerBootstrapFactory(
                String nettyServerBootstrapFactory) {
            this.properties.put("nettyServerBootstrapFactory", nettyServerBootstrapFactory);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * To use a shared Netty HTTP server. See Netty HTTP Server Example for
         * more details.
         * The option is a
         * <code>org.apache.camel.component.netty4.http.NettySharedHttpServer</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder nettySharedHttpServer(
                Object nettySharedHttpServer) {
            this.properties.put("nettySharedHttpServer", nettySharedHttpServer);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * To use a shared Netty HTTP server. See Netty HTTP Server Example for
         * more details.
         * The option will be converted to a
         * <code>org.apache.camel.component.netty4.http.NettySharedHttpServer</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder nettySharedHttpServer(
                String nettySharedHttpServer) {
            this.properties.put("nettySharedHttpServer", nettySharedHttpServer);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * If sync is enabled this option dictates NettyConsumer which logging
         * level to use when logging a there is no reply to send back.
         * The option is a <code>org.apache.camel.LoggingLevel</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder noReplyLogLevel(
                LoggingLevel noReplyLogLevel) {
            this.properties.put("noReplyLogLevel", noReplyLogLevel);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * If sync is enabled this option dictates NettyConsumer which logging
         * level to use when logging a there is no reply to send back.
         * The option will be converted to a
         * <code>org.apache.camel.LoggingLevel</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder noReplyLogLevel(String noReplyLogLevel) {
            this.properties.put("noReplyLogLevel", noReplyLogLevel);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * If the server (NettyConsumer) catches an
         * java.nio.channels.ClosedChannelException then its logged using this
         * logging level. This is used to avoid logging the closed channel
         * exceptions, as clients can disconnect abruptly and then cause a flood
         * of closed exceptions in the Netty server.
         * The option is a <code>org.apache.camel.LoggingLevel</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder serverClosedChannelExceptionCaughtLogLevel(
                LoggingLevel serverClosedChannelExceptionCaughtLogLevel) {
            this.properties.put("serverClosedChannelExceptionCaughtLogLevel", serverClosedChannelExceptionCaughtLogLevel);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * If the server (NettyConsumer) catches an
         * java.nio.channels.ClosedChannelException then its logged using this
         * logging level. This is used to avoid logging the closed channel
         * exceptions, as clients can disconnect abruptly and then cause a flood
         * of closed exceptions in the Netty server.
         * The option will be converted to a
         * <code>org.apache.camel.LoggingLevel</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder serverClosedChannelExceptionCaughtLogLevel(
                String serverClosedChannelExceptionCaughtLogLevel) {
            this.properties.put("serverClosedChannelExceptionCaughtLogLevel", serverClosedChannelExceptionCaughtLogLevel);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * If the server (NettyConsumer) catches an exception then its logged
         * using this logging level.
         * The option is a <code>org.apache.camel.LoggingLevel</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder serverExceptionCaughtLogLevel(
                LoggingLevel serverExceptionCaughtLogLevel) {
            this.properties.put("serverExceptionCaughtLogLevel", serverExceptionCaughtLogLevel);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * If the server (NettyConsumer) catches an exception then its logged
         * using this logging level.
         * The option will be converted to a
         * <code>org.apache.camel.LoggingLevel</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder serverExceptionCaughtLogLevel(
                String serverExceptionCaughtLogLevel) {
            this.properties.put("serverExceptionCaughtLogLevel", serverExceptionCaughtLogLevel);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * To use a custom ServerInitializerFactory.
         * The option is a
         * <code>org.apache.camel.component.netty4.ServerInitializerFactory</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder serverInitializerFactory(
                Object serverInitializerFactory) {
            this.properties.put("serverInitializerFactory", serverInitializerFactory);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * To use a custom ServerInitializerFactory.
         * The option will be converted to a
         * <code>org.apache.camel.component.netty4.ServerInitializerFactory</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder serverInitializerFactory(
                String serverInitializerFactory) {
            this.properties.put("serverInitializerFactory", serverInitializerFactory);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * Specifies whether to enable HTTP TRACE for this Netty HTTP consumer.
         * By default TRACE is turned off.
         * The option is a <code>boolean</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder traceEnabled(boolean traceEnabled) {
            this.properties.put("traceEnabled", traceEnabled);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * Specifies whether to enable HTTP TRACE for this Netty HTTP consumer.
         * By default TRACE is turned off.
         * The option will be converted to a <code>boolean</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder traceEnabled(String traceEnabled) {
            this.properties.put("traceEnabled", traceEnabled);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * If this option is enabled, then during binding from Netty to Camel
         * Message then the header values will be URL decoded (eg %20 will be a
         * space character. Notice this option is used by the default
         * org.apache.camel.component.netty.http.NettyHttpBinding and therefore
         * if you implement a custom
         * org.apache.camel.component.netty4.http.NettyHttpBinding then you
         * would need to decode the headers accordingly to this option.
         * The option is a <code>boolean</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder urlDecodeHeaders(
                boolean urlDecodeHeaders) {
            this.properties.put("urlDecodeHeaders", urlDecodeHeaders);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * If this option is enabled, then during binding from Netty to Camel
         * Message then the header values will be URL decoded (eg %20 will be a
         * space character. Notice this option is used by the default
         * org.apache.camel.component.netty.http.NettyHttpBinding and therefore
         * if you implement a custom
         * org.apache.camel.component.netty4.http.NettyHttpBinding then you
         * would need to decode the headers accordingly to this option.
         * The option will be converted to a <code>boolean</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder urlDecodeHeaders(String urlDecodeHeaders) {
            this.properties.put("urlDecodeHeaders", urlDecodeHeaders);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * Whether to use ordered thread pool, to ensure events are processed
         * orderly on the same channel.
         * The option is a <code>boolean</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder usingExecutorService(
                boolean usingExecutorService) {
            this.properties.put("usingExecutorService", usingExecutorService);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * Whether to use ordered thread pool, to ensure events are processed
         * orderly on the same channel.
         * The option will be converted to a <code>boolean</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder usingExecutorService(
                String usingExecutorService) {
            this.properties.put("usingExecutorService", usingExecutorService);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * Configures whether the server needs client authentication when using
         * SSL.
         * The option is a <code>boolean</code> type.
         * @group security
         */
        public NettyHttpConsumerBuilder needClientAuth(boolean needClientAuth) {
            this.properties.put("needClientAuth", needClientAuth);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * Configures whether the server needs client authentication when using
         * SSL.
         * The option will be converted to a <code>boolean</code> type.
         * @group security
         */
        public NettyHttpConsumerBuilder needClientAuth(String needClientAuth) {
            this.properties.put("needClientAuth", needClientAuth);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * Refers to a
         * org.apache.camel.component.netty4.http.NettyHttpSecurityConfiguration
         * for configuring secure web resources.
         * The option is a
         * <code>org.apache.camel.component.netty4.http.NettyHttpSecurityConfiguration</code> type.
         * @group security
         */
        public NettyHttpConsumerBuilder securityConfiguration(
                Object securityConfiguration) {
            this.properties.put("securityConfiguration", securityConfiguration);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * Refers to a
         * org.apache.camel.component.netty4.http.NettyHttpSecurityConfiguration
         * for configuring secure web resources.
         * The option will be converted to a
         * <code>org.apache.camel.component.netty4.http.NettyHttpSecurityConfiguration</code> type.
         * @group security
         */
        public NettyHttpConsumerBuilder securityConfiguration(
                String securityConfiguration) {
            this.properties.put("securityConfiguration", securityConfiguration);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * To configure NettyHttpSecurityConfiguration using key/value pairs
         * from the map.
         * The option is a <code>java.util.Map&lt;java.lang.String,
         * java.lang.Object&gt;</code> type.
         * @group security
         */
        public NettyHttpConsumerBuilder securityOptions(
                Map<String, Object> securityOptions) {
            this.properties.put("securityOptions", securityOptions);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * To configure NettyHttpSecurityConfiguration using key/value pairs
         * from the map.
         * The option will be converted to a
         * <code>java.util.Map&lt;java.lang.String, java.lang.Object&gt;</code>
         * type.
         * @group security
         */
        public NettyHttpConsumerBuilder securityOptions(String securityOptions) {
            this.properties.put("securityOptions", securityOptions);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * Allows for bridging the consumer to the Camel routing Error Handler,
         * which mean any exceptions occurred while the consumer is trying to
         * pickup incoming messages, or the likes, will now be processed as a
         * message and handled by the routing Error Handler. By default the
         * consumer will use the org.apache.camel.spi.ExceptionHandler to deal
         * with exceptions, that will be logged at WARN or ERROR level and
         * ignored.
         * The option is a <code>boolean</code> type.
         * @group consumer
         */
        public NettyHttpConsumerBuilder bridgeErrorHandler(
                boolean bridgeErrorHandler) {
            this.properties.put("bridgeErrorHandler", bridgeErrorHandler);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * Allows for bridging the consumer to the Camel routing Error Handler,
         * which mean any exceptions occurred while the consumer is trying to
         * pickup incoming messages, or the likes, will now be processed as a
         * message and handled by the routing Error Handler. By default the
         * consumer will use the org.apache.camel.spi.ExceptionHandler to deal
         * with exceptions, that will be logged at WARN or ERROR level and
         * ignored.
         * The option will be converted to a <code>boolean</code> type.
         * @group consumer
         */
        public NettyHttpConsumerBuilder bridgeErrorHandler(
                String bridgeErrorHandler) {
            this.properties.put("bridgeErrorHandler", bridgeErrorHandler);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * To let the consumer use a custom ExceptionHandler. Notice if the
         * option bridgeErrorHandler is enabled then this option is not in use.
         * By default the consumer will deal with exceptions, that will be
         * logged at WARN or ERROR level and ignored.
         * The option is a <code>org.apache.camel.spi.ExceptionHandler</code>
         * type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder exceptionHandler(
                ExceptionHandler exceptionHandler) {
            this.properties.put("exceptionHandler", exceptionHandler);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * To let the consumer use a custom ExceptionHandler. Notice if the
         * option bridgeErrorHandler is enabled then this option is not in use.
         * By default the consumer will deal with exceptions, that will be
         * logged at WARN or ERROR level and ignored.
         * The option will be converted to a
         * <code>org.apache.camel.spi.ExceptionHandler</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder exceptionHandler(String exceptionHandler) {
            this.properties.put("exceptionHandler", exceptionHandler);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * Sets the exchange pattern when the consumer creates an exchange.
         * The option is a <code>org.apache.camel.ExchangePattern</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder exchangePattern(
                ExchangePattern exchangePattern) {
            this.properties.put("exchangePattern", exchangePattern);
            return (NettyHttpConsumerBuilder) this;
        }
        /**
         * Sets the exchange pattern when the consumer creates an exchange.
         * The option will be converted to a
         * <code>org.apache.camel.ExchangePattern</code> type.
         * @group consumer (advanced)
         */
        public NettyHttpConsumerBuilder exchangePattern(String exchangePattern) {
            this.properties.put("exchangePattern", exchangePattern);
            return (NettyHttpConsumerBuilder) this;
        }
    }

    /**
     * Builder for endpoint producers for the Netty4 HTTP component.
     */
    public static class NettyHttpProducerBuilder
            extends
                NettyHttpCommonBuilder<NettyHttpProducerBuilder>
            implements
                EndpointProducerBuilder {
        public NettyHttpProducerBuilder(String path) {
            super(path);
        }
        /**
         * Time to wait for a socket connection to be available. Value is in
         * milliseconds.
         * The option is a <code>int</code> type.
         * @group producer
         */
        public NettyHttpProducerBuilder connectTimeout(int connectTimeout) {
            this.properties.put("connectTimeout", connectTimeout);
            return (NettyHttpProducerBuilder) this;
        }
        /**
         * Time to wait for a socket connection to be available. Value is in
         * milliseconds.
         * The option will be converted to a <code>int</code> type.
         * @group producer
         */
        public NettyHttpProducerBuilder connectTimeout(String connectTimeout) {
            this.properties.put("connectTimeout", connectTimeout);
            return (NettyHttpProducerBuilder) this;
        }
        /**
         * Configure a cookie handler to maintain a HTTP session.
         * The option is a
         * <code>org.apache.camel.http.common.cookie.CookieHandler</code> type.
         * @group producer
         */
        public NettyHttpProducerBuilder cookieHandler(Object cookieHandler) {
            this.properties.put("cookieHandler", cookieHandler);
            return (NettyHttpProducerBuilder) this;
        }
        /**
         * Configure a cookie handler to maintain a HTTP session.
         * The option will be converted to a
         * <code>org.apache.camel.http.common.cookie.CookieHandler</code> type.
         * @group producer
         */
        public NettyHttpProducerBuilder cookieHandler(String cookieHandler) {
            this.properties.put("cookieHandler", cookieHandler);
            return (NettyHttpProducerBuilder) this;
        }
        /**
         * Allows to use a timeout for the Netty producer when calling a remote
         * server. By default no timeout is in use. The value is in milli
         * seconds, so eg 30000 is 30 seconds. The requestTimeout is using
         * Netty's ReadTimeoutHandler to trigger the timeout.
         * The option is a <code>long</code> type.
         * @group producer
         */
        public NettyHttpProducerBuilder requestTimeout(long requestTimeout) {
            this.properties.put("requestTimeout", requestTimeout);
            return (NettyHttpProducerBuilder) this;
        }
        /**
         * Allows to use a timeout for the Netty producer when calling a remote
         * server. By default no timeout is in use. The value is in milli
         * seconds, so eg 30000 is 30 seconds. The requestTimeout is using
         * Netty's ReadTimeoutHandler to trigger the timeout.
         * The option will be converted to a <code>long</code> type.
         * @group producer
         */
        public NettyHttpProducerBuilder requestTimeout(String requestTimeout) {
            this.properties.put("requestTimeout", requestTimeout);
            return (NettyHttpProducerBuilder) this;
        }
        /**
         * Option to disable throwing the HttpOperationFailedException in case
         * of failed responses from the remote server. This allows you to get
         * all responses regardless of the HTTP status code.
         * The option is a <code>boolean</code> type.
         * @group producer
         */
        public NettyHttpProducerBuilder throwExceptionOnFailure(
                boolean throwExceptionOnFailure) {
            this.properties.put("throwExceptionOnFailure", throwExceptionOnFailure);
            return (NettyHttpProducerBuilder) this;
        }
        /**
         * Option to disable throwing the HttpOperationFailedException in case
         * of failed responses from the remote server. This allows you to get
         * all responses regardless of the HTTP status code.
         * The option will be converted to a <code>boolean</code> type.
         * @group producer
         */
        public NettyHttpProducerBuilder throwExceptionOnFailure(
                String throwExceptionOnFailure) {
            this.properties.put("throwExceptionOnFailure", throwExceptionOnFailure);
            return (NettyHttpProducerBuilder) this;
        }
        /**
         * To use a custom ClientInitializerFactory.
         * The option is a
         * <code>org.apache.camel.component.netty4.ClientInitializerFactory</code> type.
         * @group producer (advanced)
         */
        public NettyHttpProducerBuilder clientInitializerFactory(
                Object clientInitializerFactory) {
            this.properties.put("clientInitializerFactory", clientInitializerFactory);
            return (NettyHttpProducerBuilder) this;
        }
        /**
         * To use a custom ClientInitializerFactory.
         * The option will be converted to a
         * <code>org.apache.camel.component.netty4.ClientInitializerFactory</code> type.
         * @group producer (advanced)
         */
        public NettyHttpProducerBuilder clientInitializerFactory(
                String clientInitializerFactory) {
            this.properties.put("clientInitializerFactory", clientInitializerFactory);
            return (NettyHttpProducerBuilder) this;
        }
        /**
         * Channels can be lazily created to avoid exceptions, if the remote
         * server is not up and running when the Camel producer is started.
         * The option is a <code>boolean</code> type.
         * @group producer (advanced)
         */
        public NettyHttpProducerBuilder lazyChannelCreation(
                boolean lazyChannelCreation) {
            this.properties.put("lazyChannelCreation", lazyChannelCreation);
            return (NettyHttpProducerBuilder) this;
        }
        /**
         * Channels can be lazily created to avoid exceptions, if the remote
         * server is not up and running when the Camel producer is started.
         * The option will be converted to a <code>boolean</code> type.
         * @group producer (advanced)
         */
        public NettyHttpProducerBuilder lazyChannelCreation(
                String lazyChannelCreation) {
            this.properties.put("lazyChannelCreation", lazyChannelCreation);
            return (NettyHttpProducerBuilder) this;
        }
        /**
         * The status codes which are considered a success response. The values
         * are inclusive. Multiple ranges can be defined, separated by comma,
         * e.g. 200-204,209,301-304. Each range must be a single number or
         * from-to with the dash included. The default range is 200-299.
         * The option is a <code>java.lang.String</code> type.
         * @group producer (advanced)
         */
        public NettyHttpProducerBuilder okStatusCodeRange(
                String okStatusCodeRange) {
            this.properties.put("okStatusCodeRange", okStatusCodeRange);
            return (NettyHttpProducerBuilder) this;
        }
        /**
         * Whether producer pool is enabled or not. Important: If you turn this
         * off then a single shared connection is used for the producer, also if
         * you are doing request/reply. That means there is a potential issue
         * with interleaved responses if replies comes back out-of-order.
         * Therefore you need to have a correlation id in both the request and
         * reply messages so you can properly correlate the replies to the Camel
         * callback that is responsible for continue processing the message in
         * Camel. To do this you need to implement
         * NettyCamelStateCorrelationManager as correlation manager and
         * configure it via the correlationManager option. See also the
         * correlationManager option for more details.
         * The option is a <code>boolean</code> type.
         * @group producer (advanced)
         */
        public NettyHttpProducerBuilder producerPoolEnabled(
                boolean producerPoolEnabled) {
            this.properties.put("producerPoolEnabled", producerPoolEnabled);
            return (NettyHttpProducerBuilder) this;
        }
        /**
         * Whether producer pool is enabled or not. Important: If you turn this
         * off then a single shared connection is used for the producer, also if
         * you are doing request/reply. That means there is a potential issue
         * with interleaved responses if replies comes back out-of-order.
         * Therefore you need to have a correlation id in both the request and
         * reply messages so you can properly correlate the replies to the Camel
         * callback that is responsible for continue processing the message in
         * Camel. To do this you need to implement
         * NettyCamelStateCorrelationManager as correlation manager and
         * configure it via the correlationManager option. See also the
         * correlationManager option for more details.
         * The option will be converted to a <code>boolean</code> type.
         * @group producer (advanced)
         */
        public NettyHttpProducerBuilder producerPoolEnabled(
                String producerPoolEnabled) {
            this.properties.put("producerPoolEnabled", producerPoolEnabled);
            return (NettyHttpProducerBuilder) this;
        }
        /**
         * Sets the cap on the number of objects that can be allocated by the
         * pool (checked out to clients, or idle awaiting checkout) at a given
         * time. Use a negative value for no limit.
         * The option is a <code>int</code> type.
         * @group producer (advanced)
         */
        public NettyHttpProducerBuilder producerPoolMaxActive(
                int producerPoolMaxActive) {
            this.properties.put("producerPoolMaxActive", producerPoolMaxActive);
            return (NettyHttpProducerBuilder) this;
        }
        /**
         * Sets the cap on the number of objects that can be allocated by the
         * pool (checked out to clients, or idle awaiting checkout) at a given
         * time. Use a negative value for no limit.
         * The option will be converted to a <code>int</code> type.
         * @group producer (advanced)
         */
        public NettyHttpProducerBuilder producerPoolMaxActive(
                String producerPoolMaxActive) {
            this.properties.put("producerPoolMaxActive", producerPoolMaxActive);
            return (NettyHttpProducerBuilder) this;
        }
        /**
         * Sets the cap on the number of idle instances in the pool.
         * The option is a <code>int</code> type.
         * @group producer (advanced)
         */
        public NettyHttpProducerBuilder producerPoolMaxIdle(
                int producerPoolMaxIdle) {
            this.properties.put("producerPoolMaxIdle", producerPoolMaxIdle);
            return (NettyHttpProducerBuilder) this;
        }
        /**
         * Sets the cap on the number of idle instances in the pool.
         * The option will be converted to a <code>int</code> type.
         * @group producer (advanced)
         */
        public NettyHttpProducerBuilder producerPoolMaxIdle(
                String producerPoolMaxIdle) {
            this.properties.put("producerPoolMaxIdle", producerPoolMaxIdle);
            return (NettyHttpProducerBuilder) this;
        }
        /**
         * Sets the minimum amount of time (value in millis) an object may sit
         * idle in the pool before it is eligible for eviction by the idle
         * object evictor.
         * The option is a <code>long</code> type.
         * @group producer (advanced)
         */
        public NettyHttpProducerBuilder producerPoolMinEvictableIdle(
                long producerPoolMinEvictableIdle) {
            this.properties.put("producerPoolMinEvictableIdle", producerPoolMinEvictableIdle);
            return (NettyHttpProducerBuilder) this;
        }
        /**
         * Sets the minimum amount of time (value in millis) an object may sit
         * idle in the pool before it is eligible for eviction by the idle
         * object evictor.
         * The option will be converted to a <code>long</code> type.
         * @group producer (advanced)
         */
        public NettyHttpProducerBuilder producerPoolMinEvictableIdle(
                String producerPoolMinEvictableIdle) {
            this.properties.put("producerPoolMinEvictableIdle", producerPoolMinEvictableIdle);
            return (NettyHttpProducerBuilder) this;
        }
        /**
         * Sets the minimum number of instances allowed in the producer pool
         * before the evictor thread (if active) spawns new objects.
         * The option is a <code>int</code> type.
         * @group producer (advanced)
         */
        public NettyHttpProducerBuilder producerPoolMinIdle(
                int producerPoolMinIdle) {
            this.properties.put("producerPoolMinIdle", producerPoolMinIdle);
            return (NettyHttpProducerBuilder) this;
        }
        /**
         * Sets the minimum number of instances allowed in the producer pool
         * before the evictor thread (if active) spawns new objects.
         * The option will be converted to a <code>int</code> type.
         * @group producer (advanced)
         */
        public NettyHttpProducerBuilder producerPoolMinIdle(
                String producerPoolMinIdle) {
            this.properties.put("producerPoolMinIdle", producerPoolMinIdle);
            return (NettyHttpProducerBuilder) this;
        }
        /**
         * Sets whether to use a relative path in HTTP requests.
         * The option is a <code>boolean</code> type.
         * @group producer (advanced)
         */
        public NettyHttpProducerBuilder useRelativePath(boolean useRelativePath) {
            this.properties.put("useRelativePath", useRelativePath);
            return (NettyHttpProducerBuilder) this;
        }
        /**
         * Sets whether to use a relative path in HTTP requests.
         * The option will be converted to a <code>boolean</code> type.
         * @group producer (advanced)
         */
        public NettyHttpProducerBuilder useRelativePath(String useRelativePath) {
            this.properties.put("useRelativePath", useRelativePath);
            return (NettyHttpProducerBuilder) this;
        }
    }
    /**
     * Netty HTTP server and client using the Netty 4.x library. Creates a
     * builder to build a consumer endpoint for the Netty4 HTTP component.
     */
    public default NettyHttpConsumerBuilder fromNettyHttp(String path) {
        return new NettyHttpConsumerBuilder(path);
    }
    /**
     * Netty HTTP server and client using the Netty 4.x library. Creates a
     * builder to build a producer endpoint for the Netty4 HTTP component.
     */
    public default NettyHttpProducerBuilder toNettyHttp(String path) {
        return new NettyHttpProducerBuilder(path);
    }
}