/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.endpoint;

import java.util.Comparator;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import javax.annotation.Generated;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Expression;
import org.apache.camel.LoggingLevel;
import org.apache.camel.Predicate;
import org.apache.camel.spi.ExceptionHandler;
import org.apache.camel.spi.IdempotentRepository;
import org.apache.camel.spi.PollingConsumerPollStrategy;
import org.apache.camel.spi.ScheduledPollConsumerScheduler;

/**
 * The ftp component is used for uploading or downloading files from FTP
 * servers.
 * 
 * Generated by camel-package-maven-plugin - do not edit this file!
 */
@Generated("org.apache.camel.maven.packaging.EndpointDslMojo")
public class FtpEndpoint {


    public static class FtpCommon<T extends EndpointConfiguration>
            extends
                EndpointConfiguration<T> {
        private String host;
        private Integer port;
        private String directoryName;
        private Boolean binary;
        private String charset;
        private Boolean disconnect;
        private String doneFileName;
        private Expression fileName;
        private Boolean passiveMode;
        private Object separator;
        private Integer transferLoggingIntervalSeconds;
        private LoggingLevel transferLoggingLevel;
        private Boolean transferLoggingVerbose;
        private Boolean fastExistsCheck;
        private String activePortRange;
        private Boolean autoCreate;
        private Boolean basicPropertyBinding;
        private Integer bufferSize;
        private Integer connectTimeout;
        private Object ftpClient;
        private Object ftpClientConfig;
        private Map<String, Object> ftpClientConfigParameters;
        private Map<String, Object> ftpClientParameters;
        private Integer maximumReconnectAttempts;
        private Long reconnectDelay;
        private String siteCommand;
        private Integer soTimeout;
        private Boolean stepwise;
        private Boolean synchronous;
        private Boolean throwExceptionOnConnectFailed;
        private Integer timeout;
        private String account;
        private String password;
        private String username;

        /**
         * Hostname of the FTP server. The option is a java.lang.String type.
         */
        public T host(String host) {
            this.host = host;
            return (T) this;
        }

        /**
         * Port of the FTP server. The option is a int type.
         */
        public T port(int port) {
            this.port = port;
            return (T) this;
        }

        /**
         * The starting directory. The option is a java.lang.String type.
         */
        public T directoryName(String directoryName) {
            this.directoryName = directoryName;
            return (T) this;
        }

        /**
         * Specifies the file transfer mode, BINARY or ASCII. Default is ASCII
         * (false). The option is a boolean type.
         */
        public T binary(boolean binary) {
            this.binary = binary;
            return (T) this;
        }

        /**
         * This option is used to specify the encoding of the file. You can use
         * this on the consumer, to specify the encodings of the files, which
         * allow Camel to know the charset it should load the file content in
         * case the file content is being accessed. Likewise when writing a
         * file, you can use this option to specify which charset to write the
         * file as well. Do mind that when writing the file Camel may have to
         * read the message content into memory to be able to convert the data
         * into the configured charset, so do not use this if you have big
         * messages. The option is a java.lang.String type.
         */
        public T charset(String charset) {
            this.charset = charset;
            return (T) this;
        }

        /**
         * Whether or not to disconnect from remote FTP server right after use.
         * Disconnect will only disconnect the current connection to the FTP
         * server. If you have a consumer which you want to stop, then you need
         * to stop the consumer/route instead. The option is a boolean type.
         */
        public T disconnect(boolean disconnect) {
            this.disconnect = disconnect;
            return (T) this;
        }

        /**
         * Producer: If provided, then Camel will write a 2nd done file when the
         * original file has been written. The done file will be empty. This
         * option configures what file name to use. Either you can specify a
         * fixed name. Or you can use dynamic placeholders. The done file will
         * always be written in the same folder as the original file. Consumer:
         * If provided, Camel will only consume files if a done file exists.
         * This option configures what file name to use. Either you can specify
         * a fixed name. Or you can use dynamic placeholders.The done file is
         * always expected in the same folder as the original file. Only
         * ${file.name} and ${file.name.noext} is supported as dynamic
         * placeholders. The option is a java.lang.String type.
         */
        public T doneFileName(String doneFileName) {
            this.doneFileName = doneFileName;
            return (T) this;
        }

        /**
         * Use Expression such as File Language to dynamically set the filename.
         * For consumers, it's used as a filename filter. For producers, it's
         * used to evaluate the filename to write. If an expression is set, it
         * take precedence over the CamelFileName header. (Note: The header
         * itself can also be an Expression). The expression options support
         * both String and Expression types. If the expression is a String type,
         * it is always evaluated using the File Language. If the expression is
         * an Expression type, the specified Expression type is used - this
         * allows you, for instance, to use OGNL expressions. For the consumer,
         * you can use it to filter filenames, so you can for instance consume
         * today's file using the File Language syntax:
         * mydata-${date:now:yyyyMMdd}.txt. The producers support the
         * CamelOverruleFileName header which takes precedence over any existing
         * CamelFileName header; the CamelOverruleFileName is a header that is
         * used only once, and makes it easier as this avoids to temporary store
         * CamelFileName and have to restore it afterwards. The option is a
         * java.lang.String type.
         */
        public T fileName(Expression fileName) {
            this.fileName = fileName;
            return (T) this;
        }

        /**
         * Sets passive mode connections. Default is active mode connections.
         * The option is a boolean type.
         */
        public T passiveMode(boolean passiveMode) {
            this.passiveMode = passiveMode;
            return (T) this;
        }

        /**
         * Sets the path separator to be used. UNIX = Uses unix style path
         * separator Windows = Uses windows style path separator Auto = (is
         * default) Use existing path separator in file name. The option is a
         * org.apache.camel.component.file.remote.RemoteFileConfiguration.PathSeparator type.
         */
        public T separator(Object separator) {
            this.separator = separator;
            return (T) this;
        }

        /**
         * Configures the interval in seconds to use when logging the progress
         * of upload and download operations that are in-flight. This is used
         * for logging progress when operations takes longer time. The option is
         * a int type.
         */
        public T transferLoggingIntervalSeconds(
                int transferLoggingIntervalSeconds) {
            this.transferLoggingIntervalSeconds = transferLoggingIntervalSeconds;
            return (T) this;
        }

        /**
         * Configure the logging level to use when logging the progress of
         * upload and download operations. The option is a
         * org.apache.camel.LoggingLevel type.
         */
        public T transferLoggingLevel(LoggingLevel transferLoggingLevel) {
            this.transferLoggingLevel = transferLoggingLevel;
            return (T) this;
        }

        /**
         * Configures whether the perform verbose (fine grained) logging of the
         * progress of upload and download operations. The option is a boolean
         * type.
         */
        public T transferLoggingVerbose(boolean transferLoggingVerbose) {
            this.transferLoggingVerbose = transferLoggingVerbose;
            return (T) this;
        }

        /**
         * If set this option to be true, camel-ftp will use the list file
         * directly to check if the file exists. Since some FTP server may not
         * support to list the file directly, if the option is false, camel-ftp
         * will use the old way to list the directory and check if the file
         * exists. This option also influences readLock=changed to control
         * whether it performs a fast check to update file information or not.
         * This can be used to speed up the process if the FTP server has a lot
         * of files. The option is a boolean type.
         */
        public T fastExistsCheck(boolean fastExistsCheck) {
            this.fastExistsCheck = fastExistsCheck;
            return (T) this;
        }

        /**
         * Set the client side port range in active mode. The syntax is:
         * minPort-maxPort Both port numbers are inclusive, eg 10000-19999 to
         * include all 1xxxx ports. The option is a java.lang.String type.
         */
        public T activePortRange(String activePortRange) {
            this.activePortRange = activePortRange;
            return (T) this;
        }

        /**
         * Automatically create missing directories in the file's pathname. For
         * the file consumer, that means creating the starting directory. For
         * the file producer, it means the directory the files should be written
         * to. The option is a boolean type.
         */
        public T autoCreate(boolean autoCreate) {
            this.autoCreate = autoCreate;
            return (T) this;
        }

        /**
         * Whether the endpoint should use basic property binding (Camel 2.x) or
         * the newer property binding with additional capabilities. The option
         * is a boolean type.
         */
        public T basicPropertyBinding(boolean basicPropertyBinding) {
            this.basicPropertyBinding = basicPropertyBinding;
            return (T) this;
        }

        /**
         * Write buffer sized in bytes. The option is a int type.
         */
        public T bufferSize(int bufferSize) {
            this.bufferSize = bufferSize;
            return (T) this;
        }

        /**
         * Sets the connect timeout for waiting for a connection to be
         * established Used by both FTPClient and JSCH. The option is a int
         * type.
         */
        public T connectTimeout(int connectTimeout) {
            this.connectTimeout = connectTimeout;
            return (T) this;
        }

        /**
         * To use a custom instance of FTPClient. The option is a
         * org.apache.commons.net.ftp.FTPClient type.
         */
        public T ftpClient(Object ftpClient) {
            this.ftpClient = ftpClient;
            return (T) this;
        }

        /**
         * To use a custom instance of FTPClientConfig to configure the FTP
         * client the endpoint should use. The option is a
         * org.apache.commons.net.ftp.FTPClientConfig type.
         */
        public T ftpClientConfig(Object ftpClientConfig) {
            this.ftpClientConfig = ftpClientConfig;
            return (T) this;
        }

        /**
         * Used by FtpComponent to provide additional parameters for the
         * FTPClientConfig. The option is a
         * java.util.Map<java.lang.String,java.lang.Object> type.
         */
        public T ftpClientConfigParameters(
                Map<String, Object> ftpClientConfigParameters) {
            this.ftpClientConfigParameters = ftpClientConfigParameters;
            return (T) this;
        }

        /**
         * Used by FtpComponent to provide additional parameters for the
         * FTPClient. The option is a
         * java.util.Map<java.lang.String,java.lang.Object> type.
         */
        public T ftpClientParameters(Map<String, Object> ftpClientParameters) {
            this.ftpClientParameters = ftpClientParameters;
            return (T) this;
        }

        /**
         * Specifies the maximum reconnect attempts Camel performs when it tries
         * to connect to the remote FTP server. Use 0 to disable this behavior.
         * The option is a int type.
         */
        public T maximumReconnectAttempts(int maximumReconnectAttempts) {
            this.maximumReconnectAttempts = maximumReconnectAttempts;
            return (T) this;
        }

        /**
         * Delay in millis Camel will wait before performing a reconnect
         * attempt. The option is a long type.
         */
        public T reconnectDelay(long reconnectDelay) {
            this.reconnectDelay = reconnectDelay;
            return (T) this;
        }

        /**
         * Sets optional site command(s) to be executed after successful login.
         * Multiple site commands can be separated using a new line character.
         * The option is a java.lang.String type.
         */
        public T siteCommand(String siteCommand) {
            this.siteCommand = siteCommand;
            return (T) this;
        }

        /**
         * Sets the so timeout FTP and FTPS Only for Camel 2.4. SFTP for Camel
         * 2.14.3/2.15.3/2.16 onwards. Is the SocketOptions.SO_TIMEOUT value in
         * millis. Recommended option is to set this to 300000 so as not have a
         * hanged connection. On SFTP this option is set as timeout on the JSCH
         * Session instance. The option is a int type.
         */
        public T soTimeout(int soTimeout) {
            this.soTimeout = soTimeout;
            return (T) this;
        }

        /**
         * Sets whether we should stepwise change directories while traversing
         * file structures when downloading files, or as well when uploading a
         * file to a directory. You can disable this if you for example are in a
         * situation where you cannot change directory on the FTP server due
         * security reasons. The option is a boolean type.
         */
        public T stepwise(boolean stepwise) {
            this.stepwise = stepwise;
            return (T) this;
        }

        /**
         * Sets whether synchronous processing should be strictly used, or Camel
         * is allowed to use asynchronous processing (if supported). The option
         * is a boolean type.
         */
        public T synchronous(boolean synchronous) {
            this.synchronous = synchronous;
            return (T) this;
        }

        /**
         * Should an exception be thrown if connection failed (exhausted) By
         * default exception is not thrown and a WARN is logged. You can use
         * this to enable exception being thrown and handle the thrown exception
         * from the org.apache.camel.spi.PollingConsumerPollStrategy rollback
         * method. The option is a boolean type.
         */
        public T throwExceptionOnConnectFailed(
                boolean throwExceptionOnConnectFailed) {
            this.throwExceptionOnConnectFailed = throwExceptionOnConnectFailed;
            return (T) this;
        }

        /**
         * Sets the data timeout for waiting for reply Used only by FTPClient.
         * The option is a int type.
         */
        public T timeout(int timeout) {
            this.timeout = timeout;
            return (T) this;
        }

        /**
         * Account to use for login. The option is a java.lang.String type.
         */
        public T account(String account) {
            this.account = account;
            return (T) this;
        }

        /**
         * Password to use for login. The option is a java.lang.String type.
         */
        public T password(String password) {
            this.password = password;
            return (T) this;
        }

        /**
         * Username to use for login. The option is a java.lang.String type.
         */
        public T username(String username) {
            this.username = username;
            return (T) this;
        }

        public String getHost() {
            return host;
        }

        public void setHost(String host) {
            this.host = host;
        }

        public Integer getPort() {
            return port;
        }

        public void setPort(Integer port) {
            this.port = port;
        }

        public String getDirectoryName() {
            return directoryName;
        }

        public void setDirectoryName(String directoryName) {
            this.directoryName = directoryName;
        }

        public Boolean getBinary() {
            return binary;
        }

        public void setBinary(Boolean binary) {
            this.binary = binary;
        }

        public String getCharset() {
            return charset;
        }

        public void setCharset(String charset) {
            this.charset = charset;
        }

        public Boolean getDisconnect() {
            return disconnect;
        }

        public void setDisconnect(Boolean disconnect) {
            this.disconnect = disconnect;
        }

        public String getDoneFileName() {
            return doneFileName;
        }

        public void setDoneFileName(String doneFileName) {
            this.doneFileName = doneFileName;
        }

        public Expression getFileName() {
            return fileName;
        }

        public void setFileName(Expression fileName) {
            this.fileName = fileName;
        }

        public Boolean getPassiveMode() {
            return passiveMode;
        }

        public void setPassiveMode(Boolean passiveMode) {
            this.passiveMode = passiveMode;
        }

        public Object getSeparator() {
            return separator;
        }

        public void setSeparator(Object separator) {
            this.separator = separator;
        }

        public Integer getTransferLoggingIntervalSeconds() {
            return transferLoggingIntervalSeconds;
        }

        public void setTransferLoggingIntervalSeconds(
                Integer transferLoggingIntervalSeconds) {
            this.transferLoggingIntervalSeconds = transferLoggingIntervalSeconds;
        }

        public LoggingLevel getTransferLoggingLevel() {
            return transferLoggingLevel;
        }

        public void setTransferLoggingLevel(LoggingLevel transferLoggingLevel) {
            this.transferLoggingLevel = transferLoggingLevel;
        }

        public Boolean getTransferLoggingVerbose() {
            return transferLoggingVerbose;
        }

        public void setTransferLoggingVerbose(Boolean transferLoggingVerbose) {
            this.transferLoggingVerbose = transferLoggingVerbose;
        }

        public Boolean getFastExistsCheck() {
            return fastExistsCheck;
        }

        public void setFastExistsCheck(Boolean fastExistsCheck) {
            this.fastExistsCheck = fastExistsCheck;
        }

        public String getActivePortRange() {
            return activePortRange;
        }

        public void setActivePortRange(String activePortRange) {
            this.activePortRange = activePortRange;
        }

        public Boolean getAutoCreate() {
            return autoCreate;
        }

        public void setAutoCreate(Boolean autoCreate) {
            this.autoCreate = autoCreate;
        }

        public Boolean getBasicPropertyBinding() {
            return basicPropertyBinding;
        }

        public void setBasicPropertyBinding(Boolean basicPropertyBinding) {
            this.basicPropertyBinding = basicPropertyBinding;
        }

        public Integer getBufferSize() {
            return bufferSize;
        }

        public void setBufferSize(Integer bufferSize) {
            this.bufferSize = bufferSize;
        }

        public Integer getConnectTimeout() {
            return connectTimeout;
        }

        public void setConnectTimeout(Integer connectTimeout) {
            this.connectTimeout = connectTimeout;
        }

        public Object getFtpClient() {
            return ftpClient;
        }

        public void setFtpClient(Object ftpClient) {
            this.ftpClient = ftpClient;
        }

        public Object getFtpClientConfig() {
            return ftpClientConfig;
        }

        public void setFtpClientConfig(Object ftpClientConfig) {
            this.ftpClientConfig = ftpClientConfig;
        }

        public Map<String, Object> getFtpClientConfigParameters() {
            return ftpClientConfigParameters;
        }

        public void setFtpClientConfigParameters(
                Map<String, Object> ftpClientConfigParameters) {
            this.ftpClientConfigParameters = ftpClientConfigParameters;
        }

        public Map<String, Object> getFtpClientParameters() {
            return ftpClientParameters;
        }

        public void setFtpClientParameters(
                Map<String, Object> ftpClientParameters) {
            this.ftpClientParameters = ftpClientParameters;
        }

        public Integer getMaximumReconnectAttempts() {
            return maximumReconnectAttempts;
        }

        public void setMaximumReconnectAttempts(Integer maximumReconnectAttempts) {
            this.maximumReconnectAttempts = maximumReconnectAttempts;
        }

        public Long getReconnectDelay() {
            return reconnectDelay;
        }

        public void setReconnectDelay(Long reconnectDelay) {
            this.reconnectDelay = reconnectDelay;
        }

        public String getSiteCommand() {
            return siteCommand;
        }

        public void setSiteCommand(String siteCommand) {
            this.siteCommand = siteCommand;
        }

        public Integer getSoTimeout() {
            return soTimeout;
        }

        public void setSoTimeout(Integer soTimeout) {
            this.soTimeout = soTimeout;
        }

        public Boolean getStepwise() {
            return stepwise;
        }

        public void setStepwise(Boolean stepwise) {
            this.stepwise = stepwise;
        }

        public Boolean getSynchronous() {
            return synchronous;
        }

        public void setSynchronous(Boolean synchronous) {
            this.synchronous = synchronous;
        }

        public Boolean getThrowExceptionOnConnectFailed() {
            return throwExceptionOnConnectFailed;
        }

        public void setThrowExceptionOnConnectFailed(
                Boolean throwExceptionOnConnectFailed) {
            this.throwExceptionOnConnectFailed = throwExceptionOnConnectFailed;
        }

        public Integer getTimeout() {
            return timeout;
        }

        public void setTimeout(Integer timeout) {
            this.timeout = timeout;
        }

        public String getAccount() {
            return account;
        }

        public void setAccount(String account) {
            this.account = account;
        }

        public String getPassword() {
            return password;
        }

        public void setPassword(String password) {
            this.password = password;
        }

        public String getUsername() {
            return username;
        }

        public void setUsername(String username) {
            this.username = username;
        }
    }

    public static class FtpConsumer extends FtpCommon<FtpConsumer> {
        private Boolean bridgeErrorHandler;
        private Boolean delete;
        private Expression moveFailed;
        private Boolean noop;
        private Expression preMove;
        private Boolean preSort;
        private Boolean recursive;
        private Boolean resumeDownload;
        private Boolean sendEmptyMessageWhenIdle;
        private Boolean streamDownload;
        private Boolean download;
        private ExceptionHandler exceptionHandler;
        private ExchangePattern exchangePattern;
        private Boolean handleDirectoryParserAbsoluteResult;
        private Boolean ignoreFileNotFoundOrPermissionError;
        private IdempotentRepository inProgressRepository;
        private String localWorkDirectory;
        private ExceptionHandler onCompletionExceptionHandler;
        private PollingConsumerPollStrategy pollStrategy;
        private Object processStrategy;
        private Integer receiveBufferSize;
        private Boolean useList;
        private String antExclude;
        private Boolean antFilterCaseSensitive;
        private String antInclude;
        private Boolean eagerMaxMessagesPerPoll;
        private String exclude;
        private Object filter;
        private Predicate filterDirectory;
        private Predicate filterFile;
        private Boolean idempotent;
        private Expression idempotentKey;
        private IdempotentRepository idempotentRepository;
        private String include;
        private Integer maxDepth;
        private Integer maxMessagesPerPoll;
        private Integer minDepth;
        private Expression move;
        private Object exclusiveReadLockStrategy;
        private String readLock;
        private Long readLockCheckInterval;
        private Boolean readLockDeleteOrphanLockFiles;
        private LoggingLevel readLockLoggingLevel;
        private Boolean readLockMarkerFile;
        private Long readLockMinAge;
        private Long readLockMinLength;
        private Boolean readLockRemoveOnCommit;
        private Boolean readLockRemoveOnRollback;
        private Long readLockTimeout;
        private Integer backoffErrorThreshold;
        private Integer backoffIdleThreshold;
        private Integer backoffMultiplier;
        private Long delay;
        private Boolean greedy;
        private Long initialDelay;
        private LoggingLevel runLoggingLevel;
        private ScheduledExecutorService scheduledExecutorService;
        private ScheduledPollConsumerScheduler scheduler;
        private Map<String, Object> schedulerProperties;
        private Boolean startScheduler;
        private TimeUnit timeUnit;
        private Boolean useFixedDelay;
        private Boolean shuffle;
        private Comparator<Exchange> sortBy;
        private Comparator<Object> sorter;

        /**
         * Allows for bridging the consumer to the Camel routing Error Handler,
         * which mean any exceptions occurred while the consumer is trying to
         * pickup incoming messages, or the likes, will now be processed as a
         * message and handled by the routing Error Handler. By default the
         * consumer will use the org.apache.camel.spi.ExceptionHandler to deal
         * with exceptions, that will be logged at WARN or ERROR level and
         * ignored. The option is a boolean type.
         */
        public FtpConsumer bridgeErrorHandler(boolean bridgeErrorHandler) {
            this.bridgeErrorHandler = bridgeErrorHandler;
            return (FtpConsumer) this;
        }

        /**
         * If true, the file will be deleted after it is processed successfully.
         * The option is a boolean type.
         */
        public FtpConsumer delete(boolean delete) {
            this.delete = delete;
            return (FtpConsumer) this;
        }

        /**
         * Sets the move failure expression based on Simple language. For
         * example, to move files into a .error subdirectory use: .error. Note:
         * When moving the files to the fail location Camel will handle the
         * error and will not pick up the file again. The option is a
         * java.lang.String type.
         */
        public FtpConsumer moveFailed(Expression moveFailed) {
            this.moveFailed = moveFailed;
            return (FtpConsumer) this;
        }

        /**
         * If true, the file is not moved or deleted in any way. This option is
         * good for readonly data, or for ETL type requirements. If noop=true,
         * Camel will set idempotent=true as well, to avoid consuming the same
         * files over and over again. The option is a boolean type.
         */
        public FtpConsumer noop(boolean noop) {
            this.noop = noop;
            return (FtpConsumer) this;
        }

        /**
         * Expression (such as File Language) used to dynamically set the
         * filename when moving it before processing. For example to move
         * in-progress files into the order directory set this value to order.
         * The option is a java.lang.String type.
         */
        public FtpConsumer preMove(Expression preMove) {
            this.preMove = preMove;
            return (FtpConsumer) this;
        }

        /**
         * When pre-sort is enabled then the consumer will sort the file and
         * directory names during polling, that was retrieved from the file
         * system. You may want to do this in case you need to operate on the
         * files in a sorted order. The pre-sort is executed before the consumer
         * starts to filter, and accept files to process by Camel. This option
         * is default=false meaning disabled. The option is a boolean type.
         */
        public FtpConsumer preSort(boolean preSort) {
            this.preSort = preSort;
            return (FtpConsumer) this;
        }

        /**
         * If a directory, will look for files in all the sub-directories as
         * well. The option is a boolean type.
         */
        public FtpConsumer recursive(boolean recursive) {
            this.recursive = recursive;
            return (FtpConsumer) this;
        }

        /**
         * Configures whether resume download is enabled. This must be supported
         * by the FTP server (almost all FTP servers support it). In addition
         * the options localWorkDirectory must be configured so downloaded files
         * are stored in a local directory, and the option binary must be
         * enabled, which is required to support resuming of downloads. The
         * option is a boolean type.
         */
        public FtpConsumer resumeDownload(boolean resumeDownload) {
            this.resumeDownload = resumeDownload;
            return (FtpConsumer) this;
        }

        /**
         * If the polling consumer did not poll any files, you can enable this
         * option to send an empty message (no body) instead. The option is a
         * boolean type.
         */
        public FtpConsumer sendEmptyMessageWhenIdle(
                boolean sendEmptyMessageWhenIdle) {
            this.sendEmptyMessageWhenIdle = sendEmptyMessageWhenIdle;
            return (FtpConsumer) this;
        }

        /**
         * Sets the download method to use when not using a local working
         * directory. If set to true, the remote files are streamed to the route
         * as they are read. When set to false, the remote files are loaded into
         * memory before being sent into the route. The option is a boolean
         * type.
         */
        public FtpConsumer streamDownload(boolean streamDownload) {
            this.streamDownload = streamDownload;
            return (FtpConsumer) this;
        }

        /**
         * Whether the FTP consumer should download the file. If this option is
         * set to false, then the message body will be null, but the consumer
         * will still trigger a Camel Exchange that has details about the file
         * such as file name, file size, etc. It's just that the file will not
         * be downloaded. The option is a boolean type.
         */
        public FtpConsumer download(boolean download) {
            this.download = download;
            return (FtpConsumer) this;
        }

        /**
         * To let the consumer use a custom ExceptionHandler. Notice if the
         * option bridgeErrorHandler is enabled then this option is not in use.
         * By default the consumer will deal with exceptions, that will be
         * logged at WARN or ERROR level and ignored. The option is a
         * org.apache.camel.spi.ExceptionHandler type.
         */
        public FtpConsumer exceptionHandler(ExceptionHandler exceptionHandler) {
            this.exceptionHandler = exceptionHandler;
            return (FtpConsumer) this;
        }

        /**
         * Sets the exchange pattern when the consumer creates an exchange. The
         * option is a org.apache.camel.ExchangePattern type.
         */
        public FtpConsumer exchangePattern(ExchangePattern exchangePattern) {
            this.exchangePattern = exchangePattern;
            return (FtpConsumer) this;
        }

        /**
         * Allows you to set how the consumer will handle subfolders and files
         * in the path if the directory parser results in with absolute paths
         * The reason for this is that some FTP servers may return file names
         * with absolute paths, and if so then the FTP component needs to handle
         * this by converting the returned path into a relative path. The option
         * is a boolean type.
         */
        public FtpConsumer handleDirectoryParserAbsoluteResult(
                boolean handleDirectoryParserAbsoluteResult) {
            this.handleDirectoryParserAbsoluteResult = handleDirectoryParserAbsoluteResult;
            return (FtpConsumer) this;
        }

        /**
         * Whether to ignore when (trying to list files in directories or when
         * downloading a file), which does not exist or due to permission error.
         * By default when a directory or file does not exists or insufficient
         * permission, then an exception is thrown. Setting this option to true
         * allows to ignore that instead. The option is a boolean type.
         */
        public FtpConsumer ignoreFileNotFoundOrPermissionError(
                boolean ignoreFileNotFoundOrPermissionError) {
            this.ignoreFileNotFoundOrPermissionError = ignoreFileNotFoundOrPermissionError;
            return (FtpConsumer) this;
        }

        /**
         * A pluggable in-progress repository
         * org.apache.camel.spi.IdempotentRepository. The in-progress repository
         * is used to account the current in progress files being consumed. By
         * default a memory based repository is used. The option is a
         * org.apache.camel.spi.IdempotentRepository type.
         */
        public FtpConsumer inProgressRepository(
                IdempotentRepository inProgressRepository) {
            this.inProgressRepository = inProgressRepository;
            return (FtpConsumer) this;
        }

        /**
         * When consuming, a local work directory can be used to store the
         * remote file content directly in local files, to avoid loading the
         * content into memory. This is beneficial, if you consume a very big
         * remote file and thus can conserve memory. The option is a
         * java.lang.String type.
         */
        public FtpConsumer localWorkDirectory(String localWorkDirectory) {
            this.localWorkDirectory = localWorkDirectory;
            return (FtpConsumer) this;
        }

        /**
         * To use a custom org.apache.camel.spi.ExceptionHandler to handle any
         * thrown exceptions that happens during the file on completion process
         * where the consumer does either a commit or rollback. The default
         * implementation will log any exception at WARN level and ignore. The
         * option is a org.apache.camel.spi.ExceptionHandler type.
         */
        public FtpConsumer onCompletionExceptionHandler(
                ExceptionHandler onCompletionExceptionHandler) {
            this.onCompletionExceptionHandler = onCompletionExceptionHandler;
            return (FtpConsumer) this;
        }

        /**
         * A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing
         * you to provide your custom implementation to control error handling
         * usually occurred during the poll operation before an Exchange have
         * been created and being routed in Camel. The option is a
         * org.apache.camel.spi.PollingConsumerPollStrategy type.
         */
        public FtpConsumer pollStrategy(PollingConsumerPollStrategy pollStrategy) {
            this.pollStrategy = pollStrategy;
            return (FtpConsumer) this;
        }

        /**
         * A pluggable
         * org.apache.camel.component.file.GenericFileProcessStrategy allowing
         * you to implement your own readLock option or similar. Can also be
         * used when special conditions must be met before a file can be
         * consumed, such as a special ready file exists. If this option is set
         * then the readLock option does not apply. The option is a
         * org.apache.camel.component.file.GenericFileProcessStrategy<T> type.
         */
        public FtpConsumer processStrategy(Object processStrategy) {
            this.processStrategy = processStrategy;
            return (FtpConsumer) this;
        }

        /**
         * The receive (download) buffer size Used only by FTPClient. The option
         * is a int type.
         */
        public FtpConsumer receiveBufferSize(int receiveBufferSize) {
            this.receiveBufferSize = receiveBufferSize;
            return (FtpConsumer) this;
        }

        /**
         * Whether to allow using LIST command when downloading a file. Default
         * is true. In some use cases you may want to download a specific file
         * and are not allowed to use the LIST command, and therefore you can
         * set this option to false. Notice when using this option, then the
         * specific file to download does not include meta-data information such
         * as file size, timestamp, permissions etc, because those information
         * is only possible to retrieve when LIST command is in use. The option
         * is a boolean type.
         */
        public FtpConsumer useList(boolean useList) {
            this.useList = useList;
            return (FtpConsumer) this;
        }

        /**
         * Ant style filter exclusion. If both antInclude and antExclude are
         * used, antExclude takes precedence over antInclude. Multiple
         * exclusions may be specified in comma-delimited format. The option is
         * a java.lang.String type.
         */
        public FtpConsumer antExclude(String antExclude) {
            this.antExclude = antExclude;
            return (FtpConsumer) this;
        }

        /**
         * Sets case sensitive flag on ant filter. The option is a boolean type.
         */
        public FtpConsumer antFilterCaseSensitive(boolean antFilterCaseSensitive) {
            this.antFilterCaseSensitive = antFilterCaseSensitive;
            return (FtpConsumer) this;
        }

        /**
         * Ant style filter inclusion. Multiple inclusions may be specified in
         * comma-delimited format. The option is a java.lang.String type.
         */
        public FtpConsumer antInclude(String antInclude) {
            this.antInclude = antInclude;
            return (FtpConsumer) this;
        }

        /**
         * Allows for controlling whether the limit from maxMessagesPerPoll is
         * eager or not. If eager then the limit is during the scanning of
         * files. Where as false would scan all files, and then perform sorting.
         * Setting this option to false allows for sorting all files first, and
         * then limit the poll. Mind that this requires a higher memory usage as
         * all file details are in memory to perform the sorting. The option is
         * a boolean type.
         */
        public FtpConsumer eagerMaxMessagesPerPoll(
                boolean eagerMaxMessagesPerPoll) {
            this.eagerMaxMessagesPerPoll = eagerMaxMessagesPerPoll;
            return (FtpConsumer) this;
        }

        /**
         * Is used to exclude files, if filename matches the regex pattern
         * (matching is case in-senstive). Notice if you use symbols such as
         * plus sign and others you would need to configure this using the RAW()
         * syntax if configuring this as an endpoint uri. See more details at
         * configuring endpoint uris. The option is a java.lang.String type.
         */
        public FtpConsumer exclude(String exclude) {
            this.exclude = exclude;
            return (FtpConsumer) this;
        }

        /**
         * Pluggable filter as a
         * org.apache.camel.component.file.GenericFileFilter class. Will skip
         * files if filter returns false in its accept() method. The option is a
         * org.apache.camel.component.file.GenericFileFilter<T> type.
         */
        public FtpConsumer filter(Object filter) {
            this.filter = filter;
            return (FtpConsumer) this;
        }

        /**
         * Filters the directory based on Simple language. For example to filter
         * on current date, you can use a simple date pattern such as
         * ${date:now:yyyMMdd}. The option is a java.lang.String type.
         */
        public FtpConsumer filterDirectory(Predicate filterDirectory) {
            this.filterDirectory = filterDirectory;
            return (FtpConsumer) this;
        }

        /**
         * Filters the file based on Simple language. For example to filter on
         * file size, you can use ${file:size} 5000. The option is a
         * java.lang.String type.
         */
        public FtpConsumer filterFile(Predicate filterFile) {
            this.filterFile = filterFile;
            return (FtpConsumer) this;
        }

        /**
         * Option to use the Idempotent Consumer EIP pattern to let Camel skip
         * already processed files. Will by default use a memory based LRUCache
         * that holds 1000 entries. If noop=true then idempotent will be enabled
         * as well to avoid consuming the same files over and over again. The
         * option is a java.lang.Boolean type.
         */
        public FtpConsumer idempotent(Boolean idempotent) {
            this.idempotent = idempotent;
            return (FtpConsumer) this;
        }

        /**
         * To use a custom idempotent key. By default the absolute path of the
         * file is used. You can use the File Language, for example to use the
         * file name and file size, you can do:
         * idempotentKey=${file:name}-${file:size}. The option is a
         * java.lang.String type.
         */
        public FtpConsumer idempotentKey(Expression idempotentKey) {
            this.idempotentKey = idempotentKey;
            return (FtpConsumer) this;
        }

        /**
         * A pluggable repository org.apache.camel.spi.IdempotentRepository
         * which by default use MemoryMessageIdRepository if none is specified
         * and idempotent is true. The option is a
         * org.apache.camel.spi.IdempotentRepository type.
         */
        public FtpConsumer idempotentRepository(
                IdempotentRepository idempotentRepository) {
            this.idempotentRepository = idempotentRepository;
            return (FtpConsumer) this;
        }

        /**
         * Is used to include files, if filename matches the regex pattern
         * (matching is case in-sensitive). Notice if you use symbols such as
         * plus sign and others you would need to configure this using the RAW()
         * syntax if configuring this as an endpoint uri. See more details at
         * configuring endpoint uris. The option is a java.lang.String type.
         */
        public FtpConsumer include(String include) {
            this.include = include;
            return (FtpConsumer) this;
        }

        /**
         * The maximum depth to traverse when recursively processing a
         * directory. The option is a int type.
         */
        public FtpConsumer maxDepth(int maxDepth) {
            this.maxDepth = maxDepth;
            return (FtpConsumer) this;
        }

        /**
         * To define a maximum messages to gather per poll. By default no
         * maximum is set. Can be used to set a limit of e.g. 1000 to avoid when
         * starting up the server that there are thousands of files. Set a value
         * of 0 or negative to disabled it. Notice: If this option is in use
         * then the File and FTP components will limit before any sorting. For
         * example if you have 100000 files and use maxMessagesPerPoll=500, then
         * only the first 500 files will be picked up, and then sorted. You can
         * use the eagerMaxMessagesPerPoll option and set this to false to allow
         * to scan all files first and then sort afterwards. The option is a int
         * type.
         */
        public FtpConsumer maxMessagesPerPoll(int maxMessagesPerPoll) {
            this.maxMessagesPerPoll = maxMessagesPerPoll;
            return (FtpConsumer) this;
        }

        /**
         * The minimum depth to start processing when recursively processing a
         * directory. Using minDepth=1 means the base directory. Using
         * minDepth=2 means the first sub directory. The option is a int type.
         */
        public FtpConsumer minDepth(int minDepth) {
            this.minDepth = minDepth;
            return (FtpConsumer) this;
        }

        /**
         * Expression (such as Simple Language) used to dynamically set the
         * filename when moving it after processing. To move files into a .done
         * subdirectory just enter .done. The option is a java.lang.String type.
         */
        public FtpConsumer move(Expression move) {
            this.move = move;
            return (FtpConsumer) this;
        }

        /**
         * Pluggable read-lock as a
         * org.apache.camel.component.file.GenericFileExclusiveReadLockStrategy
         * implementation. The option is a
         * org.apache.camel.component.file.GenericFileExclusiveReadLockStrategy<T> type.
         */
        public FtpConsumer exclusiveReadLockStrategy(
                Object exclusiveReadLockStrategy) {
            this.exclusiveReadLockStrategy = exclusiveReadLockStrategy;
            return (FtpConsumer) this;
        }

        /**
         * Used by consumer, to only poll the files if it has exclusive
         * read-lock on the file (i.e. the file is not in-progress or being
         * written). Camel will wait until the file lock is granted. This option
         * provides the build in strategies: none - No read lock is in use
         * markerFile - Camel creates a marker file (fileName.camelLock) and
         * then holds a lock on it. This option is not available for the FTP
         * component changed - Changed is using file length/modification
         * timestamp to detect whether the file is currently being copied or
         * not. Will at least use 1 sec to determine this, so this option cannot
         * consume files as fast as the others, but can be more reliable as the
         * JDK IO API cannot always determine whether a file is currently being
         * used by another process. The option readLockCheckInterval can be used
         * to set the check frequency. fileLock - is for using
         * java.nio.channels.FileLock. This option is not avail for the FTP
         * component. This approach should be avoided when accessing a remote
         * file system via a mount/share unless that file system supports
         * distributed file locks. rename - rename is for using a try to rename
         * the file as a test if we can get exclusive read-lock. idempotent -
         * (only for file component) idempotent is for using a
         * idempotentRepository as the read-lock. This allows to use read locks
         * that supports clustering if the idempotent repository implementation
         * supports that. idempotent-changed - (only for file component)
         * idempotent-changed is for using a idempotentRepository and changed as
         * the combined read-lock. This allows to use read locks that supports
         * clustering if the idempotent repository implementation supports that.
         * idempotent-rename - (only for file component) idempotent-rename is
         * for using a idempotentRepository and rename as the combined
         * read-lock. This allows to use read locks that supports clustering if
         * the idempotent repository implementation supports that. Notice: The
         * various read locks is not all suited to work in clustered mode, where
         * concurrent consumers on different nodes is competing for the same
         * files on a shared file system. The markerFile using a close to atomic
         * operation to create the empty marker file, but its not guaranteed to
         * work in a cluster. The fileLock may work better but then the file
         * system need to support distributed file locks, and so on. Using the
         * idempotent read lock can support clustering if the idempotent
         * repository supports clustering, such as Hazelcast Component or
         * Infinispan. The option is a java.lang.String type.
         */
        public FtpConsumer readLock(String readLock) {
            this.readLock = readLock;
            return (FtpConsumer) this;
        }

        /**
         * Interval in millis for the read-lock, if supported by the read lock.
         * This interval is used for sleeping between attempts to acquire the
         * read lock. For example when using the changed read lock, you can set
         * a higher interval period to cater for slow writes. The default of 1
         * sec. may be too fast if the producer is very slow writing the file.
         * Notice: For FTP the default readLockCheckInterval is 5000. The
         * readLockTimeout value must be higher than readLockCheckInterval, but
         * a rule of thumb is to have a timeout that is at least 2 or more times
         * higher than the readLockCheckInterval. This is needed to ensure that
         * amble time is allowed for the read lock process to try to grab the
         * lock before the timeout was hit. The option is a long type.
         */
        public FtpConsumer readLockCheckInterval(long readLockCheckInterval) {
            this.readLockCheckInterval = readLockCheckInterval;
            return (FtpConsumer) this;
        }

        /**
         * Whether or not read lock with marker files should upon startup delete
         * any orphan read lock files, which may have been left on the file
         * system, if Camel was not properly shutdown (such as a JVM crash). If
         * turning this option to false then any orphaned lock file will cause
         * Camel to not attempt to pickup that file, this could also be due
         * another node is concurrently reading files from the same shared
         * directory. The option is a boolean type.
         */
        public FtpConsumer readLockDeleteOrphanLockFiles(
                boolean readLockDeleteOrphanLockFiles) {
            this.readLockDeleteOrphanLockFiles = readLockDeleteOrphanLockFiles;
            return (FtpConsumer) this;
        }

        /**
         * Logging level used when a read lock could not be acquired. By default
         * a DEBUG is logged. You can change this level, for example to OFF to
         * not have any logging. This option is only applicable for readLock of
         * types: changed, fileLock, idempotent, idempotent-changed,
         * idempotent-rename, rename. The option is a
         * org.apache.camel.LoggingLevel type.
         */
        public FtpConsumer readLockLoggingLevel(
                LoggingLevel readLockLoggingLevel) {
            this.readLockLoggingLevel = readLockLoggingLevel;
            return (FtpConsumer) this;
        }

        /**
         * Whether to use marker file with the changed, rename, or exclusive
         * read lock types. By default a marker file is used as well to guard
         * against other processes picking up the same files. This behavior can
         * be turned off by setting this option to false. For example if you do
         * not want to write marker files to the file systems by the Camel
         * application. The option is a boolean type.
         */
        public FtpConsumer readLockMarkerFile(boolean readLockMarkerFile) {
            this.readLockMarkerFile = readLockMarkerFile;
            return (FtpConsumer) this;
        }

        /**
         * This option is applied only for readLock=changed. It allows to
         * specify a minimum age the file must be before attempting to acquire
         * the read lock. For example use readLockMinAge=300s to require the
         * file is at last 5 minutes old. This can speedup the changed read lock
         * as it will only attempt to acquire files which are at least that
         * given age. The option is a long type.
         */
        public FtpConsumer readLockMinAge(long readLockMinAge) {
            this.readLockMinAge = readLockMinAge;
            return (FtpConsumer) this;
        }

        /**
         * This option is applied only for readLock=changed. It allows you to
         * configure a minimum file length. By default Camel expects the file to
         * contain data, and thus the default value is 1. You can set this
         * option to zero, to allow consuming zero-length files. The option is a
         * long type.
         */
        public FtpConsumer readLockMinLength(long readLockMinLength) {
            this.readLockMinLength = readLockMinLength;
            return (FtpConsumer) this;
        }

        /**
         * This option is applied only for readLock=idempotent. It allows to
         * specify whether to remove the file name entry from the idempotent
         * repository when processing the file is succeeded and a commit
         * happens. By default the file is not removed which ensures that any
         * race-condition do not occur so another active node may attempt to
         * grab the file. Instead the idempotent repository may support eviction
         * strategies that you can configure to evict the file name entry after
         * X minutes - this ensures no problems with race conditions. See more
         * details at the readLockIdempotentReleaseDelay option. The option is a
         * boolean type.
         */
        public FtpConsumer readLockRemoveOnCommit(boolean readLockRemoveOnCommit) {
            this.readLockRemoveOnCommit = readLockRemoveOnCommit;
            return (FtpConsumer) this;
        }

        /**
         * This option is applied only for readLock=idempotent. It allows to
         * specify whether to remove the file name entry from the idempotent
         * repository when processing the file failed and a rollback happens. If
         * this option is false, then the file name entry is confirmed (as if
         * the file did a commit). The option is a boolean type.
         */
        public FtpConsumer readLockRemoveOnRollback(
                boolean readLockRemoveOnRollback) {
            this.readLockRemoveOnRollback = readLockRemoveOnRollback;
            return (FtpConsumer) this;
        }

        /**
         * Optional timeout in millis for the read-lock, if supported by the
         * read-lock. If the read-lock could not be granted and the timeout
         * triggered, then Camel will skip the file. At next poll Camel, will
         * try the file again, and this time maybe the read-lock could be
         * granted. Use a value of 0 or lower to indicate forever. Currently
         * fileLock, changed and rename support the timeout. Notice: For FTP the
         * default readLockTimeout value is 20000 instead of 10000. The
         * readLockTimeout value must be higher than readLockCheckInterval, but
         * a rule of thumb is to have a timeout that is at least 2 or more times
         * higher than the readLockCheckInterval. This is needed to ensure that
         * amble time is allowed for the read lock process to try to grab the
         * lock before the timeout was hit. The option is a long type.
         */
        public FtpConsumer readLockTimeout(long readLockTimeout) {
            this.readLockTimeout = readLockTimeout;
            return (FtpConsumer) this;
        }

        /**
         * The number of subsequent error polls (failed due some error) that
         * should happen before the backoffMultipler should kick-in. The option
         * is a int type.
         */
        public FtpConsumer backoffErrorThreshold(int backoffErrorThreshold) {
            this.backoffErrorThreshold = backoffErrorThreshold;
            return (FtpConsumer) this;
        }

        /**
         * The number of subsequent idle polls that should happen before the
         * backoffMultipler should kick-in. The option is a int type.
         */
        public FtpConsumer backoffIdleThreshold(int backoffIdleThreshold) {
            this.backoffIdleThreshold = backoffIdleThreshold;
            return (FtpConsumer) this;
        }

        /**
         * To let the scheduled polling consumer backoff if there has been a
         * number of subsequent idles/errors in a row. The multiplier is then
         * the number of polls that will be skipped before the next actual
         * attempt is happening again. When this option is in use then
         * backoffIdleThreshold and/or backoffErrorThreshold must also be
         * configured. The option is a int type.
         */
        public FtpConsumer backoffMultiplier(int backoffMultiplier) {
            this.backoffMultiplier = backoffMultiplier;
            return (FtpConsumer) this;
        }

        /**
         * Milliseconds before the next poll. You can also specify time values
         * using units, such as 60s (60 seconds), 5m30s (5 minutes and 30
         * seconds), and 1h (1 hour). The option is a long type.
         */
        public FtpConsumer delay(long delay) {
            this.delay = delay;
            return (FtpConsumer) this;
        }

        /**
         * If greedy is enabled, then the ScheduledPollConsumer will run
         * immediately again, if the previous run polled 1 or more messages. The
         * option is a boolean type.
         */
        public FtpConsumer greedy(boolean greedy) {
            this.greedy = greedy;
            return (FtpConsumer) this;
        }

        /**
         * Milliseconds before the first poll starts. You can also specify time
         * values using units, such as 60s (60 seconds), 5m30s (5 minutes and 30
         * seconds), and 1h (1 hour). The option is a long type.
         */
        public FtpConsumer initialDelay(long initialDelay) {
            this.initialDelay = initialDelay;
            return (FtpConsumer) this;
        }

        /**
         * The consumer logs a start/complete log line when it polls. This
         * option allows you to configure the logging level for that. The option
         * is a org.apache.camel.LoggingLevel type.
         */
        public FtpConsumer runLoggingLevel(LoggingLevel runLoggingLevel) {
            this.runLoggingLevel = runLoggingLevel;
            return (FtpConsumer) this;
        }

        /**
         * Allows for configuring a custom/shared thread pool to use for the
         * consumer. By default each consumer has its own single threaded thread
         * pool. The option is a java.util.concurrent.ScheduledExecutorService
         * type.
         */
        public FtpConsumer scheduledExecutorService(
                ScheduledExecutorService scheduledExecutorService) {
            this.scheduledExecutorService = scheduledExecutorService;
            return (FtpConsumer) this;
        }

        /**
         * To use a cron scheduler from either camel-spring or camel-quartz2
         * component. The option is a
         * org.apache.camel.spi.ScheduledPollConsumerScheduler type.
         */
        public FtpConsumer scheduler(ScheduledPollConsumerScheduler scheduler) {
            this.scheduler = scheduler;
            return (FtpConsumer) this;
        }

        /**
         * To configure additional properties when using a custom scheduler or
         * any of the Quartz2, Spring based scheduler. The option is a
         * java.util.Map<java.lang.String,java.lang.Object> type.
         */
        public FtpConsumer schedulerProperties(
                Map<String, Object> schedulerProperties) {
            this.schedulerProperties = schedulerProperties;
            return (FtpConsumer) this;
        }

        /**
         * Whether the scheduler should be auto started. The option is a boolean
         * type.
         */
        public FtpConsumer startScheduler(boolean startScheduler) {
            this.startScheduler = startScheduler;
            return (FtpConsumer) this;
        }

        /**
         * Time unit for initialDelay and delay options. The option is a
         * java.util.concurrent.TimeUnit type.
         */
        public FtpConsumer timeUnit(TimeUnit timeUnit) {
            this.timeUnit = timeUnit;
            return (FtpConsumer) this;
        }

        /**
         * Controls if fixed delay or fixed rate is used. See
         * ScheduledExecutorService in JDK for details. The option is a boolean
         * type.
         */
        public FtpConsumer useFixedDelay(boolean useFixedDelay) {
            this.useFixedDelay = useFixedDelay;
            return (FtpConsumer) this;
        }

        /**
         * To shuffle the list of files (sort in random order). The option is a
         * boolean type.
         */
        public FtpConsumer shuffle(boolean shuffle) {
            this.shuffle = shuffle;
            return (FtpConsumer) this;
        }

        /**
         * Built-in sort by using the File Language. Supports nested sorts, so
         * you can have a sort by file name and as a 2nd group sort by modified
         * date. The option is a java.lang.String type.
         */
        public FtpConsumer sortBy(Comparator<Exchange> sortBy) {
            this.sortBy = sortBy;
            return (FtpConsumer) this;
        }

        /**
         * Pluggable sorter as a java.util.Comparator class. The option is a
         * java.util.Comparator<org.apache.camel.component.file.GenericFile<T>>
         * type.
         */
        public FtpConsumer sorter(Comparator<Object> sorter) {
            this.sorter = sorter;
            return (FtpConsumer) this;
        }

        public Boolean getBridgeErrorHandler() {
            return bridgeErrorHandler;
        }

        public void setBridgeErrorHandler(Boolean bridgeErrorHandler) {
            this.bridgeErrorHandler = bridgeErrorHandler;
        }

        public Boolean getDelete() {
            return delete;
        }

        public void setDelete(Boolean delete) {
            this.delete = delete;
        }

        public Expression getMoveFailed() {
            return moveFailed;
        }

        public void setMoveFailed(Expression moveFailed) {
            this.moveFailed = moveFailed;
        }

        public Boolean getNoop() {
            return noop;
        }

        public void setNoop(Boolean noop) {
            this.noop = noop;
        }

        public Expression getPreMove() {
            return preMove;
        }

        public void setPreMove(Expression preMove) {
            this.preMove = preMove;
        }

        public Boolean getPreSort() {
            return preSort;
        }

        public void setPreSort(Boolean preSort) {
            this.preSort = preSort;
        }

        public Boolean getRecursive() {
            return recursive;
        }

        public void setRecursive(Boolean recursive) {
            this.recursive = recursive;
        }

        public Boolean getResumeDownload() {
            return resumeDownload;
        }

        public void setResumeDownload(Boolean resumeDownload) {
            this.resumeDownload = resumeDownload;
        }

        public Boolean getSendEmptyMessageWhenIdle() {
            return sendEmptyMessageWhenIdle;
        }

        public void setSendEmptyMessageWhenIdle(Boolean sendEmptyMessageWhenIdle) {
            this.sendEmptyMessageWhenIdle = sendEmptyMessageWhenIdle;
        }

        public Boolean getStreamDownload() {
            return streamDownload;
        }

        public void setStreamDownload(Boolean streamDownload) {
            this.streamDownload = streamDownload;
        }

        public Boolean getDownload() {
            return download;
        }

        public void setDownload(Boolean download) {
            this.download = download;
        }

        public ExceptionHandler getExceptionHandler() {
            return exceptionHandler;
        }

        public void setExceptionHandler(ExceptionHandler exceptionHandler) {
            this.exceptionHandler = exceptionHandler;
        }

        public ExchangePattern getExchangePattern() {
            return exchangePattern;
        }

        public void setExchangePattern(ExchangePattern exchangePattern) {
            this.exchangePattern = exchangePattern;
        }

        public Boolean getHandleDirectoryParserAbsoluteResult() {
            return handleDirectoryParserAbsoluteResult;
        }

        public void setHandleDirectoryParserAbsoluteResult(
                Boolean handleDirectoryParserAbsoluteResult) {
            this.handleDirectoryParserAbsoluteResult = handleDirectoryParserAbsoluteResult;
        }

        public Boolean getIgnoreFileNotFoundOrPermissionError() {
            return ignoreFileNotFoundOrPermissionError;
        }

        public void setIgnoreFileNotFoundOrPermissionError(
                Boolean ignoreFileNotFoundOrPermissionError) {
            this.ignoreFileNotFoundOrPermissionError = ignoreFileNotFoundOrPermissionError;
        }

        public IdempotentRepository getInProgressRepository() {
            return inProgressRepository;
        }

        public void setInProgressRepository(
                IdempotentRepository inProgressRepository) {
            this.inProgressRepository = inProgressRepository;
        }

        public String getLocalWorkDirectory() {
            return localWorkDirectory;
        }

        public void setLocalWorkDirectory(String localWorkDirectory) {
            this.localWorkDirectory = localWorkDirectory;
        }

        public ExceptionHandler getOnCompletionExceptionHandler() {
            return onCompletionExceptionHandler;
        }

        public void setOnCompletionExceptionHandler(
                ExceptionHandler onCompletionExceptionHandler) {
            this.onCompletionExceptionHandler = onCompletionExceptionHandler;
        }

        public PollingConsumerPollStrategy getPollStrategy() {
            return pollStrategy;
        }

        public void setPollStrategy(PollingConsumerPollStrategy pollStrategy) {
            this.pollStrategy = pollStrategy;
        }

        public Object getProcessStrategy() {
            return processStrategy;
        }

        public void setProcessStrategy(Object processStrategy) {
            this.processStrategy = processStrategy;
        }

        public Integer getReceiveBufferSize() {
            return receiveBufferSize;
        }

        public void setReceiveBufferSize(Integer receiveBufferSize) {
            this.receiveBufferSize = receiveBufferSize;
        }

        public Boolean getUseList() {
            return useList;
        }

        public void setUseList(Boolean useList) {
            this.useList = useList;
        }

        public String getAntExclude() {
            return antExclude;
        }

        public void setAntExclude(String antExclude) {
            this.antExclude = antExclude;
        }

        public Boolean getAntFilterCaseSensitive() {
            return antFilterCaseSensitive;
        }

        public void setAntFilterCaseSensitive(Boolean antFilterCaseSensitive) {
            this.antFilterCaseSensitive = antFilterCaseSensitive;
        }

        public String getAntInclude() {
            return antInclude;
        }

        public void setAntInclude(String antInclude) {
            this.antInclude = antInclude;
        }

        public Boolean getEagerMaxMessagesPerPoll() {
            return eagerMaxMessagesPerPoll;
        }

        public void setEagerMaxMessagesPerPoll(Boolean eagerMaxMessagesPerPoll) {
            this.eagerMaxMessagesPerPoll = eagerMaxMessagesPerPoll;
        }

        public String getExclude() {
            return exclude;
        }

        public void setExclude(String exclude) {
            this.exclude = exclude;
        }

        public Object getFilter() {
            return filter;
        }

        public void setFilter(Object filter) {
            this.filter = filter;
        }

        public Predicate getFilterDirectory() {
            return filterDirectory;
        }

        public void setFilterDirectory(Predicate filterDirectory) {
            this.filterDirectory = filterDirectory;
        }

        public Predicate getFilterFile() {
            return filterFile;
        }

        public void setFilterFile(Predicate filterFile) {
            this.filterFile = filterFile;
        }

        public Boolean getIdempotent() {
            return idempotent;
        }

        public void setIdempotent(Boolean idempotent) {
            this.idempotent = idempotent;
        }

        public Expression getIdempotentKey() {
            return idempotentKey;
        }

        public void setIdempotentKey(Expression idempotentKey) {
            this.idempotentKey = idempotentKey;
        }

        public IdempotentRepository getIdempotentRepository() {
            return idempotentRepository;
        }

        public void setIdempotentRepository(
                IdempotentRepository idempotentRepository) {
            this.idempotentRepository = idempotentRepository;
        }

        public String getInclude() {
            return include;
        }

        public void setInclude(String include) {
            this.include = include;
        }

        public Integer getMaxDepth() {
            return maxDepth;
        }

        public void setMaxDepth(Integer maxDepth) {
            this.maxDepth = maxDepth;
        }

        public Integer getMaxMessagesPerPoll() {
            return maxMessagesPerPoll;
        }

        public void setMaxMessagesPerPoll(Integer maxMessagesPerPoll) {
            this.maxMessagesPerPoll = maxMessagesPerPoll;
        }

        public Integer getMinDepth() {
            return minDepth;
        }

        public void setMinDepth(Integer minDepth) {
            this.minDepth = minDepth;
        }

        public Expression getMove() {
            return move;
        }

        public void setMove(Expression move) {
            this.move = move;
        }

        public Object getExclusiveReadLockStrategy() {
            return exclusiveReadLockStrategy;
        }

        public void setExclusiveReadLockStrategy(
                Object exclusiveReadLockStrategy) {
            this.exclusiveReadLockStrategy = exclusiveReadLockStrategy;
        }

        public String getReadLock() {
            return readLock;
        }

        public void setReadLock(String readLock) {
            this.readLock = readLock;
        }

        public Long getReadLockCheckInterval() {
            return readLockCheckInterval;
        }

        public void setReadLockCheckInterval(Long readLockCheckInterval) {
            this.readLockCheckInterval = readLockCheckInterval;
        }

        public Boolean getReadLockDeleteOrphanLockFiles() {
            return readLockDeleteOrphanLockFiles;
        }

        public void setReadLockDeleteOrphanLockFiles(
                Boolean readLockDeleteOrphanLockFiles) {
            this.readLockDeleteOrphanLockFiles = readLockDeleteOrphanLockFiles;
        }

        public LoggingLevel getReadLockLoggingLevel() {
            return readLockLoggingLevel;
        }

        public void setReadLockLoggingLevel(LoggingLevel readLockLoggingLevel) {
            this.readLockLoggingLevel = readLockLoggingLevel;
        }

        public Boolean getReadLockMarkerFile() {
            return readLockMarkerFile;
        }

        public void setReadLockMarkerFile(Boolean readLockMarkerFile) {
            this.readLockMarkerFile = readLockMarkerFile;
        }

        public Long getReadLockMinAge() {
            return readLockMinAge;
        }

        public void setReadLockMinAge(Long readLockMinAge) {
            this.readLockMinAge = readLockMinAge;
        }

        public Long getReadLockMinLength() {
            return readLockMinLength;
        }

        public void setReadLockMinLength(Long readLockMinLength) {
            this.readLockMinLength = readLockMinLength;
        }

        public Boolean getReadLockRemoveOnCommit() {
            return readLockRemoveOnCommit;
        }

        public void setReadLockRemoveOnCommit(Boolean readLockRemoveOnCommit) {
            this.readLockRemoveOnCommit = readLockRemoveOnCommit;
        }

        public Boolean getReadLockRemoveOnRollback() {
            return readLockRemoveOnRollback;
        }

        public void setReadLockRemoveOnRollback(Boolean readLockRemoveOnRollback) {
            this.readLockRemoveOnRollback = readLockRemoveOnRollback;
        }

        public Long getReadLockTimeout() {
            return readLockTimeout;
        }

        public void setReadLockTimeout(Long readLockTimeout) {
            this.readLockTimeout = readLockTimeout;
        }

        public Integer getBackoffErrorThreshold() {
            return backoffErrorThreshold;
        }

        public void setBackoffErrorThreshold(Integer backoffErrorThreshold) {
            this.backoffErrorThreshold = backoffErrorThreshold;
        }

        public Integer getBackoffIdleThreshold() {
            return backoffIdleThreshold;
        }

        public void setBackoffIdleThreshold(Integer backoffIdleThreshold) {
            this.backoffIdleThreshold = backoffIdleThreshold;
        }

        public Integer getBackoffMultiplier() {
            return backoffMultiplier;
        }

        public void setBackoffMultiplier(Integer backoffMultiplier) {
            this.backoffMultiplier = backoffMultiplier;
        }

        public Long getDelay() {
            return delay;
        }

        public void setDelay(Long delay) {
            this.delay = delay;
        }

        public Boolean getGreedy() {
            return greedy;
        }

        public void setGreedy(Boolean greedy) {
            this.greedy = greedy;
        }

        public Long getInitialDelay() {
            return initialDelay;
        }

        public void setInitialDelay(Long initialDelay) {
            this.initialDelay = initialDelay;
        }

        public LoggingLevel getRunLoggingLevel() {
            return runLoggingLevel;
        }

        public void setRunLoggingLevel(LoggingLevel runLoggingLevel) {
            this.runLoggingLevel = runLoggingLevel;
        }

        public ScheduledExecutorService getScheduledExecutorService() {
            return scheduledExecutorService;
        }

        public void setScheduledExecutorService(
                ScheduledExecutorService scheduledExecutorService) {
            this.scheduledExecutorService = scheduledExecutorService;
        }

        public ScheduledPollConsumerScheduler getScheduler() {
            return scheduler;
        }

        public void setScheduler(ScheduledPollConsumerScheduler scheduler) {
            this.scheduler = scheduler;
        }

        public Map<String, Object> getSchedulerProperties() {
            return schedulerProperties;
        }

        public void setSchedulerProperties(
                Map<String, Object> schedulerProperties) {
            this.schedulerProperties = schedulerProperties;
        }

        public Boolean getStartScheduler() {
            return startScheduler;
        }

        public void setStartScheduler(Boolean startScheduler) {
            this.startScheduler = startScheduler;
        }

        public TimeUnit getTimeUnit() {
            return timeUnit;
        }

        public void setTimeUnit(TimeUnit timeUnit) {
            this.timeUnit = timeUnit;
        }

        public Boolean getUseFixedDelay() {
            return useFixedDelay;
        }

        public void setUseFixedDelay(Boolean useFixedDelay) {
            this.useFixedDelay = useFixedDelay;
        }

        public Boolean getShuffle() {
            return shuffle;
        }

        public void setShuffle(Boolean shuffle) {
            this.shuffle = shuffle;
        }

        public Comparator<Exchange> getSortBy() {
            return sortBy;
        }

        public void setSortBy(Comparator<Exchange> sortBy) {
            this.sortBy = sortBy;
        }

        public Comparator<Object> getSorter() {
            return sorter;
        }

        public void setSorter(Comparator<Object> sorter) {
            this.sorter = sorter;
        }
    }

    public static class FtpProducer extends FtpCommon<FtpProducer> {
        private GenericFileExist fileExist;
        private Boolean flatten;
        private Boolean jailStartingDirectory;
        private Expression moveExisting;
        private Expression tempFileName;
        private String tempPrefix;
        private Boolean allowNullBody;
        private String chmod;
        private Boolean disconnectOnBatchComplete;
        private Boolean eagerDeleteTargetFile;
        private Boolean keepLastModified;
        private Object moveExistingFileStrategy;
        private Boolean sendNoop;

        /**
         * What to do if a file already exists with the same name. Override,
         * which is the default, replaces the existing file. Append - adds
         * content to the existing file. Fail - throws a
         * GenericFileOperationException, indicating that there is already an
         * existing file. Ignore - silently ignores the problem and does not
         * override the existing file, but assumes everything is okay. Move -
         * option requires to use the moveExisting option to be configured as
         * well. The option eagerDeleteTargetFile can be used to control what to
         * do if an moving the file, and there exists already an existing file,
         * otherwise causing the move operation to fail. The Move option will
         * move any existing files, before writing the target file. TryRename is
         * only applicable if tempFileName option is in use. This allows to try
         * renaming the file from the temporary name to the actual name, without
         * doing any exists check. This check may be faster on some file systems
         * and especially FTP servers. The option is a
         * org.apache.camel.component.file.GenericFileExist type.
         */
        public FtpProducer fileExist(GenericFileExist fileExist) {
            this.fileExist = fileExist;
            return (FtpProducer) this;
        }

        /**
         * Flatten is used to flatten the file name path to strip any leading
         * paths, so it's just the file name. This allows you to consume
         * recursively into sub-directories, but when you eg write the files to
         * another directory they will be written in a single directory. Setting
         * this to true on the producer enforces that any file name in
         * CamelFileName header will be stripped for any leading paths. The
         * option is a boolean type.
         */
        public FtpProducer flatten(boolean flatten) {
            this.flatten = flatten;
            return (FtpProducer) this;
        }

        /**
         * Used for jailing (restricting) writing files to the starting
         * directory (and sub) only. This is enabled by default to not allow
         * Camel to write files to outside directories (to be more secured out
         * of the box). You can turn this off to allow writing files to
         * directories outside the starting directory, such as parent or root
         * folders. The option is a boolean type.
         */
        public FtpProducer jailStartingDirectory(boolean jailStartingDirectory) {
            this.jailStartingDirectory = jailStartingDirectory;
            return (FtpProducer) this;
        }

        /**
         * Expression (such as File Language) used to compute file name to use
         * when fileExist=Move is configured. To move files into a backup
         * subdirectory just enter backup. This option only supports the
         * following File Language tokens: file:name, file:name.ext,
         * file:name.noext, file:onlyname, file:onlyname.noext, file:ext, and
         * file:parent. Notice the file:parent is not supported by the FTP
         * component, as the FTP component can only move any existing files to a
         * relative directory based on current dir as base. The option is a
         * java.lang.String type.
         */
        public FtpProducer moveExisting(Expression moveExisting) {
            this.moveExisting = moveExisting;
            return (FtpProducer) this;
        }

        /**
         * The same as tempPrefix option but offering a more fine grained
         * control on the naming of the temporary filename as it uses the File
         * Language. The location for tempFilename is relative to the final file
         * location in the option 'fileName', not the target directory in the
         * base uri. For example if option fileName includes a directory prefix:
         * dir/finalFilename then tempFileName is relative to that subdirectory
         * dir. The option is a java.lang.String type.
         */
        public FtpProducer tempFileName(Expression tempFileName) {
            this.tempFileName = tempFileName;
            return (FtpProducer) this;
        }

        /**
         * This option is used to write the file using a temporary name and
         * then, after the write is complete, rename it to the real name. Can be
         * used to identify files being written and also avoid consumers (not
         * using exclusive read locks) reading in progress files. Is often used
         * by FTP when uploading big files. The option is a java.lang.String
         * type.
         */
        public FtpProducer tempPrefix(String tempPrefix) {
            this.tempPrefix = tempPrefix;
            return (FtpProducer) this;
        }

        /**
         * Used to specify if a null body is allowed during file writing. If set
         * to true then an empty file will be created, when set to false, and
         * attempting to send a null body to the file component, a
         * GenericFileWriteException of 'Cannot write null body to file.' will
         * be thrown. If the fileExist option is set to 'Override', then the
         * file will be truncated, and if set to append the file will remain
         * unchanged. The option is a boolean type.
         */
        public FtpProducer allowNullBody(boolean allowNullBody) {
            this.allowNullBody = allowNullBody;
            return (FtpProducer) this;
        }

        /**
         * Allows you to set chmod on the stored file. For example chmod=640.
         * The option is a java.lang.String type.
         */
        public FtpProducer chmod(String chmod) {
            this.chmod = chmod;
            return (FtpProducer) this;
        }

        /**
         * Whether or not to disconnect from remote FTP server right after a
         * Batch upload is complete. disconnectOnBatchComplete will only
         * disconnect the current connection to the FTP server. The option is a
         * boolean type.
         */
        public FtpProducer disconnectOnBatchComplete(
                boolean disconnectOnBatchComplete) {
            this.disconnectOnBatchComplete = disconnectOnBatchComplete;
            return (FtpProducer) this;
        }

        /**
         * Whether or not to eagerly delete any existing target file. This
         * option only applies when you use fileExists=Override and the
         * tempFileName option as well. You can use this to disable (set it to
         * false) deleting the target file before the temp file is written. For
         * example you may write big files and want the target file to exists
         * during the temp file is being written. This ensure the target file is
         * only deleted until the very last moment, just before the temp file is
         * being renamed to the target filename. This option is also used to
         * control whether to delete any existing files when fileExist=Move is
         * enabled, and an existing file exists. If this option
         * copyAndDeleteOnRenameFails false, then an exception will be thrown if
         * an existing file existed, if its true, then the existing file is
         * deleted before the move operation. The option is a boolean type.
         */
        public FtpProducer eagerDeleteTargetFile(boolean eagerDeleteTargetFile) {
            this.eagerDeleteTargetFile = eagerDeleteTargetFile;
            return (FtpProducer) this;
        }

        /**
         * Will keep the last modified timestamp from the source file (if any).
         * Will use the Exchange.FILE_LAST_MODIFIED header to located the
         * timestamp. This header can contain either a java.util.Date or long
         * with the timestamp. If the timestamp exists and the option is enabled
         * it will set this timestamp on the written file. Note: This option
         * only applies to the file producer. You cannot use this option with
         * any of the ftp producers. The option is a boolean type.
         */
        public FtpProducer keepLastModified(boolean keepLastModified) {
            this.keepLastModified = keepLastModified;
            return (FtpProducer) this;
        }

        /**
         * Strategy (Custom Strategy) used to move file with special naming
         * token to use when fileExist=Move is configured. By default, there is
         * an implementation used if no custom strategy is provided. The option
         * is a
         * org.apache.camel.component.file.strategy.FileMoveExistingStrategy
         * type.
         */
        public FtpProducer moveExistingFileStrategy(
                Object moveExistingFileStrategy) {
            this.moveExistingFileStrategy = moveExistingFileStrategy;
            return (FtpProducer) this;
        }

        /**
         * Whether to send a noop command as a pre-write check before uploading
         * files to the FTP server. This is enabled by default as a validation
         * of the connection is still valid, which allows to silently re-connect
         * to be able to upload the file. However if this causes problems, you
         * can turn this option off. The option is a boolean type.
         */
        public FtpProducer sendNoop(boolean sendNoop) {
            this.sendNoop = sendNoop;
            return (FtpProducer) this;
        }

        public GenericFileExist getFileExist() {
            return fileExist;
        }

        public void setFileExist(GenericFileExist fileExist) {
            this.fileExist = fileExist;
        }

        public Boolean getFlatten() {
            return flatten;
        }

        public void setFlatten(Boolean flatten) {
            this.flatten = flatten;
        }

        public Boolean getJailStartingDirectory() {
            return jailStartingDirectory;
        }

        public void setJailStartingDirectory(Boolean jailStartingDirectory) {
            this.jailStartingDirectory = jailStartingDirectory;
        }

        public Expression getMoveExisting() {
            return moveExisting;
        }

        public void setMoveExisting(Expression moveExisting) {
            this.moveExisting = moveExisting;
        }

        public Expression getTempFileName() {
            return tempFileName;
        }

        public void setTempFileName(Expression tempFileName) {
            this.tempFileName = tempFileName;
        }

        public String getTempPrefix() {
            return tempPrefix;
        }

        public void setTempPrefix(String tempPrefix) {
            this.tempPrefix = tempPrefix;
        }

        public Boolean getAllowNullBody() {
            return allowNullBody;
        }

        public void setAllowNullBody(Boolean allowNullBody) {
            this.allowNullBody = allowNullBody;
        }

        public String getChmod() {
            return chmod;
        }

        public void setChmod(String chmod) {
            this.chmod = chmod;
        }

        public Boolean getDisconnectOnBatchComplete() {
            return disconnectOnBatchComplete;
        }

        public void setDisconnectOnBatchComplete(
                Boolean disconnectOnBatchComplete) {
            this.disconnectOnBatchComplete = disconnectOnBatchComplete;
        }

        public Boolean getEagerDeleteTargetFile() {
            return eagerDeleteTargetFile;
        }

        public void setEagerDeleteTargetFile(Boolean eagerDeleteTargetFile) {
            this.eagerDeleteTargetFile = eagerDeleteTargetFile;
        }

        public Boolean getKeepLastModified() {
            return keepLastModified;
        }

        public void setKeepLastModified(Boolean keepLastModified) {
            this.keepLastModified = keepLastModified;
        }

        public Object getMoveExistingFileStrategy() {
            return moveExistingFileStrategy;
        }

        public void setMoveExistingFileStrategy(Object moveExistingFileStrategy) {
            this.moveExistingFileStrategy = moveExistingFileStrategy;
        }

        public Boolean getSendNoop() {
            return sendNoop;
        }

        public void setSendNoop(Boolean sendNoop) {
            this.sendNoop = sendNoop;
        }
    }

    public static enum GenericFileExist {
        Override, Append, Fail, Ignore, Move, TryRename;
    }
}