/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.endpoint;

import java.util.concurrent.ScheduledExecutorService;
import javax.annotation.Generated;
import org.apache.camel.AggregationStrategy;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Predicate;
import org.apache.camel.spi.ExceptionHandler;
import org.apache.camel.spi.HeaderFilterStrategy;

/**
 * The sjms-batch component is a specialized for highly performant,
 * transactional batch consumption from a JMS queue.
 * 
 * Generated by camel-package-maven-plugin - do not edit this file!
 */
@Generated("org.apache.camel.maven.packaging.EndpointDslMojo")
public class SjmsBatchEndpoint {


    public static class SjmsBatchCommon<T extends EndpointConfiguration>
            extends
                EndpointConfiguration<T> {
        private String destinationName;
        private AggregationStrategy aggregationStrategy;
        private Boolean allowNullBody;
        private Integer completionInterval;
        private Predicate completionPredicate;
        private Integer completionSize;
        private Integer completionTimeout;
        private Integer consumerCount;
        private Boolean eagerCheckCompletion;
        private Boolean includeAllJMSXProperties;
        private Boolean mapJmsMessage;
        private Integer pollDuration;
        private Boolean sendEmptyMessageWhenIdle;
        private Boolean asyncStartListener;
        private Boolean basicPropertyBinding;
        private HeaderFilterStrategy headerFilterStrategy;
        private Object jmsKeyFormatStrategy;
        private Integer keepAliveDelay;
        private Object messageCreatedStrategy;
        private Integer recoveryInterval;
        private Boolean synchronous;
        private ScheduledExecutorService timeoutCheckerExecutorService;

        /**
         * The destination name. Only queues are supported, names may be
         * prefixed by 'queue:'. The option is a java.lang.String type.
         */
        public T destinationName(String destinationName) {
            this.destinationName = destinationName;
            return (T) this;
        }

        /**
         * The aggregation strategy to use, which merges all the batched
         * messages into a single message. The option is a
         * org.apache.camel.AggregationStrategy type.
         */
        public T aggregationStrategy(AggregationStrategy aggregationStrategy) {
            this.aggregationStrategy = aggregationStrategy;
            return (T) this;
        }

        /**
         * Whether to allow sending messages with no body. If this option is
         * false and the message body is null, then an JMSException is thrown.
         * The option is a boolean type.
         */
        public T allowNullBody(boolean allowNullBody) {
            this.allowNullBody = allowNullBody;
            return (T) this;
        }

        /**
         * The completion interval in millis, which causes batches to be
         * completed in a scheduled fixed rate every interval. The batch may be
         * empty if the timeout triggered and there was no messages in the
         * batch. Notice you cannot use both completion timeout and completion
         * interval at the same time, only one can be configured. The option is
         * a int type.
         */
        public T completionInterval(int completionInterval) {
            this.completionInterval = completionInterval;
            return (T) this;
        }

        /**
         * The completion predicate, which causes batches to be completed when
         * the predicate evaluates as true. The predicate can also be configured
         * using the simple language using the string syntax. You may want to
         * set the option eagerCheckCompletion to true to let the predicate
         * match the incoming message, as otherwise it matches the aggregated
         * message. The option is a java.lang.String type.
         */
        public T completionPredicate(Predicate completionPredicate) {
            this.completionPredicate = completionPredicate;
            return (T) this;
        }

        /**
         * The number of messages consumed at which the batch will be completed.
         * The option is a int type.
         */
        public T completionSize(int completionSize) {
            this.completionSize = completionSize;
            return (T) this;
        }

        /**
         * The timeout in millis from receipt of the first first message when
         * the batch will be completed. The batch may be empty if the timeout
         * triggered and there was no messages in the batch. Notice you cannot
         * use both completion timeout and completion interval at the same time,
         * only one can be configured. The option is a int type.
         */
        public T completionTimeout(int completionTimeout) {
            this.completionTimeout = completionTimeout;
            return (T) this;
        }

        /**
         * The number of JMS sessions to consume from. The option is a int type.
         */
        public T consumerCount(int consumerCount) {
            this.consumerCount = consumerCount;
            return (T) this;
        }

        /**
         * Use eager completion checking which means that the
         * completionPredicate will use the incoming Exchange. As opposed to
         * without eager completion checking the completionPredicate will use
         * the aggregated Exchange. The option is a boolean type.
         */
        public T eagerCheckCompletion(boolean eagerCheckCompletion) {
            this.eagerCheckCompletion = eagerCheckCompletion;
            return (T) this;
        }

        /**
         * Whether to include all JMSXxxx properties when mapping from JMS to
         * Camel Message. Setting this to true will include properties such as
         * JMSXAppID, and JMSXUserID etc. Note: If you are using a custom
         * headerFilterStrategy then this option does not apply. The option is a
         * boolean type.
         */
        public T includeAllJMSXProperties(boolean includeAllJMSXProperties) {
            this.includeAllJMSXProperties = includeAllJMSXProperties;
            return (T) this;
        }

        /**
         * Specifies whether Camel should auto map the received JMS message to a
         * suited payload type, such as javax.jms.TextMessage to a String etc.
         * See section about how mapping works below for more details. The
         * option is a boolean type.
         */
        public T mapJmsMessage(boolean mapJmsMessage) {
            this.mapJmsMessage = mapJmsMessage;
            return (T) this;
        }

        /**
         * The duration in milliseconds of each poll for messages.
         * completionTimeOut will be used if it is shorter and a batch has
         * started. The option is a int type.
         */
        public T pollDuration(int pollDuration) {
            this.pollDuration = pollDuration;
            return (T) this;
        }

        /**
         * If using completion timeout or interval, then the batch may be empty
         * if the timeout triggered and there was no messages in the batch. If
         * this option is true and the batch is empty then an empty message is
         * added to the batch so an empty message is routed. The option is a
         * boolean type.
         */
        public T sendEmptyMessageWhenIdle(boolean sendEmptyMessageWhenIdle) {
            this.sendEmptyMessageWhenIdle = sendEmptyMessageWhenIdle;
            return (T) this;
        }

        /**
         * Whether to startup the consumer message listener asynchronously, when
         * starting a route. For example if a JmsConsumer cannot get a
         * connection to a remote JMS broker, then it may block while retrying
         * and/or failover. This will cause Camel to block while starting
         * routes. By setting this option to true, you will let routes startup,
         * while the JmsConsumer connects to the JMS broker using a dedicated
         * thread in asynchronous mode. If this option is used, then beware that
         * if the connection could not be established, then an exception is
         * logged at WARN level, and the consumer will not be able to receive
         * messages; You can then restart the route to retry. The option is a
         * boolean type.
         */
        public T asyncStartListener(boolean asyncStartListener) {
            this.asyncStartListener = asyncStartListener;
            return (T) this;
        }

        /**
         * Whether the endpoint should use basic property binding (Camel 2.x) or
         * the newer property binding with additional capabilities. The option
         * is a boolean type.
         */
        public T basicPropertyBinding(boolean basicPropertyBinding) {
            this.basicPropertyBinding = basicPropertyBinding;
            return (T) this;
        }

        /**
         * To use a custom HeaderFilterStrategy to filter header to and from
         * Camel message. The option is a
         * org.apache.camel.spi.HeaderFilterStrategy type.
         */
        public T headerFilterStrategy(HeaderFilterStrategy headerFilterStrategy) {
            this.headerFilterStrategy = headerFilterStrategy;
            return (T) this;
        }

        /**
         * Pluggable strategy for encoding and decoding JMS keys so they can be
         * compliant with the JMS specification. Camel provides two
         * implementations out of the box: default and passthrough. The default
         * strategy will safely marshal dots and hyphens (. and -). The
         * passthrough strategy leaves the key as is. Can be used for JMS
         * brokers which do not care whether JMS header keys contain illegal
         * characters. You can provide your own implementation of the
         * org.apache.camel.component.jms.JmsKeyFormatStrategy and refer to it
         * using the # notation. The option is a
         * org.apache.camel.component.sjms.jms.JmsKeyFormatStrategy type.
         */
        public T jmsKeyFormatStrategy(Object jmsKeyFormatStrategy) {
            this.jmsKeyFormatStrategy = jmsKeyFormatStrategy;
            return (T) this;
        }

        /**
         * The delay in millis between attempts to re-establish a valid session.
         * If this is a positive value the SjmsBatchConsumer will attempt to
         * create a new session if it sees an IllegalStateException during
         * message consumption. This delay value allows you to pause between
         * attempts to prevent spamming the logs. If this is a negative value
         * (default is -1) then the SjmsBatchConsumer will behave as it always
         * has before - that is it will bail out and the route will shut down if
         * it sees an IllegalStateException. The option is a int type.
         */
        public T keepAliveDelay(int keepAliveDelay) {
            this.keepAliveDelay = keepAliveDelay;
            return (T) this;
        }

        /**
         * To use the given MessageCreatedStrategy which are invoked when Camel
         * creates new instances of javax.jms.Message objects when Camel is
         * sending a JMS message. The option is a
         * org.apache.camel.component.sjms.jms.MessageCreatedStrategy type.
         */
        public T messageCreatedStrategy(Object messageCreatedStrategy) {
            this.messageCreatedStrategy = messageCreatedStrategy;
            return (T) this;
        }

        /**
         * Specifies the interval between recovery attempts, i.e. when a
         * connection is being refreshed, in milliseconds. The default is 5000
         * ms, that is, 5 seconds. The option is a int type.
         */
        public T recoveryInterval(int recoveryInterval) {
            this.recoveryInterval = recoveryInterval;
            return (T) this;
        }

        /**
         * Sets whether synchronous processing should be strictly used, or Camel
         * is allowed to use asynchronous processing (if supported). The option
         * is a boolean type.
         */
        public T synchronous(boolean synchronous) {
            this.synchronous = synchronous;
            return (T) this;
        }

        /**
         * If using the completionInterval option a background thread is created
         * to trigger the completion interval. Set this option to provide a
         * custom thread pool to be used rather than creating a new thread for
         * every consumer. The option is a
         * java.util.concurrent.ScheduledExecutorService type.
         */
        public T timeoutCheckerExecutorService(
                ScheduledExecutorService timeoutCheckerExecutorService) {
            this.timeoutCheckerExecutorService = timeoutCheckerExecutorService;
            return (T) this;
        }

        public String getDestinationName() {
            return destinationName;
        }

        public void setDestinationName(String destinationName) {
            this.destinationName = destinationName;
        }

        public AggregationStrategy getAggregationStrategy() {
            return aggregationStrategy;
        }

        public void setAggregationStrategy(
                AggregationStrategy aggregationStrategy) {
            this.aggregationStrategy = aggregationStrategy;
        }

        public Boolean getAllowNullBody() {
            return allowNullBody;
        }

        public void setAllowNullBody(Boolean allowNullBody) {
            this.allowNullBody = allowNullBody;
        }

        public Integer getCompletionInterval() {
            return completionInterval;
        }

        public void setCompletionInterval(Integer completionInterval) {
            this.completionInterval = completionInterval;
        }

        public Predicate getCompletionPredicate() {
            return completionPredicate;
        }

        public void setCompletionPredicate(Predicate completionPredicate) {
            this.completionPredicate = completionPredicate;
        }

        public Integer getCompletionSize() {
            return completionSize;
        }

        public void setCompletionSize(Integer completionSize) {
            this.completionSize = completionSize;
        }

        public Integer getCompletionTimeout() {
            return completionTimeout;
        }

        public void setCompletionTimeout(Integer completionTimeout) {
            this.completionTimeout = completionTimeout;
        }

        public Integer getConsumerCount() {
            return consumerCount;
        }

        public void setConsumerCount(Integer consumerCount) {
            this.consumerCount = consumerCount;
        }

        public Boolean getEagerCheckCompletion() {
            return eagerCheckCompletion;
        }

        public void setEagerCheckCompletion(Boolean eagerCheckCompletion) {
            this.eagerCheckCompletion = eagerCheckCompletion;
        }

        public Boolean getIncludeAllJMSXProperties() {
            return includeAllJMSXProperties;
        }

        public void setIncludeAllJMSXProperties(Boolean includeAllJMSXProperties) {
            this.includeAllJMSXProperties = includeAllJMSXProperties;
        }

        public Boolean getMapJmsMessage() {
            return mapJmsMessage;
        }

        public void setMapJmsMessage(Boolean mapJmsMessage) {
            this.mapJmsMessage = mapJmsMessage;
        }

        public Integer getPollDuration() {
            return pollDuration;
        }

        public void setPollDuration(Integer pollDuration) {
            this.pollDuration = pollDuration;
        }

        public Boolean getSendEmptyMessageWhenIdle() {
            return sendEmptyMessageWhenIdle;
        }

        public void setSendEmptyMessageWhenIdle(Boolean sendEmptyMessageWhenIdle) {
            this.sendEmptyMessageWhenIdle = sendEmptyMessageWhenIdle;
        }

        public Boolean getAsyncStartListener() {
            return asyncStartListener;
        }

        public void setAsyncStartListener(Boolean asyncStartListener) {
            this.asyncStartListener = asyncStartListener;
        }

        public Boolean getBasicPropertyBinding() {
            return basicPropertyBinding;
        }

        public void setBasicPropertyBinding(Boolean basicPropertyBinding) {
            this.basicPropertyBinding = basicPropertyBinding;
        }

        public HeaderFilterStrategy getHeaderFilterStrategy() {
            return headerFilterStrategy;
        }

        public void setHeaderFilterStrategy(
                HeaderFilterStrategy headerFilterStrategy) {
            this.headerFilterStrategy = headerFilterStrategy;
        }

        public Object getJmsKeyFormatStrategy() {
            return jmsKeyFormatStrategy;
        }

        public void setJmsKeyFormatStrategy(Object jmsKeyFormatStrategy) {
            this.jmsKeyFormatStrategy = jmsKeyFormatStrategy;
        }

        public Integer getKeepAliveDelay() {
            return keepAliveDelay;
        }

        public void setKeepAliveDelay(Integer keepAliveDelay) {
            this.keepAliveDelay = keepAliveDelay;
        }

        public Object getMessageCreatedStrategy() {
            return messageCreatedStrategy;
        }

        public void setMessageCreatedStrategy(Object messageCreatedStrategy) {
            this.messageCreatedStrategy = messageCreatedStrategy;
        }

        public Integer getRecoveryInterval() {
            return recoveryInterval;
        }

        public void setRecoveryInterval(Integer recoveryInterval) {
            this.recoveryInterval = recoveryInterval;
        }

        public Boolean getSynchronous() {
            return synchronous;
        }

        public void setSynchronous(Boolean synchronous) {
            this.synchronous = synchronous;
        }

        public ScheduledExecutorService getTimeoutCheckerExecutorService() {
            return timeoutCheckerExecutorService;
        }

        public void setTimeoutCheckerExecutorService(
                ScheduledExecutorService timeoutCheckerExecutorService) {
            this.timeoutCheckerExecutorService = timeoutCheckerExecutorService;
        }
    }

    public static class SjmsBatchConsumer
            extends
                SjmsBatchCommon<SjmsBatchConsumer> {
        private Boolean bridgeErrorHandler;
        private ExceptionHandler exceptionHandler;
        private ExchangePattern exchangePattern;

        /**
         * Allows for bridging the consumer to the Camel routing Error Handler,
         * which mean any exceptions occurred while the consumer is trying to
         * pickup incoming messages, or the likes, will now be processed as a
         * message and handled by the routing Error Handler. By default the
         * consumer will use the org.apache.camel.spi.ExceptionHandler to deal
         * with exceptions, that will be logged at WARN or ERROR level and
         * ignored. The option is a boolean type.
         */
        public SjmsBatchConsumer bridgeErrorHandler(boolean bridgeErrorHandler) {
            this.bridgeErrorHandler = bridgeErrorHandler;
            return (SjmsBatchConsumer) this;
        }

        /**
         * To let the consumer use a custom ExceptionHandler. Notice if the
         * option bridgeErrorHandler is enabled then this option is not in use.
         * By default the consumer will deal with exceptions, that will be
         * logged at WARN or ERROR level and ignored. The option is a
         * org.apache.camel.spi.ExceptionHandler type.
         */
        public SjmsBatchConsumer exceptionHandler(
                ExceptionHandler exceptionHandler) {
            this.exceptionHandler = exceptionHandler;
            return (SjmsBatchConsumer) this;
        }

        /**
         * Sets the exchange pattern when the consumer creates an exchange. The
         * option is a org.apache.camel.ExchangePattern type.
         */
        public SjmsBatchConsumer exchangePattern(ExchangePattern exchangePattern) {
            this.exchangePattern = exchangePattern;
            return (SjmsBatchConsumer) this;
        }

        public Boolean getBridgeErrorHandler() {
            return bridgeErrorHandler;
        }

        public void setBridgeErrorHandler(Boolean bridgeErrorHandler) {
            this.bridgeErrorHandler = bridgeErrorHandler;
        }

        public ExceptionHandler getExceptionHandler() {
            return exceptionHandler;
        }

        public void setExceptionHandler(ExceptionHandler exceptionHandler) {
            this.exceptionHandler = exceptionHandler;
        }

        public ExchangePattern getExchangePattern() {
            return exchangePattern;
        }

        public void setExchangePattern(ExchangePattern exchangePattern) {
            this.exchangePattern = exchangePattern;
        }
    }

    public static class SjmsBatchProducer
            extends
                SjmsBatchCommon<SjmsBatchProducer> {
    }
}