/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.endpoint;

import javax.annotation.Generated;
import org.apache.camel.ExchangePattern;
import org.apache.camel.spi.ExceptionHandler;

/**
 * Provides functionality required by Healthcare providers to communicate with
 * other systems using the MLLP protocol.
 * 
 * Generated by camel-package-maven-plugin - do not edit this file!
 */
@Generated("org.apache.camel.maven.packaging.EndpointDslMojo")
public class MllpEndpoint {


    public static class MllpCommon<T extends EndpointConfiguration>
            extends
                EndpointConfiguration<T> {
        private String hostname;
        private Integer port;
        private Boolean autoAck;
        @Deprecated
        private Boolean bufferWrites;
        private Boolean hl7Headers;
        private Boolean requireEndOfData;
        private Boolean stringPayload;
        private Boolean validatePayload;
        private Boolean basicPropertyBinding;
        private Boolean synchronous;
        private Integer idleTimeout;
        private Integer receiveBufferSize;
        private Integer sendBufferSize;
        private Integer readTimeout;
        private Integer receiveTimeout;
        private String charsetName;

        /**
         * Hostname or IP for connection for the TCP connection. The default
         * value is null, which means any local IP address. The option is a
         * java.lang.String type.
         */
        public T hostname(String hostname) {
            this.hostname = hostname;
            return (T) this;
        }

        /**
         * Port number for the TCP connection. The option is a int type.
         */
        public T port(int port) {
            this.port = port;
            return (T) this;
        }

        /**
         * Enable/Disable the automatic generation of a MLLP Acknowledgement
         * MLLP Consumers only. The option is a boolean type.
         */
        public T autoAck(boolean autoAck) {
            this.autoAck = autoAck;
            return (T) this;
        }

        /**
         * Enable/Disable the buffering of HL7 payloads before writing to the
         * socket. The option is a boolean type.
         */
        @Deprecated
        public T bufferWrites(boolean bufferWrites) {
            this.bufferWrites = bufferWrites;
            return (T) this;
        }

        /**
         * Enable/Disable the automatic generation of message headers from the
         * HL7 Message MLLP Consumers only. The option is a boolean type.
         */
        public T hl7Headers(boolean hl7Headers) {
            this.hl7Headers = hl7Headers;
            return (T) this;
        }

        /**
         * Enable/Disable strict compliance to the MLLP standard. The MLLP
         * standard specifies START_OF_BLOCKhl7 payloadEND_OF_BLOCKEND_OF_DATA,
         * however, some systems do not send the final END_OF_DATA byte. This
         * setting controls whether or not the final END_OF_DATA byte is
         * required or optional. The option is a boolean type.
         */
        public T requireEndOfData(boolean requireEndOfData) {
            this.requireEndOfData = requireEndOfData;
            return (T) this;
        }

        /**
         * Enable/Disable converting the payload to a String. If enabled, HL7
         * Payloads received from external systems will be validated converted
         * to a String. If the charsetName property is set, that character set
         * will be used for the conversion. If the charsetName property is not
         * set, the value of MSH-18 will be used to determine th appropriate
         * character set. If MSH-18 is not set, then the default ISO-8859-1
         * character set will be use. The option is a boolean type.
         */
        public T stringPayload(boolean stringPayload) {
            this.stringPayload = stringPayload;
            return (T) this;
        }

        /**
         * Enable/Disable the validation of HL7 Payloads If enabled, HL7
         * Payloads received from external systems will be validated (see
         * Hl7Util.generateInvalidPayloadExceptionMessage for details on the
         * validation). If and invalid payload is detected, a
         * MllpInvalidMessageException (for consumers) or a
         * MllpInvalidAcknowledgementException will be thrown. The option is a
         * boolean type.
         */
        public T validatePayload(boolean validatePayload) {
            this.validatePayload = validatePayload;
            return (T) this;
        }

        /**
         * Whether the endpoint should use basic property binding (Camel 2.x) or
         * the newer property binding with additional capabilities. The option
         * is a boolean type.
         */
        public T basicPropertyBinding(boolean basicPropertyBinding) {
            this.basicPropertyBinding = basicPropertyBinding;
            return (T) this;
        }

        /**
         * Sets whether synchronous processing should be strictly used (this
         * component only supports synchronous operations). The option is a
         * boolean type.
         */
        public T synchronous(boolean synchronous) {
            this.synchronous = synchronous;
            return (T) this;
        }

        /**
         * The approximate idle time allowed before the Client TCP Connection
         * will be reset. A null value or a value less than or equal to zero
         * will disable the idle timeout. The option is a java.lang.Integer
         * type.
         */
        public T idleTimeout(Integer idleTimeout) {
            this.idleTimeout = idleTimeout;
            return (T) this;
        }

        /**
         * Sets the SO_RCVBUF option to the specified value (in bytes). The
         * option is a java.lang.Integer type.
         */
        public T receiveBufferSize(Integer receiveBufferSize) {
            this.receiveBufferSize = receiveBufferSize;
            return (T) this;
        }

        /**
         * Sets the SO_SNDBUF option to the specified value (in bytes). The
         * option is a java.lang.Integer type.
         */
        public T sendBufferSize(Integer sendBufferSize) {
            this.sendBufferSize = sendBufferSize;
            return (T) this;
        }

        /**
         * The SO_TIMEOUT value (in milliseconds) used after the start of an
         * MLLP frame has been received. The option is a int type.
         */
        public T readTimeout(int readTimeout) {
            this.readTimeout = readTimeout;
            return (T) this;
        }

        /**
         * The SO_TIMEOUT value (in milliseconds) used when waiting for the
         * start of an MLLP frame. The option is a int type.
         */
        public T receiveTimeout(int receiveTimeout) {
            this.receiveTimeout = receiveTimeout;
            return (T) this;
        }

        /**
         * Set the CamelCharsetName property on the exchange. The option is a
         * java.lang.String type.
         */
        public T charsetName(String charsetName) {
            this.charsetName = charsetName;
            return (T) this;
        }

        public String getHostname() {
            return hostname;
        }

        public void setHostname(String hostname) {
            this.hostname = hostname;
        }

        public Integer getPort() {
            return port;
        }

        public void setPort(Integer port) {
            this.port = port;
        }

        public Boolean getAutoAck() {
            return autoAck;
        }

        public void setAutoAck(Boolean autoAck) {
            this.autoAck = autoAck;
        }

        @Deprecated
        public Boolean getBufferWrites() {
            return bufferWrites;
        }

        @Deprecated
        public void setBufferWrites(Boolean bufferWrites) {
            this.bufferWrites = bufferWrites;
        }

        public Boolean getHl7Headers() {
            return hl7Headers;
        }

        public void setHl7Headers(Boolean hl7Headers) {
            this.hl7Headers = hl7Headers;
        }

        public Boolean getRequireEndOfData() {
            return requireEndOfData;
        }

        public void setRequireEndOfData(Boolean requireEndOfData) {
            this.requireEndOfData = requireEndOfData;
        }

        public Boolean getStringPayload() {
            return stringPayload;
        }

        public void setStringPayload(Boolean stringPayload) {
            this.stringPayload = stringPayload;
        }

        public Boolean getValidatePayload() {
            return validatePayload;
        }

        public void setValidatePayload(Boolean validatePayload) {
            this.validatePayload = validatePayload;
        }

        public Boolean getBasicPropertyBinding() {
            return basicPropertyBinding;
        }

        public void setBasicPropertyBinding(Boolean basicPropertyBinding) {
            this.basicPropertyBinding = basicPropertyBinding;
        }

        public Boolean getSynchronous() {
            return synchronous;
        }

        public void setSynchronous(Boolean synchronous) {
            this.synchronous = synchronous;
        }

        public Integer getIdleTimeout() {
            return idleTimeout;
        }

        public void setIdleTimeout(Integer idleTimeout) {
            this.idleTimeout = idleTimeout;
        }

        public Integer getReceiveBufferSize() {
            return receiveBufferSize;
        }

        public void setReceiveBufferSize(Integer receiveBufferSize) {
            this.receiveBufferSize = receiveBufferSize;
        }

        public Integer getSendBufferSize() {
            return sendBufferSize;
        }

        public void setSendBufferSize(Integer sendBufferSize) {
            this.sendBufferSize = sendBufferSize;
        }

        public Integer getReadTimeout() {
            return readTimeout;
        }

        public void setReadTimeout(Integer readTimeout) {
            this.readTimeout = readTimeout;
        }

        public Integer getReceiveTimeout() {
            return receiveTimeout;
        }

        public void setReceiveTimeout(Integer receiveTimeout) {
            this.receiveTimeout = receiveTimeout;
        }

        public String getCharsetName() {
            return charsetName;
        }

        public void setCharsetName(String charsetName) {
            this.charsetName = charsetName;
        }
    }

    public static class MllpConsumer extends MllpCommon<MllpConsumer> {
        private Boolean bridgeErrorHandler;
        private ExceptionHandler exceptionHandler;
        private ExchangePattern exchangePattern;
        private Integer backlog;
        private Boolean lenientBind;
        private Integer maxConcurrentConsumers;
        private Boolean reuseAddress;
        private Integer acceptTimeout;
        private Integer bindRetryInterval;
        private Integer bindTimeout;
        @Deprecated
        private Integer maxReceiveTimeouts;

        /**
         * Allows for bridging the consumer to the Camel routing Error Handler,
         * which mean any exceptions occurred while the consumer is trying to
         * receive incoming messages, or the likes, will now be processed as a
         * message and handled by the routing Error Handler. If disabled, the
         * consumer will use the org.apache.camel.spi.ExceptionHandler to deal
         * with exceptions by logging them at WARN or ERROR level and ignored.
         * The option is a boolean type.
         */
        public MllpConsumer bridgeErrorHandler(boolean bridgeErrorHandler) {
            this.bridgeErrorHandler = bridgeErrorHandler;
            return (MllpConsumer) this;
        }

        /**
         * To let the consumer use a custom ExceptionHandler. Notice if the
         * option bridgeErrorHandler is enabled then this option is not in use.
         * By default the consumer will deal with exceptions, that will be
         * logged at WARN or ERROR level and ignored. The option is a
         * org.apache.camel.spi.ExceptionHandler type.
         */
        public MllpConsumer exceptionHandler(ExceptionHandler exceptionHandler) {
            this.exceptionHandler = exceptionHandler;
            return (MllpConsumer) this;
        }

        /**
         * Sets the exchange pattern when the consumer creates an exchange. The
         * option is a org.apache.camel.ExchangePattern type.
         */
        public MllpConsumer exchangePattern(ExchangePattern exchangePattern) {
            this.exchangePattern = exchangePattern;
            return (MllpConsumer) this;
        }

        /**
         * The maximum queue length for incoming connection indications (a
         * request to connect) is set to the backlog parameter. If a connection
         * indication arrives when the queue is full, the connection is refused.
         * The option is a java.lang.Integer type.
         */
        public MllpConsumer backlog(Integer backlog) {
            this.backlog = backlog;
            return (MllpConsumer) this;
        }

        /**
         * TCP Server Only - Allow the endpoint to start before the TCP
         * ServerSocket is bound. In some environments, it may be desirable to
         * allow the endpoint to start before the TCP ServerSocket is bound. The
         * option is a boolean type.
         */
        public MllpConsumer lenientBind(boolean lenientBind) {
            this.lenientBind = lenientBind;
            return (MllpConsumer) this;
        }

        /**
         * The maximum number of concurrent MLLP Consumer connections that will
         * be allowed. If a new connection is received and the maximum is number
         * are already established, the new connection will be reset
         * immediately. The option is a int type.
         */
        public MllpConsumer maxConcurrentConsumers(int maxConcurrentConsumers) {
            this.maxConcurrentConsumers = maxConcurrentConsumers;
            return (MllpConsumer) this;
        }

        /**
         * Enable/disable the SO_REUSEADDR socket option. The option is a
         * java.lang.Boolean type.
         */
        public MllpConsumer reuseAddress(Boolean reuseAddress) {
            this.reuseAddress = reuseAddress;
            return (MllpConsumer) this;
        }

        /**
         * Timeout (in milliseconds) while waiting for a TCP connection TCP
         * Server Only. The option is a int type.
         */
        public MllpConsumer acceptTimeout(int acceptTimeout) {
            this.acceptTimeout = acceptTimeout;
            return (MllpConsumer) this;
        }

        /**
         * TCP Server Only - The number of milliseconds to wait between bind
         * attempts. The option is a int type.
         */
        public MllpConsumer bindRetryInterval(int bindRetryInterval) {
            this.bindRetryInterval = bindRetryInterval;
            return (MllpConsumer) this;
        }

        /**
         * TCP Server Only - The number of milliseconds to retry binding to a
         * server port. The option is a int type.
         */
        public MllpConsumer bindTimeout(int bindTimeout) {
            this.bindTimeout = bindTimeout;
            return (MllpConsumer) this;
        }

        /**
         * The maximum number of timeouts (specified by receiveTimeout) allowed
         * before the TCP Connection will be reset. The option is a
         * java.lang.Integer type.
         */
        @Deprecated
        public MllpConsumer maxReceiveTimeouts(Integer maxReceiveTimeouts) {
            this.maxReceiveTimeouts = maxReceiveTimeouts;
            return (MllpConsumer) this;
        }

        public Boolean getBridgeErrorHandler() {
            return bridgeErrorHandler;
        }

        public void setBridgeErrorHandler(Boolean bridgeErrorHandler) {
            this.bridgeErrorHandler = bridgeErrorHandler;
        }

        public ExceptionHandler getExceptionHandler() {
            return exceptionHandler;
        }

        public void setExceptionHandler(ExceptionHandler exceptionHandler) {
            this.exceptionHandler = exceptionHandler;
        }

        public ExchangePattern getExchangePattern() {
            return exchangePattern;
        }

        public void setExchangePattern(ExchangePattern exchangePattern) {
            this.exchangePattern = exchangePattern;
        }

        public Integer getBacklog() {
            return backlog;
        }

        public void setBacklog(Integer backlog) {
            this.backlog = backlog;
        }

        public Boolean getLenientBind() {
            return lenientBind;
        }

        public void setLenientBind(Boolean lenientBind) {
            this.lenientBind = lenientBind;
        }

        public Integer getMaxConcurrentConsumers() {
            return maxConcurrentConsumers;
        }

        public void setMaxConcurrentConsumers(Integer maxConcurrentConsumers) {
            this.maxConcurrentConsumers = maxConcurrentConsumers;
        }

        public Boolean getReuseAddress() {
            return reuseAddress;
        }

        public void setReuseAddress(Boolean reuseAddress) {
            this.reuseAddress = reuseAddress;
        }

        public Integer getAcceptTimeout() {
            return acceptTimeout;
        }

        public void setAcceptTimeout(Integer acceptTimeout) {
            this.acceptTimeout = acceptTimeout;
        }

        public Integer getBindRetryInterval() {
            return bindRetryInterval;
        }

        public void setBindRetryInterval(Integer bindRetryInterval) {
            this.bindRetryInterval = bindRetryInterval;
        }

        public Integer getBindTimeout() {
            return bindTimeout;
        }

        public void setBindTimeout(Integer bindTimeout) {
            this.bindTimeout = bindTimeout;
        }

        @Deprecated
        public Integer getMaxReceiveTimeouts() {
            return maxReceiveTimeouts;
        }

        @Deprecated
        public void setMaxReceiveTimeouts(Integer maxReceiveTimeouts) {
            this.maxReceiveTimeouts = maxReceiveTimeouts;
        }
    }

    public static class MllpProducer extends MllpCommon<MllpProducer> {
        private Integer connectTimeout;
        private Boolean keepAlive;
        private Boolean tcpNoDelay;

        /**
         * Timeout (in milliseconds) for establishing for a TCP connection TCP
         * Client only. The option is a int type.
         */
        public MllpProducer connectTimeout(int connectTimeout) {
            this.connectTimeout = connectTimeout;
            return (MllpProducer) this;
        }

        /**
         * Enable/disable the SO_KEEPALIVE socket option. The option is a
         * java.lang.Boolean type.
         */
        public MllpProducer keepAlive(Boolean keepAlive) {
            this.keepAlive = keepAlive;
            return (MllpProducer) this;
        }

        /**
         * Enable/disable the TCP_NODELAY socket option. The option is a
         * java.lang.Boolean type.
         */
        public MllpProducer tcpNoDelay(Boolean tcpNoDelay) {
            this.tcpNoDelay = tcpNoDelay;
            return (MllpProducer) this;
        }

        public Integer getConnectTimeout() {
            return connectTimeout;
        }

        public void setConnectTimeout(Integer connectTimeout) {
            this.connectTimeout = connectTimeout;
        }

        public Boolean getKeepAlive() {
            return keepAlive;
        }

        public void setKeepAlive(Boolean keepAlive) {
            this.keepAlive = keepAlive;
        }

        public Boolean getTcpNoDelay() {
            return tcpNoDelay;
        }

        public void setTcpNoDelay(Boolean tcpNoDelay) {
            this.tcpNoDelay = tcpNoDelay;
        }
    }
}