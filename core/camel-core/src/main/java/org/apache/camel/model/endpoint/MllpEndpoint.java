/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.endpoint;

import javax.annotation.Generated;
import org.apache.camel.ExchangePattern;
import org.apache.camel.spi.ExceptionHandler;

/**
 * Provides functionality required by Healthcare providers to communicate with
 * other systems using the MLLP protocol.
 * 
 * Generated by camel-package-maven-plugin - do not edit this file!
 */
@Generated("org.apache.camel.maven.packaging.EndpointDslMojo")
public class MllpEndpoint {


    public static class MllpCommon extends EndpointConfiguration {
        /**
         * Hostname or IP for connection for the TCP connection. The default
         * value is null, which means any local IP address. The option is a
         * java.lang.String type.
         */
        private String hostname;
        /**
         * Port number for the TCP connection. The option is a int type.
         */
        private int port;
        /**
         * Enable/Disable the automatic generation of a MLLP Acknowledgement
         * MLLP Consumers only. The option is a boolean type.
         */
        private boolean autoAck;
        /**
         * Enable/Disable the buffering of HL7 payloads before writing to the
         * socket. The option is a boolean type.
         */
        @Deprecated
        private boolean bufferWrites;
        /**
         * Enable/Disable the automatic generation of message headers from the
         * HL7 Message MLLP Consumers only. The option is a boolean type.
         */
        private boolean hl7Headers;
        /**
         * Enable/Disable strict compliance to the MLLP standard. The MLLP
         * standard specifies START_OF_BLOCKhl7 payloadEND_OF_BLOCKEND_OF_DATA,
         * however, some systems do not send the final END_OF_DATA byte. This
         * setting controls whether or not the final END_OF_DATA byte is
         * required or optional. The option is a boolean type.
         */
        private boolean requireEndOfData;
        /**
         * Enable/Disable converting the payload to a String. If enabled, HL7
         * Payloads received from external systems will be validated converted
         * to a String. If the charsetName property is set, that character set
         * will be used for the conversion. If the charsetName property is not
         * set, the value of MSH-18 will be used to determine th appropriate
         * character set. If MSH-18 is not set, then the default ISO-8859-1
         * character set will be use. The option is a boolean type.
         */
        private boolean stringPayload;
        /**
         * Enable/Disable the validation of HL7 Payloads If enabled, HL7
         * Payloads received from external systems will be validated (see
         * Hl7Util.generateInvalidPayloadExceptionMessage for details on the
         * validation). If and invalid payload is detected, a
         * MllpInvalidMessageException (for consumers) or a
         * MllpInvalidAcknowledgementException will be thrown. The option is a
         * boolean type.
         */
        private boolean validatePayload;
        /**
         * Whether the endpoint should use basic property binding (Camel 2.x) or
         * the newer property binding with additional capabilities. The option
         * is a boolean type.
         */
        private boolean basicPropertyBinding;
        /**
         * Sets whether synchronous processing should be strictly used (this
         * component only supports synchronous operations). The option is a
         * boolean type.
         */
        private boolean synchronous;
        /**
         * The approximate idle time allowed before the Client TCP Connection
         * will be reset. A null value or a value less than or equal to zero
         * will disable the idle timeout. The option is a java.lang.Integer
         * type.
         */
        private Integer idleTimeout;
        /**
         * Sets the SO_RCVBUF option to the specified value (in bytes). The
         * option is a java.lang.Integer type.
         */
        private Integer receiveBufferSize;
        /**
         * Sets the SO_SNDBUF option to the specified value (in bytes). The
         * option is a java.lang.Integer type.
         */
        private Integer sendBufferSize;
        /**
         * The SO_TIMEOUT value (in milliseconds) used after the start of an
         * MLLP frame has been received. The option is a int type.
         */
        private int readTimeout;
        /**
         * The SO_TIMEOUT value (in milliseconds) used when waiting for the
         * start of an MLLP frame. The option is a int type.
         */
        private int receiveTimeout;
        /**
         * Set the CamelCharsetName property on the exchange. The option is a
         * java.lang.String type.
         */
        private String charsetName;

        public String getHostname() {
            return hostname;
        }

        public void setHostname(String hostname) {
            this.hostname = hostname;
        }

        public int getPort() {
            return port;
        }

        public void setPort(int port) {
            this.port = port;
        }

        public boolean getAutoAck() {
            return autoAck;
        }

        public void setAutoAck(boolean autoAck) {
            this.autoAck = autoAck;
        }

        @Deprecated
        public boolean getBufferWrites() {
            return bufferWrites;
        }

        @Deprecated
        public void setBufferWrites(boolean bufferWrites) {
            this.bufferWrites = bufferWrites;
        }

        public boolean getHl7Headers() {
            return hl7Headers;
        }

        public void setHl7Headers(boolean hl7Headers) {
            this.hl7Headers = hl7Headers;
        }

        public boolean getRequireEndOfData() {
            return requireEndOfData;
        }

        public void setRequireEndOfData(boolean requireEndOfData) {
            this.requireEndOfData = requireEndOfData;
        }

        public boolean getStringPayload() {
            return stringPayload;
        }

        public void setStringPayload(boolean stringPayload) {
            this.stringPayload = stringPayload;
        }

        public boolean getValidatePayload() {
            return validatePayload;
        }

        public void setValidatePayload(boolean validatePayload) {
            this.validatePayload = validatePayload;
        }

        public boolean getBasicPropertyBinding() {
            return basicPropertyBinding;
        }

        public void setBasicPropertyBinding(boolean basicPropertyBinding) {
            this.basicPropertyBinding = basicPropertyBinding;
        }

        public boolean getSynchronous() {
            return synchronous;
        }

        public void setSynchronous(boolean synchronous) {
            this.synchronous = synchronous;
        }

        public Integer getIdleTimeout() {
            return idleTimeout;
        }

        public void setIdleTimeout(Integer idleTimeout) {
            this.idleTimeout = idleTimeout;
        }

        public Integer getReceiveBufferSize() {
            return receiveBufferSize;
        }

        public void setReceiveBufferSize(Integer receiveBufferSize) {
            this.receiveBufferSize = receiveBufferSize;
        }

        public Integer getSendBufferSize() {
            return sendBufferSize;
        }

        public void setSendBufferSize(Integer sendBufferSize) {
            this.sendBufferSize = sendBufferSize;
        }

        public int getReadTimeout() {
            return readTimeout;
        }

        public void setReadTimeout(int readTimeout) {
            this.readTimeout = readTimeout;
        }

        public int getReceiveTimeout() {
            return receiveTimeout;
        }

        public void setReceiveTimeout(int receiveTimeout) {
            this.receiveTimeout = receiveTimeout;
        }

        public String getCharsetName() {
            return charsetName;
        }

        public void setCharsetName(String charsetName) {
            this.charsetName = charsetName;
        }
    }

    public static class MllpConsumer extends MllpCommon {
        /**
         * Allows for bridging the consumer to the Camel routing Error Handler,
         * which mean any exceptions occurred while the consumer is trying to
         * receive incoming messages, or the likes, will now be processed as a
         * message and handled by the routing Error Handler. If disabled, the
         * consumer will use the org.apache.camel.spi.ExceptionHandler to deal
         * with exceptions by logging them at WARN or ERROR level and ignored.
         * The option is a boolean type.
         */
        private boolean bridgeErrorHandler;
        /**
         * To let the consumer use a custom ExceptionHandler. Notice if the
         * option bridgeErrorHandler is enabled then this option is not in use.
         * By default the consumer will deal with exceptions, that will be
         * logged at WARN or ERROR level and ignored. The option is a
         * org.apache.camel.spi.ExceptionHandler type.
         */
        private ExceptionHandler exceptionHandler;
        /**
         * Sets the exchange pattern when the consumer creates an exchange. The
         * option is a org.apache.camel.ExchangePattern type.
         */
        private ExchangePattern exchangePattern;
        /**
         * The maximum queue length for incoming connection indications (a
         * request to connect) is set to the backlog parameter. If a connection
         * indication arrives when the queue is full, the connection is refused.
         * The option is a java.lang.Integer type.
         */
        private Integer backlog;
        /**
         * TCP Server Only - Allow the endpoint to start before the TCP
         * ServerSocket is bound. In some environments, it may be desirable to
         * allow the endpoint to start before the TCP ServerSocket is bound. The
         * option is a boolean type.
         */
        private boolean lenientBind;
        /**
         * The maximum number of concurrent MLLP Consumer connections that will
         * be allowed. If a new connection is received and the maximum is number
         * are already established, the new connection will be reset
         * immediately. The option is a int type.
         */
        private int maxConcurrentConsumers;
        /**
         * Enable/disable the SO_REUSEADDR socket option. The option is a
         * java.lang.Boolean type.
         */
        private Boolean reuseAddress;
        /**
         * Timeout (in milliseconds) while waiting for a TCP connection TCP
         * Server Only. The option is a int type.
         */
        private int acceptTimeout;
        /**
         * TCP Server Only - The number of milliseconds to wait between bind
         * attempts. The option is a int type.
         */
        private int bindRetryInterval;
        /**
         * TCP Server Only - The number of milliseconds to retry binding to a
         * server port. The option is a int type.
         */
        private int bindTimeout;
        /**
         * The maximum number of timeouts (specified by receiveTimeout) allowed
         * before the TCP Connection will be reset. The option is a
         * java.lang.Integer type.
         */
        @Deprecated
        private Integer maxReceiveTimeouts;

        public boolean getBridgeErrorHandler() {
            return bridgeErrorHandler;
        }

        public void setBridgeErrorHandler(boolean bridgeErrorHandler) {
            this.bridgeErrorHandler = bridgeErrorHandler;
        }

        public ExceptionHandler getExceptionHandler() {
            return exceptionHandler;
        }

        public void setExceptionHandler(ExceptionHandler exceptionHandler) {
            this.exceptionHandler = exceptionHandler;
        }

        public ExchangePattern getExchangePattern() {
            return exchangePattern;
        }

        public void setExchangePattern(ExchangePattern exchangePattern) {
            this.exchangePattern = exchangePattern;
        }

        public Integer getBacklog() {
            return backlog;
        }

        public void setBacklog(Integer backlog) {
            this.backlog = backlog;
        }

        public boolean getLenientBind() {
            return lenientBind;
        }

        public void setLenientBind(boolean lenientBind) {
            this.lenientBind = lenientBind;
        }

        public int getMaxConcurrentConsumers() {
            return maxConcurrentConsumers;
        }

        public void setMaxConcurrentConsumers(int maxConcurrentConsumers) {
            this.maxConcurrentConsumers = maxConcurrentConsumers;
        }

        public Boolean getReuseAddress() {
            return reuseAddress;
        }

        public void setReuseAddress(Boolean reuseAddress) {
            this.reuseAddress = reuseAddress;
        }

        public int getAcceptTimeout() {
            return acceptTimeout;
        }

        public void setAcceptTimeout(int acceptTimeout) {
            this.acceptTimeout = acceptTimeout;
        }

        public int getBindRetryInterval() {
            return bindRetryInterval;
        }

        public void setBindRetryInterval(int bindRetryInterval) {
            this.bindRetryInterval = bindRetryInterval;
        }

        public int getBindTimeout() {
            return bindTimeout;
        }

        public void setBindTimeout(int bindTimeout) {
            this.bindTimeout = bindTimeout;
        }

        @Deprecated
        public Integer getMaxReceiveTimeouts() {
            return maxReceiveTimeouts;
        }

        @Deprecated
        public void setMaxReceiveTimeouts(Integer maxReceiveTimeouts) {
            this.maxReceiveTimeouts = maxReceiveTimeouts;
        }
    }

    public static class MllpProducer extends MllpCommon {
        /**
         * Timeout (in milliseconds) for establishing for a TCP connection TCP
         * Client only. The option is a int type.
         */
        private int connectTimeout;
        /**
         * Enable/disable the SO_KEEPALIVE socket option. The option is a
         * java.lang.Boolean type.
         */
        private Boolean keepAlive;
        /**
         * Enable/disable the TCP_NODELAY socket option. The option is a
         * java.lang.Boolean type.
         */
        private Boolean tcpNoDelay;

        public int getConnectTimeout() {
            return connectTimeout;
        }

        public void setConnectTimeout(int connectTimeout) {
            this.connectTimeout = connectTimeout;
        }

        public Boolean getKeepAlive() {
            return keepAlive;
        }

        public void setKeepAlive(Boolean keepAlive) {
            this.keepAlive = keepAlive;
        }

        public Boolean getTcpNoDelay() {
            return tcpNoDelay;
        }

        public void setTcpNoDelay(Boolean tcpNoDelay) {
            this.tcpNoDelay = tcpNoDelay;
        }
    }
}