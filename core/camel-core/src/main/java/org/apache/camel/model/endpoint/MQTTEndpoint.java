/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.endpoint;

import java.net.URI;
import java.util.concurrent.Executor;
import javax.annotation.Generated;
import org.apache.camel.ExchangePattern;
import org.apache.camel.spi.ExceptionHandler;

/**
 * Component for communicating with MQTT M2M message brokers using FuseSource
 * MQTT Client.
 * 
 * Generated by camel-package-maven-plugin - do not edit this file!
 */
@Generated("org.apache.camel.maven.packaging.EndpointDslMojo")
public class MQTTEndpoint {


    public static class MQTTCommon extends EndpointConfiguration {
        /**
         * A logical name to use which is not the topic name. The option is a
         * java.lang.String type.
         */
        private String name;
        /**
         * SSL connections perform blocking operations against internal thread
         * pool unless you call the setBlockingExecutor method to configure that
         * executor they will use instead. The option is a
         * java.util.concurrent.Executor type.
         */
        private Executor blockingExecutor;
        /**
         * The default retain policy to be used on messages sent to the MQTT
         * broker. The option is a boolean type.
         */
        private boolean byDefaultRetain;
        /**
         * Set to false if you want the MQTT server to persist topic
         * subscriptions and ack positions across client sessions. Defaults to
         * true. The option is a boolean type.
         */
        private boolean cleanSession;
        /**
         * Use to set the client Id of the session. This is what an MQTT server
         * uses to identify a session where setCleanSession(false); is being
         * used. The id must be 23 characters or less. Defaults to auto
         * generated id (based on your socket address, port and timestamp). The
         * option is a java.lang.String type.
         */
        private String clientId;
        /**
         * The maximum number of reconnect attempts before an error is reported
         * back to the client on the first attempt by the client to connect to a
         * server. Set to -1 to use unlimited attempts. Defaults to -1. The
         * option is a long type.
         */
        private long connectAttemptsMax;
        /**
         * Delay in seconds the Component will wait for a connection to be
         * established to the MQTT broker. The option is a int type.
         */
        private int connectWaitInSeconds;
        /**
         * The number of seconds the Component will wait for a valid disconnect
         * on stop() from the MQTT broker. The option is a int type.
         */
        private int disconnectWaitInSeconds;
        /**
         * A HawtDispatch dispatch queue is used to synchronize access to the
         * connection. If an explicit queue is not configured via the
         * setDispatchQueue method, then a new queue will be created for the
         * connection. Setting an explicit queue might be handy if you want
         * multiple connection to share the same queue for synchronization. The
         * option is a org.fusesource.hawtdispatch.DispatchQueue type.
         */
        private Object dispatchQueue;
        /**
         * The URI of the MQTT broker to connect too - this component also
         * supports SSL - e.g. ssl://127.0.0.1:8883. The option is a
         * java.net.URI type.
         */
        private String host;
        /**
         * Configures the Keep Alive timer in seconds. Defines the maximum time
         * interval between messages received from a client. It enables the
         * server to detect that the network connection to a client has dropped,
         * without having to wait for the long TCP/IP timeout. The option is a
         * short type.
         */
        private short keepAlive;
        /**
         * The local InetAddress and port to use. The option is a java.net.URI
         * type.
         */
        private URI localAddress;
        /**
         * Sets the maximum bytes per second that this transport will receive
         * data at. This setting throttles reads so that the rate is not
         * exceeded. Defaults to 0 which disables throttling. The option is a
         * int type.
         */
        private int maxReadRate;
        /**
         * Sets the maximum bytes per second that this transport will send data
         * at. This setting throttles writes so that the rate is not exceeded.
         * Defaults to 0 which disables throttling. The option is a int type.
         */
        private int maxWriteRate;
        /**
         * The property name to look for on an Exchange for an individual
         * published message. If this is set (one of AtMostOnce, AtLeastOnce or
         * ExactlyOnce ) - then that QoS will be set on the message sent to the
         * MQTT message broker. The option is a java.lang.String type.
         */
        private String mqttQosPropertyName;
        /**
         * The property name to look for on an Exchange for an individual
         * published message. If this is set (expects a Boolean value) - then
         * the retain property will be set on the message sent to the MQTT
         * message broker. The option is a java.lang.String type.
         */
        private String mqttRetainPropertyName;
        /**
         * These a properties that are looked for in an Exchange - to publish
         * to. The option is a java.lang.String type.
         */
        private String mqttTopicPropertyName;
        /**
         * The default Topic to publish messages on. The option is a
         * java.lang.String type.
         */
        private String publishTopicName;
        /**
         * Quality of service level to use for topics. The option is a
         * java.lang.String type.
         */
        private String qualityOfService;
        /**
         * Sets the size of the internal socket receive buffer. Defaults to
         * 65536 (64k). The option is a int type.
         */
        private int receiveBufferSize;
        /**
         * The maximum number of reconnect attempts before an error is reported
         * back to the client after a server connection had previously been
         * established. Set to -1 to use unlimited attempts. Defaults to -1. The
         * option is a long type.
         */
        private long reconnectAttemptsMax;
        /**
         * The Exponential backoff be used between reconnect attempts. Set to 1
         * to disable exponential backoff. Defaults to 2. The option is a double
         * type.
         */
        private double reconnectBackOffMultiplier;
        /**
         * How long to wait in ms before the first reconnect attempt. Defaults
         * to 10. The option is a long type.
         */
        private long reconnectDelay;
        /**
         * The maximum amount of time in ms to wait between reconnect attempts.
         * Defaults to 30,000. The option is a long type.
         */
        private long reconnectDelayMax;
        /**
         * Sets the size of the internal socket send buffer. Defaults to 65536
         * (64k). The option is a int type.
         */
        private int sendBufferSize;
        /**
         * The maximum time the Component will wait for a receipt from the MQTT
         * broker to acknowledge a published message before throwing an
         * exception. The option is a int type.
         */
        private int sendWaitInSeconds;
        /**
         * To configure security using SSLContext configuration. The option is a
         * javax.net.ssl.SSLContext type.
         */
        private Object sslContext;
        /**
         * These are set on the Endpoint - together with properties inherited
         * from MQTT. The option is a java.lang.String type.
         */
        @Deprecated
        private String subscribeTopicName;
        /**
         * A comma-delimited list of Topics to subscribe to for messages. Note
         * that each item of this list can contain MQTT wildcards ( and/or #),
         * in order to subscribe to topics matching a certain pattern within a
         * hierarchy. For example, is a wildcard for all topics at a level
         * within the hierarchy, so if a broker has topics topics/one and
         * topics/two, then topics/ can be used to subscribe to both. A caveat
         * to consider here is that if the broker adds topics/three, the route
         * would also begin to receive messages from that topic. The option is a
         * java.lang.String type.
         */
        private String subscribeTopicNames;
        /**
         * Sets traffic class or type-of-service octet in the IP header for
         * packets sent from the transport. Defaults to 8 which means the
         * traffic should be optimized for throughput. The option is a int type.
         */
        private int trafficClass;
        /**
         * Set to 3.1.1 to use MQTT version 3.1.1. Otherwise defaults to the 3.1
         * protocol version. The option is a java.lang.String type.
         */
        private String version;
        /**
         * The Will message to send. Defaults to a zero length message. The
         * option is a java.lang.String type.
         */
        private String willMessage;
        /**
         * Sets the quality of service to use for the Will message. Defaults to
         * AT_MOST_ONCE. The option is a org.fusesource.mqtt.client.QoS type.
         */
        private QoS willQos;
        /**
         * Set to true if you want the Will to be published with the retain
         * option. The option is a org.fusesource.mqtt.client.QoS type.
         */
        private QoS willRetain;
        /**
         * If set the server will publish the client's Will message to the
         * specified topics if the client has an unexpected disconnection. The
         * option is a java.lang.String type.
         */
        private String willTopic;
        /**
         * Whether the endpoint should use basic property binding (Camel 2.x) or
         * the newer property binding with additional capabilities. The option
         * is a boolean type.
         */
        private boolean basicPropertyBinding;
        /**
         * Sets whether synchronous processing should be strictly used, or Camel
         * is allowed to use asynchronous processing (if supported). The option
         * is a boolean type.
         */
        private boolean synchronous;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public Executor getBlockingExecutor() {
            return blockingExecutor;
        }

        public void setBlockingExecutor(Executor blockingExecutor) {
            this.blockingExecutor = blockingExecutor;
        }

        public boolean getByDefaultRetain() {
            return byDefaultRetain;
        }

        public void setByDefaultRetain(boolean byDefaultRetain) {
            this.byDefaultRetain = byDefaultRetain;
        }

        public boolean getCleanSession() {
            return cleanSession;
        }

        public void setCleanSession(boolean cleanSession) {
            this.cleanSession = cleanSession;
        }

        public String getClientId() {
            return clientId;
        }

        public void setClientId(String clientId) {
            this.clientId = clientId;
        }

        public long getConnectAttemptsMax() {
            return connectAttemptsMax;
        }

        public void setConnectAttemptsMax(long connectAttemptsMax) {
            this.connectAttemptsMax = connectAttemptsMax;
        }

        public int getConnectWaitInSeconds() {
            return connectWaitInSeconds;
        }

        public void setConnectWaitInSeconds(int connectWaitInSeconds) {
            this.connectWaitInSeconds = connectWaitInSeconds;
        }

        public int getDisconnectWaitInSeconds() {
            return disconnectWaitInSeconds;
        }

        public void setDisconnectWaitInSeconds(int disconnectWaitInSeconds) {
            this.disconnectWaitInSeconds = disconnectWaitInSeconds;
        }

        public Object getDispatchQueue() {
            return dispatchQueue;
        }

        public void setDispatchQueue(Object dispatchQueue) {
            this.dispatchQueue = dispatchQueue;
        }

        public String getHost() {
            return host;
        }

        public void setHost(String host) {
            this.host = host;
        }

        public short getKeepAlive() {
            return keepAlive;
        }

        public void setKeepAlive(short keepAlive) {
            this.keepAlive = keepAlive;
        }

        public URI getLocalAddress() {
            return localAddress;
        }

        public void setLocalAddress(URI localAddress) {
            this.localAddress = localAddress;
        }

        public int getMaxReadRate() {
            return maxReadRate;
        }

        public void setMaxReadRate(int maxReadRate) {
            this.maxReadRate = maxReadRate;
        }

        public int getMaxWriteRate() {
            return maxWriteRate;
        }

        public void setMaxWriteRate(int maxWriteRate) {
            this.maxWriteRate = maxWriteRate;
        }

        public String getMqttQosPropertyName() {
            return mqttQosPropertyName;
        }

        public void setMqttQosPropertyName(String mqttQosPropertyName) {
            this.mqttQosPropertyName = mqttQosPropertyName;
        }

        public String getMqttRetainPropertyName() {
            return mqttRetainPropertyName;
        }

        public void setMqttRetainPropertyName(String mqttRetainPropertyName) {
            this.mqttRetainPropertyName = mqttRetainPropertyName;
        }

        public String getMqttTopicPropertyName() {
            return mqttTopicPropertyName;
        }

        public void setMqttTopicPropertyName(String mqttTopicPropertyName) {
            this.mqttTopicPropertyName = mqttTopicPropertyName;
        }

        public String getPublishTopicName() {
            return publishTopicName;
        }

        public void setPublishTopicName(String publishTopicName) {
            this.publishTopicName = publishTopicName;
        }

        public String getQualityOfService() {
            return qualityOfService;
        }

        public void setQualityOfService(String qualityOfService) {
            this.qualityOfService = qualityOfService;
        }

        public int getReceiveBufferSize() {
            return receiveBufferSize;
        }

        public void setReceiveBufferSize(int receiveBufferSize) {
            this.receiveBufferSize = receiveBufferSize;
        }

        public long getReconnectAttemptsMax() {
            return reconnectAttemptsMax;
        }

        public void setReconnectAttemptsMax(long reconnectAttemptsMax) {
            this.reconnectAttemptsMax = reconnectAttemptsMax;
        }

        public double getReconnectBackOffMultiplier() {
            return reconnectBackOffMultiplier;
        }

        public void setReconnectBackOffMultiplier(
                double reconnectBackOffMultiplier) {
            this.reconnectBackOffMultiplier = reconnectBackOffMultiplier;
        }

        public long getReconnectDelay() {
            return reconnectDelay;
        }

        public void setReconnectDelay(long reconnectDelay) {
            this.reconnectDelay = reconnectDelay;
        }

        public long getReconnectDelayMax() {
            return reconnectDelayMax;
        }

        public void setReconnectDelayMax(long reconnectDelayMax) {
            this.reconnectDelayMax = reconnectDelayMax;
        }

        public int getSendBufferSize() {
            return sendBufferSize;
        }

        public void setSendBufferSize(int sendBufferSize) {
            this.sendBufferSize = sendBufferSize;
        }

        public int getSendWaitInSeconds() {
            return sendWaitInSeconds;
        }

        public void setSendWaitInSeconds(int sendWaitInSeconds) {
            this.sendWaitInSeconds = sendWaitInSeconds;
        }

        public Object getSslContext() {
            return sslContext;
        }

        public void setSslContext(Object sslContext) {
            this.sslContext = sslContext;
        }

        @Deprecated
        public String getSubscribeTopicName() {
            return subscribeTopicName;
        }

        @Deprecated
        public void setSubscribeTopicName(String subscribeTopicName) {
            this.subscribeTopicName = subscribeTopicName;
        }

        public String getSubscribeTopicNames() {
            return subscribeTopicNames;
        }

        public void setSubscribeTopicNames(String subscribeTopicNames) {
            this.subscribeTopicNames = subscribeTopicNames;
        }

        public int getTrafficClass() {
            return trafficClass;
        }

        public void setTrafficClass(int trafficClass) {
            this.trafficClass = trafficClass;
        }

        public String getVersion() {
            return version;
        }

        public void setVersion(String version) {
            this.version = version;
        }

        public String getWillMessage() {
            return willMessage;
        }

        public void setWillMessage(String willMessage) {
            this.willMessage = willMessage;
        }

        public QoS getWillQos() {
            return willQos;
        }

        public void setWillQos(QoS willQos) {
            this.willQos = willQos;
        }

        public QoS getWillRetain() {
            return willRetain;
        }

        public void setWillRetain(QoS willRetain) {
            this.willRetain = willRetain;
        }

        public String getWillTopic() {
            return willTopic;
        }

        public void setWillTopic(String willTopic) {
            this.willTopic = willTopic;
        }

        public boolean getBasicPropertyBinding() {
            return basicPropertyBinding;
        }

        public void setBasicPropertyBinding(boolean basicPropertyBinding) {
            this.basicPropertyBinding = basicPropertyBinding;
        }

        public boolean getSynchronous() {
            return synchronous;
        }

        public void setSynchronous(boolean synchronous) {
            this.synchronous = synchronous;
        }
    }

    public static class MQTTConsumer extends MQTTCommon {
        /**
         * Allows for bridging the consumer to the Camel routing Error Handler,
         * which mean any exceptions occurred while the consumer is trying to
         * pickup incoming messages, or the likes, will now be processed as a
         * message and handled by the routing Error Handler. By default the
         * consumer will use the org.apache.camel.spi.ExceptionHandler to deal
         * with exceptions, that will be logged at WARN or ERROR level and
         * ignored. The option is a boolean type.
         */
        private boolean bridgeErrorHandler;
        /**
         * To let the consumer use a custom ExceptionHandler. Notice if the
         * option bridgeErrorHandler is enabled then this option is not in use.
         * By default the consumer will deal with exceptions, that will be
         * logged at WARN or ERROR level and ignored. The option is a
         * org.apache.camel.spi.ExceptionHandler type.
         */
        private ExceptionHandler exceptionHandler;
        /**
         * Sets the exchange pattern when the consumer creates an exchange. The
         * option is a org.apache.camel.ExchangePattern type.
         */
        private ExchangePattern exchangePattern;

        public boolean getBridgeErrorHandler() {
            return bridgeErrorHandler;
        }

        public void setBridgeErrorHandler(boolean bridgeErrorHandler) {
            this.bridgeErrorHandler = bridgeErrorHandler;
        }

        public ExceptionHandler getExceptionHandler() {
            return exceptionHandler;
        }

        public void setExceptionHandler(ExceptionHandler exceptionHandler) {
            this.exceptionHandler = exceptionHandler;
        }

        public ExchangePattern getExchangePattern() {
            return exchangePattern;
        }

        public void setExchangePattern(ExchangePattern exchangePattern) {
            this.exchangePattern = exchangePattern;
        }
    }

    public static class MQTTProducer extends MQTTCommon {
        /**
         * Sessions can be lazily created to avoid exceptions, if the remote
         * server is not up and running when the Camel producer is started. The
         * option is a boolean type.
         */
        private boolean lazySessionCreation;

        public boolean getLazySessionCreation() {
            return lazySessionCreation;
        }

        public void setLazySessionCreation(boolean lazySessionCreation) {
            this.lazySessionCreation = lazySessionCreation;
        }
    }

    public static enum QoS {
        AtMostOnce, AtLeastOnce, ExactlyOnce;
    }
}