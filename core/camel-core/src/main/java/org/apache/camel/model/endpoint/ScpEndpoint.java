/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.endpoint;

import javax.annotation.Generated;
import org.apache.camel.Expression;

/**
 * To copy files using the secure copy protocol (SCP).
 * 
 * Generated by camel-package-maven-plugin - do not edit this file!
 */
@Generated("org.apache.camel.maven.packaging.EndpointDslMojo")
public class ScpEndpoint {


    public static class ScpCommon extends EndpointConfiguration {
        /**
         * Hostname of the FTP server. The option is a java.lang.String type.
         */
        private String host;
        /**
         * Port of the FTP server. The option is a int type.
         */
        private Integer port;
        /**
         * The starting directory. The option is a java.lang.String type.
         */
        private String directoryName;
        /**
         * Whether or not to disconnect from remote FTP server right after use.
         * Disconnect will only disconnect the current connection to the FTP
         * server. If you have a consumer which you want to stop, then you need
         * to stop the consumer/route instead. The option is a boolean type.
         */
        private Boolean disconnect;
        /**
         * Allows you to set chmod on the stored file. For example chmod=664.
         * The option is a java.lang.String type.
         */
        private String chmod;
        /**
         * Use Expression such as File Language to dynamically set the filename.
         * For consumers, it's used as a filename filter. For producers, it's
         * used to evaluate the filename to write. If an expression is set, it
         * take precedence over the CamelFileName header. (Note: The header
         * itself can also be an Expression). The expression options support
         * both String and Expression types. If the expression is a String type,
         * it is always evaluated using the File Language. If the expression is
         * an Expression type, the specified Expression type is used - this
         * allows you, for instance, to use OGNL expressions. For the consumer,
         * you can use it to filter filenames, so you can for instance consume
         * today's file using the File Language syntax:
         * mydata-${date:now:yyyyMMdd}.txt. The producers support the
         * CamelOverruleFileName header which takes precedence over any existing
         * CamelFileName header; the CamelOverruleFileName is a header that is
         * used only once, and makes it easier as this avoids to temporary store
         * CamelFileName and have to restore it afterwards. The option is a
         * java.lang.String type.
         */
        private Expression fileName;
        /**
         * Sets whether to use strict host key checking. Possible values are:
         * no, yes. The option is a java.lang.String type.
         */
        private String strictHostKeyChecking;
        /**
         * Whether the endpoint should use basic property binding (Camel 2.x) or
         * the newer property binding with additional capabilities. The option
         * is a boolean type.
         */
        private Boolean basicPropertyBinding;
        /**
         * Sets the connect timeout for waiting for a connection to be
         * established Used by both FTPClient and JSCH. The option is a int
         * type.
         */
        private Integer connectTimeout;
        /**
         * Sets the so timeout FTP and FTPS Only for Camel 2.4. SFTP for Camel
         * 2.14.3/2.15.3/2.16 onwards. Is the SocketOptions.SO_TIMEOUT value in
         * millis. Recommended option is to set this to 300000 so as not have a
         * hanged connection. On SFTP this option is set as timeout on the JSCH
         * Session instance. The option is a int type.
         */
        private Integer soTimeout;
        /**
         * Sets whether synchronous processing should be strictly used, or Camel
         * is allowed to use asynchronous processing (if supported). The option
         * is a boolean type.
         */
        private Boolean synchronous;
        /**
         * Sets the data timeout for waiting for reply Used only by FTPClient.
         * The option is a int type.
         */
        private Integer timeout;
        /**
         * Sets the known_hosts file, so that the jsch endpoint can do host key
         * verification. You can prefix with classpath: to load the file from
         * classpath instead of file system. The option is a java.lang.String
         * type.
         */
        private String knownHostsFile;
        /**
         * Password to use for login. The option is a java.lang.String type.
         */
        private String password;
        /**
         * Set a comma separated list of authentications that will be used in
         * order of preference. Possible authentication methods are defined by
         * JCraft JSCH. Some examples include:
         * gssapi-with-mic,publickey,keyboard-interactive,password If not
         * specified the JSCH and/or system defaults will be used. The option is
         * a java.lang.String type.
         */
        private String preferredAuthentications;
        /**
         * Set the private key bytes to that the endpoint can do private key
         * verification. This must be used only if privateKeyFile wasn't set.
         * Otherwise the file will have the priority. The option is a byte[]
         * type.
         */
        private Byte[] privateKeyBytes;
        /**
         * Set the private key file to that the endpoint can do private key
         * verification. You can prefix with classpath: to load the file from
         * classpath instead of file system. The option is a java.lang.String
         * type.
         */
        private String privateKeyFile;
        /**
         * Set the private key file passphrase to that the endpoint can do
         * private key verification. The option is a java.lang.String type.
         */
        private String privateKeyFilePassphrase;
        /**
         * Username to use for login. The option is a java.lang.String type.
         */
        private String username;
        /**
         * If knownHostFile has not been explicit configured, then use the host
         * file from System.getProperty(user.home) /.ssh/known_hosts. The option
         * is a boolean type.
         */
        private Boolean useUserKnownHostsFile;
        /**
         * Set a comma separated list of ciphers that will be used in order of
         * preference. Possible cipher names are defined by JCraft JSCH. Some
         * examples include:
         * aes128-ctr,aes128-cbc,3des-ctr,3des-cbc,blowfish-cbc,aes192-cbc,aes256-cbc. If not specified the default list from JSCH will be used. The option is a java.lang.String type.
         */
        private String ciphers;

        public String getHost() {
            return host;
        }

        public void setHost(String host) {
            this.host = host;
        }

        public Integer getPort() {
            return port;
        }

        public void setPort(Integer port) {
            this.port = port;
        }

        public String getDirectoryName() {
            return directoryName;
        }

        public void setDirectoryName(String directoryName) {
            this.directoryName = directoryName;
        }

        public Boolean getDisconnect() {
            return disconnect;
        }

        public void setDisconnect(Boolean disconnect) {
            this.disconnect = disconnect;
        }

        public String getChmod() {
            return chmod;
        }

        public void setChmod(String chmod) {
            this.chmod = chmod;
        }

        public Expression getFileName() {
            return fileName;
        }

        public void setFileName(Expression fileName) {
            this.fileName = fileName;
        }

        public String getStrictHostKeyChecking() {
            return strictHostKeyChecking;
        }

        public void setStrictHostKeyChecking(String strictHostKeyChecking) {
            this.strictHostKeyChecking = strictHostKeyChecking;
        }

        public Boolean getBasicPropertyBinding() {
            return basicPropertyBinding;
        }

        public void setBasicPropertyBinding(Boolean basicPropertyBinding) {
            this.basicPropertyBinding = basicPropertyBinding;
        }

        public Integer getConnectTimeout() {
            return connectTimeout;
        }

        public void setConnectTimeout(Integer connectTimeout) {
            this.connectTimeout = connectTimeout;
        }

        public Integer getSoTimeout() {
            return soTimeout;
        }

        public void setSoTimeout(Integer soTimeout) {
            this.soTimeout = soTimeout;
        }

        public Boolean getSynchronous() {
            return synchronous;
        }

        public void setSynchronous(Boolean synchronous) {
            this.synchronous = synchronous;
        }

        public Integer getTimeout() {
            return timeout;
        }

        public void setTimeout(Integer timeout) {
            this.timeout = timeout;
        }

        public String getKnownHostsFile() {
            return knownHostsFile;
        }

        public void setKnownHostsFile(String knownHostsFile) {
            this.knownHostsFile = knownHostsFile;
        }

        public String getPassword() {
            return password;
        }

        public void setPassword(String password) {
            this.password = password;
        }

        public String getPreferredAuthentications() {
            return preferredAuthentications;
        }

        public void setPreferredAuthentications(String preferredAuthentications) {
            this.preferredAuthentications = preferredAuthentications;
        }

        public Byte[] getPrivateKeyBytes() {
            return privateKeyBytes;
        }

        public void setPrivateKeyBytes(Byte[] privateKeyBytes) {
            this.privateKeyBytes = privateKeyBytes;
        }

        public String getPrivateKeyFile() {
            return privateKeyFile;
        }

        public void setPrivateKeyFile(String privateKeyFile) {
            this.privateKeyFile = privateKeyFile;
        }

        public String getPrivateKeyFilePassphrase() {
            return privateKeyFilePassphrase;
        }

        public void setPrivateKeyFilePassphrase(String privateKeyFilePassphrase) {
            this.privateKeyFilePassphrase = privateKeyFilePassphrase;
        }

        public String getUsername() {
            return username;
        }

        public void setUsername(String username) {
            this.username = username;
        }

        public Boolean getUseUserKnownHostsFile() {
            return useUserKnownHostsFile;
        }

        public void setUseUserKnownHostsFile(Boolean useUserKnownHostsFile) {
            this.useUserKnownHostsFile = useUserKnownHostsFile;
        }

        public String getCiphers() {
            return ciphers;
        }

        public void setCiphers(String ciphers) {
            this.ciphers = ciphers;
        }
    }

    public static class ScpConsumer extends ScpCommon {
    }

    public static class ScpProducer extends ScpCommon {
        /**
         * Flatten is used to flatten the file name path to strip any leading
         * paths, so it's just the file name. This allows you to consume
         * recursively into sub-directories, but when you eg write the files to
         * another directory they will be written in a single directory. Setting
         * this to true on the producer enforces that any file name in
         * CamelFileName header will be stripped for any leading paths. The
         * option is a boolean type.
         */
        private Boolean flatten;
        /**
         * Used for jailing (restricting) writing files to the starting
         * directory (and sub) only. This is enabled by default to not allow
         * Camel to write files to outside directories (to be more secured out
         * of the box). You can turn this off to allow writing files to
         * directories outside the starting directory, such as parent or root
         * folders. The option is a boolean type.
         */
        private Boolean jailStartingDirectory;
        /**
         * Used to specify if a null body is allowed during file writing. If set
         * to true then an empty file will be created, when set to false, and
         * attempting to send a null body to the file component, a
         * GenericFileWriteException of 'Cannot write null body to file.' will
         * be thrown. If the fileExist option is set to 'Override', then the
         * file will be truncated, and if set to append the file will remain
         * unchanged. The option is a boolean type.
         */
        private Boolean allowNullBody;
        /**
         * Whether or not to disconnect from remote FTP server right after a
         * Batch upload is complete. disconnectOnBatchComplete will only
         * disconnect the current connection to the FTP server. The option is a
         * boolean type.
         */
        private Boolean disconnectOnBatchComplete;
        /**
         * Strategy (Custom Strategy) used to move file with special naming
         * token to use when fileExist=Move is configured. By default, there is
         * an implementation used if no custom strategy is provided. The option
         * is a
         * org.apache.camel.component.file.strategy.FileMoveExistingStrategy
         * type.
         */
        private Object moveExistingFileStrategy;

        public Boolean getFlatten() {
            return flatten;
        }

        public void setFlatten(Boolean flatten) {
            this.flatten = flatten;
        }

        public Boolean getJailStartingDirectory() {
            return jailStartingDirectory;
        }

        public void setJailStartingDirectory(Boolean jailStartingDirectory) {
            this.jailStartingDirectory = jailStartingDirectory;
        }

        public Boolean getAllowNullBody() {
            return allowNullBody;
        }

        public void setAllowNullBody(Boolean allowNullBody) {
            this.allowNullBody = allowNullBody;
        }

        public Boolean getDisconnectOnBatchComplete() {
            return disconnectOnBatchComplete;
        }

        public void setDisconnectOnBatchComplete(
                Boolean disconnectOnBatchComplete) {
            this.disconnectOnBatchComplete = disconnectOnBatchComplete;
        }

        public Object getMoveExistingFileStrategy() {
            return moveExistingFileStrategy;
        }

        public void setMoveExistingFileStrategy(Object moveExistingFileStrategy) {
            this.moveExistingFileStrategy = moveExistingFileStrategy;
        }
    }
}