/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.endpoint;

import java.util.Map;
import javax.annotation.Generated;
import org.apache.camel.ExchangePattern;
import org.apache.camel.spi.ExceptionHandler;

/**
 * The rabbitmq component allows you produce and consume messages from RabbitMQ
 * instances.
 * 
 * Generated by camel-package-maven-plugin - do not edit this file!
 */
@Generated("org.apache.camel.maven.packaging.EndpointDslMojo")
public class RabbitMQEndpoint {


    public static class RabbitMQCommon extends EndpointConfiguration {
        /**
         * The exchange name determines which exchange produced messages will
         * sent to. In the case of consumers, the exchange name determines which
         * exchange the queue will bind to. The option is a java.lang.String
         * type.
         */
        private String exchangeName;
        /**
         * If this option is set, camel-rabbitmq will try to create connection
         * based on the setting of option addresses. The addresses value is a
         * string which looks like server1:12345, server2:12345. The option is a
         * com.rabbitmq.client.Address[] type.
         */
        private Object[] addresses;
        /**
         * If it is true, the exchange will be deleted when it is no longer in
         * use. The option is a boolean type.
         */
        private boolean autoDelete;
        /**
         * To use a custom RabbitMQ connection factory. When this option is set,
         * all connection options (connectionTimeout, requestedChannelMax...)
         * set on URI are not used. The option is a
         * com.rabbitmq.client.ConnectionFactory type.
         */
        private Object connectionFactory;
        /**
         * The name of the dead letter exchange. The option is a
         * java.lang.String type.
         */
        private String deadLetterExchange;
        /**
         * The type of the dead letter exchange. The option is a
         * java.lang.String type.
         */
        private String deadLetterExchangeType;
        /**
         * The name of the dead letter queue. The option is a java.lang.String
         * type.
         */
        private String deadLetterQueue;
        /**
         * The routing key for the dead letter exchange. The option is a
         * java.lang.String type.
         */
        private String deadLetterRoutingKey;
        /**
         * If the option is true, camel declare the exchange and queue name and
         * bind them together. If the option is false, camel won't declare the
         * exchange and queue name on the server. The option is a boolean type.
         */
        private boolean declare;
        /**
         * If we are declaring a durable exchange (the exchange will survive a
         * server restart). The option is a boolean type.
         */
        private boolean durable;
        /**
         * The exchange type such as direct or topic. The option is a
         * java.lang.String type.
         */
        private String exchangeType;
        /**
         * Exclusive queues may only be accessed by the current connection, and
         * are deleted when that connection closes. The option is a boolean
         * type.
         */
        private boolean exclusive;
        /**
         * The hostname of the running rabbitmq instance or cluster. The option
         * is a java.lang.String type.
         */
        private String hostname;
        /**
         * Passive queues depend on the queue already to be available at
         * RabbitMQ. The option is a boolean type.
         */
        private boolean passive;
        /**
         * Port number for the host with the running rabbitmq instance or
         * cluster. Default value is 5672. The option is a int type.
         */
        private int portNumber;
        /**
         * The queue to receive messages from. The option is a java.lang.String
         * type.
         */
        private String queue;
        /**
         * The routing key to use when binding a consumer queue to the exchange.
         * For producer routing keys, you set the header rabbitmq.ROUTING_KEY.
         * The option is a java.lang.String type.
         */
        private String routingKey;
        /**
         * This can be used if we need to declare the queue but not the
         * exchange. The option is a boolean type.
         */
        private boolean skipExchangeDeclare;
        /**
         * If true the queue will not be bound to the exchange after declaring
         * it. The option is a boolean type.
         */
        private boolean skipQueueBind;
        /**
         * If true the producer will not declare and bind a queue. This can be
         * used for directing messages via an existing routing key. The option
         * is a boolean type.
         */
        private boolean skipQueueDeclare;
        /**
         * The vhost for the channel. The option is a java.lang.String type.
         */
        private String vhost;
        /**
         * Specify arguments for configuring the different RabbitMQ concepts, a
         * different prefix is required for each: Exchange: arg.exchange. Queue:
         * arg.queue. Binding: arg.binding. For example to declare a queue with
         * message ttl argument:
         * http://localhost:5672/exchange/queueargs=arg.queue.x-message-ttl=60000. The option is a java.util.Map<java.lang.String,java.lang.Object> type.
         */
        private Map<String, Object> args;
        /**
         * Enables connection automatic recovery (uses connection implementation
         * that performs automatic recovery when connection shutdown is not
         * initiated by the application). The option is a java.lang.Boolean
         * type.
         */
        private Boolean automaticRecoveryEnabled;
        /**
         * Whether the endpoint should use basic property binding (Camel 2.x) or
         * the newer property binding with additional capabilities. The option
         * is a boolean type.
         */
        private boolean basicPropertyBinding;
        /**
         * Connection client properties (client info used in negotiating with
         * the server). The option is a
         * java.util.Map<java.lang.String,java.lang.Object> type.
         */
        private Map<String, Object> clientProperties;
        /**
         * Connection timeout. The option is a int type.
         */
        private int connectionTimeout;
        /**
         * Network recovery interval in milliseconds (interval used when
         * recovering from network failure). The option is a java.lang.Integer
         * type.
         */
        private Integer networkRecoveryInterval;
        /**
         * Connection requested channel max (max number of channels offered).
         * The option is a int type.
         */
        private int requestedChannelMax;
        /**
         * Connection requested frame max (max size of frame offered). The
         * option is a int type.
         */
        private int requestedFrameMax;
        /**
         * Connection requested heartbeat (heart-beat in seconds offered). The
         * option is a int type.
         */
        private int requestedHeartbeat;
        /**
         * Set timeout for waiting for a reply when using the InOut Exchange
         * Pattern (in milliseconds). The option is a long type.
         */
        private long requestTimeout;
        /**
         * Set requestTimeoutCheckerInterval for inOut exchange. The option is a
         * long type.
         */
        private long requestTimeoutCheckerInterval;
        /**
         * Sets whether synchronous processing should be strictly used, or Camel
         * is allowed to use asynchronous processing (if supported). The option
         * is a boolean type.
         */
        private boolean synchronous;
        /**
         * Enables connection topology recovery (should topology recovery be
         * performed). The option is a java.lang.Boolean type.
         */
        private Boolean topologyRecoveryEnabled;
        /**
         * When true and an inOut Exchange failed on the consumer side send the
         * caused Exception back in the response. The option is a boolean type.
         */
        private boolean transferException;
        /**
         * Password for authenticated access. The option is a java.lang.String
         * type.
         */
        private String password;
        /**
         * Enables SSL on connection, accepted value are true, TLS and 'SSLv3.
         * The option is a java.lang.String type.
         */
        private String sslProtocol;
        /**
         * Configure SSL trust manager, SSL should be enabled for this option to
         * be effective. The option is a javax.net.ssl.TrustManager type.
         */
        private Object trustManager;
        /**
         * Username in case of authenticated access. The option is a
         * java.lang.String type.
         */
        private String username;

        public String getExchangeName() {
            return exchangeName;
        }

        public void setExchangeName(String exchangeName) {
            this.exchangeName = exchangeName;
        }

        public Object[] getAddresses() {
            return addresses;
        }

        public void setAddresses(Object[] addresses) {
            this.addresses = addresses;
        }

        public boolean getAutoDelete() {
            return autoDelete;
        }

        public void setAutoDelete(boolean autoDelete) {
            this.autoDelete = autoDelete;
        }

        public Object getConnectionFactory() {
            return connectionFactory;
        }

        public void setConnectionFactory(Object connectionFactory) {
            this.connectionFactory = connectionFactory;
        }

        public String getDeadLetterExchange() {
            return deadLetterExchange;
        }

        public void setDeadLetterExchange(String deadLetterExchange) {
            this.deadLetterExchange = deadLetterExchange;
        }

        public String getDeadLetterExchangeType() {
            return deadLetterExchangeType;
        }

        public void setDeadLetterExchangeType(String deadLetterExchangeType) {
            this.deadLetterExchangeType = deadLetterExchangeType;
        }

        public String getDeadLetterQueue() {
            return deadLetterQueue;
        }

        public void setDeadLetterQueue(String deadLetterQueue) {
            this.deadLetterQueue = deadLetterQueue;
        }

        public String getDeadLetterRoutingKey() {
            return deadLetterRoutingKey;
        }

        public void setDeadLetterRoutingKey(String deadLetterRoutingKey) {
            this.deadLetterRoutingKey = deadLetterRoutingKey;
        }

        public boolean getDeclare() {
            return declare;
        }

        public void setDeclare(boolean declare) {
            this.declare = declare;
        }

        public boolean getDurable() {
            return durable;
        }

        public void setDurable(boolean durable) {
            this.durable = durable;
        }

        public String getExchangeType() {
            return exchangeType;
        }

        public void setExchangeType(String exchangeType) {
            this.exchangeType = exchangeType;
        }

        public boolean getExclusive() {
            return exclusive;
        }

        public void setExclusive(boolean exclusive) {
            this.exclusive = exclusive;
        }

        public String getHostname() {
            return hostname;
        }

        public void setHostname(String hostname) {
            this.hostname = hostname;
        }

        public boolean getPassive() {
            return passive;
        }

        public void setPassive(boolean passive) {
            this.passive = passive;
        }

        public int getPortNumber() {
            return portNumber;
        }

        public void setPortNumber(int portNumber) {
            this.portNumber = portNumber;
        }

        public String getQueue() {
            return queue;
        }

        public void setQueue(String queue) {
            this.queue = queue;
        }

        public String getRoutingKey() {
            return routingKey;
        }

        public void setRoutingKey(String routingKey) {
            this.routingKey = routingKey;
        }

        public boolean getSkipExchangeDeclare() {
            return skipExchangeDeclare;
        }

        public void setSkipExchangeDeclare(boolean skipExchangeDeclare) {
            this.skipExchangeDeclare = skipExchangeDeclare;
        }

        public boolean getSkipQueueBind() {
            return skipQueueBind;
        }

        public void setSkipQueueBind(boolean skipQueueBind) {
            this.skipQueueBind = skipQueueBind;
        }

        public boolean getSkipQueueDeclare() {
            return skipQueueDeclare;
        }

        public void setSkipQueueDeclare(boolean skipQueueDeclare) {
            this.skipQueueDeclare = skipQueueDeclare;
        }

        public String getVhost() {
            return vhost;
        }

        public void setVhost(String vhost) {
            this.vhost = vhost;
        }

        public Map<String, Object> getArgs() {
            return args;
        }

        public void setArgs(Map<String, Object> args) {
            this.args = args;
        }

        public Boolean getAutomaticRecoveryEnabled() {
            return automaticRecoveryEnabled;
        }

        public void setAutomaticRecoveryEnabled(Boolean automaticRecoveryEnabled) {
            this.automaticRecoveryEnabled = automaticRecoveryEnabled;
        }

        public boolean getBasicPropertyBinding() {
            return basicPropertyBinding;
        }

        public void setBasicPropertyBinding(boolean basicPropertyBinding) {
            this.basicPropertyBinding = basicPropertyBinding;
        }

        public Map<String, Object> getClientProperties() {
            return clientProperties;
        }

        public void setClientProperties(Map<String, Object> clientProperties) {
            this.clientProperties = clientProperties;
        }

        public int getConnectionTimeout() {
            return connectionTimeout;
        }

        public void setConnectionTimeout(int connectionTimeout) {
            this.connectionTimeout = connectionTimeout;
        }

        public Integer getNetworkRecoveryInterval() {
            return networkRecoveryInterval;
        }

        public void setNetworkRecoveryInterval(Integer networkRecoveryInterval) {
            this.networkRecoveryInterval = networkRecoveryInterval;
        }

        public int getRequestedChannelMax() {
            return requestedChannelMax;
        }

        public void setRequestedChannelMax(int requestedChannelMax) {
            this.requestedChannelMax = requestedChannelMax;
        }

        public int getRequestedFrameMax() {
            return requestedFrameMax;
        }

        public void setRequestedFrameMax(int requestedFrameMax) {
            this.requestedFrameMax = requestedFrameMax;
        }

        public int getRequestedHeartbeat() {
            return requestedHeartbeat;
        }

        public void setRequestedHeartbeat(int requestedHeartbeat) {
            this.requestedHeartbeat = requestedHeartbeat;
        }

        public long getRequestTimeout() {
            return requestTimeout;
        }

        public void setRequestTimeout(long requestTimeout) {
            this.requestTimeout = requestTimeout;
        }

        public long getRequestTimeoutCheckerInterval() {
            return requestTimeoutCheckerInterval;
        }

        public void setRequestTimeoutCheckerInterval(
                long requestTimeoutCheckerInterval) {
            this.requestTimeoutCheckerInterval = requestTimeoutCheckerInterval;
        }

        public boolean getSynchronous() {
            return synchronous;
        }

        public void setSynchronous(boolean synchronous) {
            this.synchronous = synchronous;
        }

        public Boolean getTopologyRecoveryEnabled() {
            return topologyRecoveryEnabled;
        }

        public void setTopologyRecoveryEnabled(Boolean topologyRecoveryEnabled) {
            this.topologyRecoveryEnabled = topologyRecoveryEnabled;
        }

        public boolean getTransferException() {
            return transferException;
        }

        public void setTransferException(boolean transferException) {
            this.transferException = transferException;
        }

        public String getPassword() {
            return password;
        }

        public void setPassword(String password) {
            this.password = password;
        }

        public String getSslProtocol() {
            return sslProtocol;
        }

        public void setSslProtocol(String sslProtocol) {
            this.sslProtocol = sslProtocol;
        }

        public Object getTrustManager() {
            return trustManager;
        }

        public void setTrustManager(Object trustManager) {
            this.trustManager = trustManager;
        }

        public String getUsername() {
            return username;
        }

        public void setUsername(String username) {
            this.username = username;
        }
    }

    public static class RabbitMQConsumer extends RabbitMQCommon {
        /**
         * If messages should be auto acknowledged. The option is a boolean
         * type.
         */
        private boolean autoAck;
        /**
         * Allows for bridging the consumer to the Camel routing Error Handler,
         * which mean any exceptions occurred while the consumer is trying to
         * pickup incoming messages, or the likes, will now be processed as a
         * message and handled by the routing Error Handler. By default the
         * consumer will use the org.apache.camel.spi.ExceptionHandler to deal
         * with exceptions, that will be logged at WARN or ERROR level and
         * ignored. The option is a boolean type.
         */
        private boolean bridgeErrorHandler;
        /**
         * Number of concurrent consumers when consuming from broker. (eg
         * similar as to the same option for the JMS component). The option is a
         * int type.
         */
        private int concurrentConsumers;
        /**
         * Request exclusive access to the queue (meaning only this consumer can
         * access the queue). This is useful when you want a long-lived shared
         * queue to be temporarily accessible by just one consumer. The option
         * is a boolean type.
         */
        private boolean exclusiveConsumer;
        /**
         * The maximum number of messages that the server will deliver, 0 if
         * unlimited. You need to specify the option of prefetchSize,
         * prefetchCount, prefetchGlobal at the same time. The option is a int
         * type.
         */
        private int prefetchCount;
        /**
         * Enables the quality of service on the RabbitMQConsumer side. You need
         * to specify the option of prefetchSize, prefetchCount, prefetchGlobal
         * at the same time. The option is a boolean type.
         */
        private boolean prefetchEnabled;
        /**
         * If the settings should be applied to the entire channel rather than
         * each consumer You need to specify the option of prefetchSize,
         * prefetchCount, prefetchGlobal at the same time. The option is a
         * boolean type.
         */
        private boolean prefetchGlobal;
        /**
         * The maximum amount of content (measured in octets) that the server
         * will deliver, 0 if unlimited. You need to specify the option of
         * prefetchSize, prefetchCount, prefetchGlobal at the same time. The
         * option is a int type.
         */
        private int prefetchSize;
        /**
         * To let the consumer use a custom ExceptionHandler. Notice if the
         * option bridgeErrorHandler is enabled then this option is not in use.
         * By default the consumer will deal with exceptions, that will be
         * logged at WARN or ERROR level and ignored. The option is a
         * org.apache.camel.spi.ExceptionHandler type.
         */
        private ExceptionHandler exceptionHandler;
        /**
         * Sets the exchange pattern when the consumer creates an exchange. The
         * option is a org.apache.camel.ExchangePattern type.
         */
        private ExchangePattern exchangePattern;
        /**
         * The consumer uses a Thread Pool Executor with a fixed number of
         * threads. This setting allows you to set that number of threads. The
         * option is a int type.
         */
        private int threadPoolSize;

        public boolean getAutoAck() {
            return autoAck;
        }

        public void setAutoAck(boolean autoAck) {
            this.autoAck = autoAck;
        }

        public boolean getBridgeErrorHandler() {
            return bridgeErrorHandler;
        }

        public void setBridgeErrorHandler(boolean bridgeErrorHandler) {
            this.bridgeErrorHandler = bridgeErrorHandler;
        }

        public int getConcurrentConsumers() {
            return concurrentConsumers;
        }

        public void setConcurrentConsumers(int concurrentConsumers) {
            this.concurrentConsumers = concurrentConsumers;
        }

        public boolean getExclusiveConsumer() {
            return exclusiveConsumer;
        }

        public void setExclusiveConsumer(boolean exclusiveConsumer) {
            this.exclusiveConsumer = exclusiveConsumer;
        }

        public int getPrefetchCount() {
            return prefetchCount;
        }

        public void setPrefetchCount(int prefetchCount) {
            this.prefetchCount = prefetchCount;
        }

        public boolean getPrefetchEnabled() {
            return prefetchEnabled;
        }

        public void setPrefetchEnabled(boolean prefetchEnabled) {
            this.prefetchEnabled = prefetchEnabled;
        }

        public boolean getPrefetchGlobal() {
            return prefetchGlobal;
        }

        public void setPrefetchGlobal(boolean prefetchGlobal) {
            this.prefetchGlobal = prefetchGlobal;
        }

        public int getPrefetchSize() {
            return prefetchSize;
        }

        public void setPrefetchSize(int prefetchSize) {
            this.prefetchSize = prefetchSize;
        }

        public ExceptionHandler getExceptionHandler() {
            return exceptionHandler;
        }

        public void setExceptionHandler(ExceptionHandler exceptionHandler) {
            this.exceptionHandler = exceptionHandler;
        }

        public ExchangePattern getExchangePattern() {
            return exchangePattern;
        }

        public void setExchangePattern(ExchangePattern exchangePattern) {
            this.exchangePattern = exchangePattern;
        }

        public int getThreadPoolSize() {
            return threadPoolSize;
        }

        public void setThreadPoolSize(int threadPoolSize) {
            this.threadPoolSize = threadPoolSize;
        }
    }

    public static class RabbitMQProducer extends RabbitMQCommon {
        /**
         * Allow pass null values to header. The option is a boolean type.
         */
        private boolean allowNullHeaders;
        /**
         * If the bridgeEndpoint is true, the producer will ignore the message
         * header of rabbitmq.EXCHANGE_NAME and rabbitmq.ROUTING_KEY. The option
         * is a boolean type.
         */
        private boolean bridgeEndpoint;
        /**
         * Get maximum number of opened channel in pool. The option is a int
         * type.
         */
        private int channelPoolMaxSize;
        /**
         * Set the maximum number of milliseconds to wait for a channel from the
         * pool. The option is a long type.
         */
        private long channelPoolMaxWait;
        /**
         * When true, an exception will be thrown when the message cannot be
         * delivered (basic.return) and the message is marked as mandatory.
         * PublisherAcknowledgement will also be activated in this case. See
         * also publisher acknowledgements - When will messages be confirmed.
         * The option is a boolean type.
         */
        private boolean guaranteedDeliveries;
        /**
         * This flag tells the server how to react if the message cannot be
         * routed to a queue consumer immediately. If this flag is set, the
         * server will return an undeliverable message with a Return method. If
         * this flag is zero, the server will queue the message, but with no
         * guarantee that it will ever be consumed. If the header is present
         * rabbitmq.IMMEDIATE it will override this option. The option is a
         * boolean type.
         */
        private boolean immediate;
        /**
         * This flag tells the server how to react if the message cannot be
         * routed to a queue. If this flag is set, the server will return an
         * unroutable message with a Return method. If this flag is zero, the
         * server silently drops the message. If the header is present
         * rabbitmq.MANDATORY it will override this option. The option is a
         * boolean type.
         */
        private boolean mandatory;
        /**
         * When true, the message will be published with publisher
         * acknowledgements turned on. The option is a boolean type.
         */
        private boolean publisherAcknowledgements;
        /**
         * The amount of time in milliseconds to wait for a basic.ack response
         * from RabbitMQ server. The option is a long type.
         */
        private long publisherAcknowledgementsTimeout;

        public boolean getAllowNullHeaders() {
            return allowNullHeaders;
        }

        public void setAllowNullHeaders(boolean allowNullHeaders) {
            this.allowNullHeaders = allowNullHeaders;
        }

        public boolean getBridgeEndpoint() {
            return bridgeEndpoint;
        }

        public void setBridgeEndpoint(boolean bridgeEndpoint) {
            this.bridgeEndpoint = bridgeEndpoint;
        }

        public int getChannelPoolMaxSize() {
            return channelPoolMaxSize;
        }

        public void setChannelPoolMaxSize(int channelPoolMaxSize) {
            this.channelPoolMaxSize = channelPoolMaxSize;
        }

        public long getChannelPoolMaxWait() {
            return channelPoolMaxWait;
        }

        public void setChannelPoolMaxWait(long channelPoolMaxWait) {
            this.channelPoolMaxWait = channelPoolMaxWait;
        }

        public boolean getGuaranteedDeliveries() {
            return guaranteedDeliveries;
        }

        public void setGuaranteedDeliveries(boolean guaranteedDeliveries) {
            this.guaranteedDeliveries = guaranteedDeliveries;
        }

        public boolean getImmediate() {
            return immediate;
        }

        public void setImmediate(boolean immediate) {
            this.immediate = immediate;
        }

        public boolean getMandatory() {
            return mandatory;
        }

        public void setMandatory(boolean mandatory) {
            this.mandatory = mandatory;
        }

        public boolean getPublisherAcknowledgements() {
            return publisherAcknowledgements;
        }

        public void setPublisherAcknowledgements(
                boolean publisherAcknowledgements) {
            this.publisherAcknowledgements = publisherAcknowledgements;
        }

        public long getPublisherAcknowledgementsTimeout() {
            return publisherAcknowledgementsTimeout;
        }

        public void setPublisherAcknowledgementsTimeout(
                long publisherAcknowledgementsTimeout) {
            this.publisherAcknowledgementsTimeout = publisherAcknowledgementsTimeout;
        }
    }
}