/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.endpoint;

import java.util.Map;
import javax.annotation.Generated;
import org.apache.camel.ExchangePattern;
import org.apache.camel.model.EndpointDefinition;
import org.apache.camel.spi.ExceptionHandler;

/**
 * The rabbitmq component allows you produce and consume messages from RabbitMQ
 * instances.
 * 
 * Generated by camel-package-maven-plugin - do not edit this file!
 */
@Generated("org.apache.camel.maven.packaging.EndpointDslMojo")
public class RabbitMQEndpoint {


    public static class RabbitMQCommon<T extends EndpointDefinition>
            extends
                EndpointDefinition<T> {
        RabbitMQCommon(String path) {
            super("rabbitmq", path);
        }
        /**
         * The exchange name determines which exchange produced messages will
         * sent to. In the case of consumers, the exchange name determines which
         * exchange the queue will bind to. The option is a java.lang.String
         * type.
         */
        public T exchangeName(String exchangeName) {
            this.properties.put("exchangeName", exchangeName);
            return (T) this;
        }
        /**
         * If this option is set, camel-rabbitmq will try to create connection
         * based on the setting of option addresses. The addresses value is a
         * string which looks like server1:12345, server2:12345. The option is a
         * com.rabbitmq.client.Address[] type.
         */
        public T addresses(Object[] addresses) {
            this.properties.put("addresses", addresses);
            return (T) this;
        }
        /**
         * If it is true, the exchange will be deleted when it is no longer in
         * use. The option is a boolean type.
         */
        public T autoDelete(boolean autoDelete) {
            this.properties.put("autoDelete", autoDelete);
            return (T) this;
        }
        /**
         * To use a custom RabbitMQ connection factory. When this option is set,
         * all connection options (connectionTimeout, requestedChannelMax...)
         * set on URI are not used. The option is a
         * com.rabbitmq.client.ConnectionFactory type.
         */
        public T connectionFactory(Object connectionFactory) {
            this.properties.put("connectionFactory", connectionFactory);
            return (T) this;
        }
        /**
         * The name of the dead letter exchange. The option is a
         * java.lang.String type.
         */
        public T deadLetterExchange(String deadLetterExchange) {
            this.properties.put("deadLetterExchange", deadLetterExchange);
            return (T) this;
        }
        /**
         * The type of the dead letter exchange. The option is a
         * java.lang.String type.
         */
        public T deadLetterExchangeType(String deadLetterExchangeType) {
            this.properties.put("deadLetterExchangeType", deadLetterExchangeType);
            return (T) this;
        }
        /**
         * The name of the dead letter queue. The option is a java.lang.String
         * type.
         */
        public T deadLetterQueue(String deadLetterQueue) {
            this.properties.put("deadLetterQueue", deadLetterQueue);
            return (T) this;
        }
        /**
         * The routing key for the dead letter exchange. The option is a
         * java.lang.String type.
         */
        public T deadLetterRoutingKey(String deadLetterRoutingKey) {
            this.properties.put("deadLetterRoutingKey", deadLetterRoutingKey);
            return (T) this;
        }
        /**
         * If the option is true, camel declare the exchange and queue name and
         * bind them together. If the option is false, camel won't declare the
         * exchange and queue name on the server. The option is a boolean type.
         */
        public T declare(boolean declare) {
            this.properties.put("declare", declare);
            return (T) this;
        }
        /**
         * If we are declaring a durable exchange (the exchange will survive a
         * server restart). The option is a boolean type.
         */
        public T durable(boolean durable) {
            this.properties.put("durable", durable);
            return (T) this;
        }
        /**
         * The exchange type such as direct or topic. The option is a
         * java.lang.String type.
         */
        public T exchangeType(String exchangeType) {
            this.properties.put("exchangeType", exchangeType);
            return (T) this;
        }
        /**
         * Exclusive queues may only be accessed by the current connection, and
         * are deleted when that connection closes. The option is a boolean
         * type.
         */
        public T exclusive(boolean exclusive) {
            this.properties.put("exclusive", exclusive);
            return (T) this;
        }
        /**
         * The hostname of the running rabbitmq instance or cluster. The option
         * is a java.lang.String type.
         */
        public T hostname(String hostname) {
            this.properties.put("hostname", hostname);
            return (T) this;
        }
        /**
         * Passive queues depend on the queue already to be available at
         * RabbitMQ. The option is a boolean type.
         */
        public T passive(boolean passive) {
            this.properties.put("passive", passive);
            return (T) this;
        }
        /**
         * Port number for the host with the running rabbitmq instance or
         * cluster. Default value is 5672. The option is a int type.
         */
        public T portNumber(int portNumber) {
            this.properties.put("portNumber", portNumber);
            return (T) this;
        }
        /**
         * The queue to receive messages from. The option is a java.lang.String
         * type.
         */
        public T queue(String queue) {
            this.properties.put("queue", queue);
            return (T) this;
        }
        /**
         * The routing key to use when binding a consumer queue to the exchange.
         * For producer routing keys, you set the header rabbitmq.ROUTING_KEY.
         * The option is a java.lang.String type.
         */
        public T routingKey(String routingKey) {
            this.properties.put("routingKey", routingKey);
            return (T) this;
        }
        /**
         * This can be used if we need to declare the queue but not the
         * exchange. The option is a boolean type.
         */
        public T skipExchangeDeclare(boolean skipExchangeDeclare) {
            this.properties.put("skipExchangeDeclare", skipExchangeDeclare);
            return (T) this;
        }
        /**
         * If true the queue will not be bound to the exchange after declaring
         * it. The option is a boolean type.
         */
        public T skipQueueBind(boolean skipQueueBind) {
            this.properties.put("skipQueueBind", skipQueueBind);
            return (T) this;
        }
        /**
         * If true the producer will not declare and bind a queue. This can be
         * used for directing messages via an existing routing key. The option
         * is a boolean type.
         */
        public T skipQueueDeclare(boolean skipQueueDeclare) {
            this.properties.put("skipQueueDeclare", skipQueueDeclare);
            return (T) this;
        }
        /**
         * The vhost for the channel. The option is a java.lang.String type.
         */
        public T vhost(String vhost) {
            this.properties.put("vhost", vhost);
            return (T) this;
        }
        /**
         * Specify arguments for configuring the different RabbitMQ concepts, a
         * different prefix is required for each: Exchange: arg.exchange. Queue:
         * arg.queue. Binding: arg.binding. For example to declare a queue with
         * message ttl argument:
         * http://localhost:5672/exchange/queueargs=arg.queue.x-message-ttl=60000. The option is a java.util.Map<java.lang.String,java.lang.Object> type.
         */
        public T args(Map<String, Object> args) {
            this.properties.put("args", args);
            return (T) this;
        }
        /**
         * Enables connection automatic recovery (uses connection implementation
         * that performs automatic recovery when connection shutdown is not
         * initiated by the application). The option is a java.lang.Boolean
         * type.
         */
        public T automaticRecoveryEnabled(Boolean automaticRecoveryEnabled) {
            this.properties.put("automaticRecoveryEnabled", automaticRecoveryEnabled);
            return (T) this;
        }
        /**
         * Whether the endpoint should use basic property binding (Camel 2.x) or
         * the newer property binding with additional capabilities. The option
         * is a boolean type.
         */
        public T basicPropertyBinding(boolean basicPropertyBinding) {
            this.properties.put("basicPropertyBinding", basicPropertyBinding);
            return (T) this;
        }
        /**
         * Connection client properties (client info used in negotiating with
         * the server). The option is a
         * java.util.Map<java.lang.String,java.lang.Object> type.
         */
        public T clientProperties(Map<String, Object> clientProperties) {
            this.properties.put("clientProperties", clientProperties);
            return (T) this;
        }
        /**
         * Connection timeout. The option is a int type.
         */
        public T connectionTimeout(int connectionTimeout) {
            this.properties.put("connectionTimeout", connectionTimeout);
            return (T) this;
        }
        /**
         * Network recovery interval in milliseconds (interval used when
         * recovering from network failure). The option is a java.lang.Integer
         * type.
         */
        public T networkRecoveryInterval(Integer networkRecoveryInterval) {
            this.properties.put("networkRecoveryInterval", networkRecoveryInterval);
            return (T) this;
        }
        /**
         * Connection requested channel max (max number of channels offered).
         * The option is a int type.
         */
        public T requestedChannelMax(int requestedChannelMax) {
            this.properties.put("requestedChannelMax", requestedChannelMax);
            return (T) this;
        }
        /**
         * Connection requested frame max (max size of frame offered). The
         * option is a int type.
         */
        public T requestedFrameMax(int requestedFrameMax) {
            this.properties.put("requestedFrameMax", requestedFrameMax);
            return (T) this;
        }
        /**
         * Connection requested heartbeat (heart-beat in seconds offered). The
         * option is a int type.
         */
        public T requestedHeartbeat(int requestedHeartbeat) {
            this.properties.put("requestedHeartbeat", requestedHeartbeat);
            return (T) this;
        }
        /**
         * Set timeout for waiting for a reply when using the InOut Exchange
         * Pattern (in milliseconds). The option is a long type.
         */
        public T requestTimeout(long requestTimeout) {
            this.properties.put("requestTimeout", requestTimeout);
            return (T) this;
        }
        /**
         * Set requestTimeoutCheckerInterval for inOut exchange. The option is a
         * long type.
         */
        public T requestTimeoutCheckerInterval(
                long requestTimeoutCheckerInterval) {
            this.properties.put("requestTimeoutCheckerInterval", requestTimeoutCheckerInterval);
            return (T) this;
        }
        /**
         * Sets whether synchronous processing should be strictly used, or Camel
         * is allowed to use asynchronous processing (if supported). The option
         * is a boolean type.
         */
        public T synchronous(boolean synchronous) {
            this.properties.put("synchronous", synchronous);
            return (T) this;
        }
        /**
         * Enables connection topology recovery (should topology recovery be
         * performed). The option is a java.lang.Boolean type.
         */
        public T topologyRecoveryEnabled(Boolean topologyRecoveryEnabled) {
            this.properties.put("topologyRecoveryEnabled", topologyRecoveryEnabled);
            return (T) this;
        }
        /**
         * When true and an inOut Exchange failed on the consumer side send the
         * caused Exception back in the response. The option is a boolean type.
         */
        public T transferException(boolean transferException) {
            this.properties.put("transferException", transferException);
            return (T) this;
        }
        /**
         * Password for authenticated access. The option is a java.lang.String
         * type.
         */
        public T password(String password) {
            this.properties.put("password", password);
            return (T) this;
        }
        /**
         * Enables SSL on connection, accepted value are true, TLS and 'SSLv3.
         * The option is a java.lang.String type.
         */
        public T sslProtocol(String sslProtocol) {
            this.properties.put("sslProtocol", sslProtocol);
            return (T) this;
        }
        /**
         * Configure SSL trust manager, SSL should be enabled for this option to
         * be effective. The option is a javax.net.ssl.TrustManager type.
         */
        public T trustManager(Object trustManager) {
            this.properties.put("trustManager", trustManager);
            return (T) this;
        }
        /**
         * Username in case of authenticated access. The option is a
         * java.lang.String type.
         */
        public T username(String username) {
            this.properties.put("username", username);
            return (T) this;
        }
    }

    public static class RabbitMQConsumer
            extends
                RabbitMQCommon<RabbitMQConsumer>
            implements
                EndpointDefinition.Consumer {
        public RabbitMQConsumer(String path) {
            super(path);
        }
        /**
         * If messages should be auto acknowledged. The option is a boolean
         * type.
         */
        public RabbitMQConsumer autoAck(boolean autoAck) {
            this.properties.put("autoAck", autoAck);
            return (RabbitMQConsumer) this;
        }
        /**
         * Allows for bridging the consumer to the Camel routing Error Handler,
         * which mean any exceptions occurred while the consumer is trying to
         * pickup incoming messages, or the likes, will now be processed as a
         * message and handled by the routing Error Handler. By default the
         * consumer will use the org.apache.camel.spi.ExceptionHandler to deal
         * with exceptions, that will be logged at WARN or ERROR level and
         * ignored. The option is a boolean type.
         */
        public RabbitMQConsumer bridgeErrorHandler(boolean bridgeErrorHandler) {
            this.properties.put("bridgeErrorHandler", bridgeErrorHandler);
            return (RabbitMQConsumer) this;
        }
        /**
         * Number of concurrent consumers when consuming from broker. (eg
         * similar as to the same option for the JMS component). The option is a
         * int type.
         */
        public RabbitMQConsumer concurrentConsumers(int concurrentConsumers) {
            this.properties.put("concurrentConsumers", concurrentConsumers);
            return (RabbitMQConsumer) this;
        }
        /**
         * Request exclusive access to the queue (meaning only this consumer can
         * access the queue). This is useful when you want a long-lived shared
         * queue to be temporarily accessible by just one consumer. The option
         * is a boolean type.
         */
        public RabbitMQConsumer exclusiveConsumer(boolean exclusiveConsumer) {
            this.properties.put("exclusiveConsumer", exclusiveConsumer);
            return (RabbitMQConsumer) this;
        }
        /**
         * The maximum number of messages that the server will deliver, 0 if
         * unlimited. You need to specify the option of prefetchSize,
         * prefetchCount, prefetchGlobal at the same time. The option is a int
         * type.
         */
        public RabbitMQConsumer prefetchCount(int prefetchCount) {
            this.properties.put("prefetchCount", prefetchCount);
            return (RabbitMQConsumer) this;
        }
        /**
         * Enables the quality of service on the RabbitMQConsumer side. You need
         * to specify the option of prefetchSize, prefetchCount, prefetchGlobal
         * at the same time. The option is a boolean type.
         */
        public RabbitMQConsumer prefetchEnabled(boolean prefetchEnabled) {
            this.properties.put("prefetchEnabled", prefetchEnabled);
            return (RabbitMQConsumer) this;
        }
        /**
         * If the settings should be applied to the entire channel rather than
         * each consumer You need to specify the option of prefetchSize,
         * prefetchCount, prefetchGlobal at the same time. The option is a
         * boolean type.
         */
        public RabbitMQConsumer prefetchGlobal(boolean prefetchGlobal) {
            this.properties.put("prefetchGlobal", prefetchGlobal);
            return (RabbitMQConsumer) this;
        }
        /**
         * The maximum amount of content (measured in octets) that the server
         * will deliver, 0 if unlimited. You need to specify the option of
         * prefetchSize, prefetchCount, prefetchGlobal at the same time. The
         * option is a int type.
         */
        public RabbitMQConsumer prefetchSize(int prefetchSize) {
            this.properties.put("prefetchSize", prefetchSize);
            return (RabbitMQConsumer) this;
        }
        /**
         * To let the consumer use a custom ExceptionHandler. Notice if the
         * option bridgeErrorHandler is enabled then this option is not in use.
         * By default the consumer will deal with exceptions, that will be
         * logged at WARN or ERROR level and ignored. The option is a
         * org.apache.camel.spi.ExceptionHandler type.
         */
        public RabbitMQConsumer exceptionHandler(
                ExceptionHandler exceptionHandler) {
            this.properties.put("exceptionHandler", exceptionHandler);
            return (RabbitMQConsumer) this;
        }
        /**
         * Sets the exchange pattern when the consumer creates an exchange. The
         * option is a org.apache.camel.ExchangePattern type.
         */
        public RabbitMQConsumer exchangePattern(ExchangePattern exchangePattern) {
            this.properties.put("exchangePattern", exchangePattern);
            return (RabbitMQConsumer) this;
        }
        /**
         * The consumer uses a Thread Pool Executor with a fixed number of
         * threads. This setting allows you to set that number of threads. The
         * option is a int type.
         */
        public RabbitMQConsumer threadPoolSize(int threadPoolSize) {
            this.properties.put("threadPoolSize", threadPoolSize);
            return (RabbitMQConsumer) this;
        }
    }

    public static class RabbitMQProducer
            extends
                RabbitMQCommon<RabbitMQProducer>
            implements
                EndpointDefinition.Producer {
        public RabbitMQProducer(String path) {
            super(path);
        }
        /**
         * Allow pass null values to header. The option is a boolean type.
         */
        public RabbitMQProducer allowNullHeaders(boolean allowNullHeaders) {
            this.properties.put("allowNullHeaders", allowNullHeaders);
            return (RabbitMQProducer) this;
        }
        /**
         * If the bridgeEndpoint is true, the producer will ignore the message
         * header of rabbitmq.EXCHANGE_NAME and rabbitmq.ROUTING_KEY. The option
         * is a boolean type.
         */
        public RabbitMQProducer bridgeEndpoint(boolean bridgeEndpoint) {
            this.properties.put("bridgeEndpoint", bridgeEndpoint);
            return (RabbitMQProducer) this;
        }
        /**
         * Get maximum number of opened channel in pool. The option is a int
         * type.
         */
        public RabbitMQProducer channelPoolMaxSize(int channelPoolMaxSize) {
            this.properties.put("channelPoolMaxSize", channelPoolMaxSize);
            return (RabbitMQProducer) this;
        }
        /**
         * Set the maximum number of milliseconds to wait for a channel from the
         * pool. The option is a long type.
         */
        public RabbitMQProducer channelPoolMaxWait(long channelPoolMaxWait) {
            this.properties.put("channelPoolMaxWait", channelPoolMaxWait);
            return (RabbitMQProducer) this;
        }
        /**
         * When true, an exception will be thrown when the message cannot be
         * delivered (basic.return) and the message is marked as mandatory.
         * PublisherAcknowledgement will also be activated in this case. See
         * also publisher acknowledgements - When will messages be confirmed.
         * The option is a boolean type.
         */
        public RabbitMQProducer guaranteedDeliveries(
                boolean guaranteedDeliveries) {
            this.properties.put("guaranteedDeliveries", guaranteedDeliveries);
            return (RabbitMQProducer) this;
        }
        /**
         * This flag tells the server how to react if the message cannot be
         * routed to a queue consumer immediately. If this flag is set, the
         * server will return an undeliverable message with a Return method. If
         * this flag is zero, the server will queue the message, but with no
         * guarantee that it will ever be consumed. If the header is present
         * rabbitmq.IMMEDIATE it will override this option. The option is a
         * boolean type.
         */
        public RabbitMQProducer immediate(boolean immediate) {
            this.properties.put("immediate", immediate);
            return (RabbitMQProducer) this;
        }
        /**
         * This flag tells the server how to react if the message cannot be
         * routed to a queue. If this flag is set, the server will return an
         * unroutable message with a Return method. If this flag is zero, the
         * server silently drops the message. If the header is present
         * rabbitmq.MANDATORY it will override this option. The option is a
         * boolean type.
         */
        public RabbitMQProducer mandatory(boolean mandatory) {
            this.properties.put("mandatory", mandatory);
            return (RabbitMQProducer) this;
        }
        /**
         * When true, the message will be published with publisher
         * acknowledgements turned on. The option is a boolean type.
         */
        public RabbitMQProducer publisherAcknowledgements(
                boolean publisherAcknowledgements) {
            this.properties.put("publisherAcknowledgements", publisherAcknowledgements);
            return (RabbitMQProducer) this;
        }
        /**
         * The amount of time in milliseconds to wait for a basic.ack response
         * from RabbitMQ server. The option is a long type.
         */
        public RabbitMQProducer publisherAcknowledgementsTimeout(
                long publisherAcknowledgementsTimeout) {
            this.properties.put("publisherAcknowledgementsTimeout", publisherAcknowledgementsTimeout);
            return (RabbitMQProducer) this;
        }
    }
}